<!doctype html><html lang=uk dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate # Идея # У меня есть несколько ультралегковесных PHP-скриптов, предоставляющих простой HTTP-API для тех или иных целей. Например, один из таких скриптов выполняет функции управления сетью (реализует протоколы SNMP, Telnet и т.д.) с доступом по HTTP-API. Но чтобы клиент мог эксплуатировать такой простой скрипт, ему необходимо установить и настроить WEB-сервер, РНР со всеми необходимыми расширениями, системные зависимости, такие как iproute2 и прочие и для многих клиентов это оказалось нетривиальной задачей."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate"><meta property="og:description" content="Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate # Идея # У меня есть несколько ультралегковесных PHP-скриптов, предоставляющих простой HTTP-API для тех или иных целей. Например, один из таких скриптов выполняет функции управления сетью (реализует протоколы SNMP, Telnet и т.д.) с доступом по HTTP-API. Но чтобы клиент мог эксплуатировать такой простой скрипт, ему необходимо установить и настроить WEB-сервер, РНР со всеми необходимыми расширениями, системные зависимости, такие как iproute2 и прочие и для многих клиентов это оказалось нетривиальной задачей."><meta property="og:type" content="article"><meta property="og:url" content="https://denisbondar.github.io/post/alpine-php-nginx-logrotate-docker-image/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-10-19T00:00:00+00:00"><meta property="article:modified_time" content="2021-10-19T00:00:00+00:00"><title>Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate | Notes</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6e9dc01763201e1138d92988ddb76ac12def039312e5473a6847a96d89bc05af.css integrity="sha256-bp3AF2MgHhE42SmI3bdqwS3vA5MS5Uc6aEepbYm8Ba8=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/uk.search.min.116be503d01279adbfac91e74b7f8dd1aa2b055df09079810e93fad4c4fc9902.js integrity="sha256-EWvlA9ASea2/rJHnS3+N0aorBV3wkHmBDpP61MT8mQI=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8991816-14","auto"),ga("send","pageview"))</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Пошук aria-label=Пошук maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/post/openvpn-server/>OpenVPN Server</a></li><li><a href=/post/alpine-php-nginx-logrotate-docker-image/ class=active>Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate</a></li><li><a href=/post/postfix-dkim-spf-tls-dmarc/>Персональный почтовый сервер</a></li><li><a href=/post/winbox-wine-tahoma-font/>Winbox в Wine как исправить кривой шрифт</a></li><li><a href=/post/how-to-install-docker-on-linux/>Установка Docker в Linux</a></li><li><a href=/post/phpstorm_docker_xdebug/>PhpStorm + Docker + Xdebug</a></li><li><a href=/post/zfs-manual-rus/>ZFS — Справочник команд</a></li><li><a href=/post/midi-keybiard-jack-bitwig-studio/>Как подключить MIDI клавиатуру к Bitwig Studio</a></li><li><a href=/post/how-to-install-debian-8/>Как установить Debian 8 без знаний и опыта</a></li><li><a href=/post/install-nginx-php7-mysql57-mariadb11-debian-ubuntu/>Установка Nginx 1.13, PHP 7, MySQL 5.7, MariaDB 10.1, PostgreSQL 11 в Debian и Ubuntu</a></li><li><a href=/post/asterisk-13-chan_dongle-debian-8/>Установка Asterisk 13 + chan_dongle (E1550, E1750) на Debian 8</a></li><li><a href=/post/asterisk11-chan_dongle_e1550-ubuntu14/>Asterisk11 Chan_dongle_e1550 Ubuntu14</a></li><li><a href=/post/asterisk-example-2-dongle-call-management/>Asterisk. Пример 2 — SIP и DONGLE</a></li><li><a href=/post/apache24php7win10/>Apache 2.4 + PHP 7 на Windows 7­, 10</a></li><li><a href=/post/simply-install-freebsd/>Как установить FreeBSD с флешки</a></li><li><a href=/post/resize-gpt-psrtition-freebsd/>Изменить размер раздела GPT FreeBSD vmWare</a></li><li><a href=/post/material-design-product-icon-ai/>Как создать иконку приложения в стиле Material Design. Наиболее правильная инструкция</a></li><li><a href=/post/asterisk-example-1-call-between-two-sip-line/>Asterisk. Пример 1 — вызов между двумя линиями SIP</a></li><li><a href=/post/manual-freebsd-install/>Ручная установка FreeBSD на USB flash или HDD</a></li><li><a href=/post/apache24php56win7/>Apache 2.4 + PHP 5.6 + MySQL 5.6 на Windows 7, 10</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#идея>Идея</a></li><li><a href=#цель>Цель</a></li><li><a href=#реализация>Реализация</a><ul><li><a href=#структура-файлов-контекст-сборки>Структура файлов (контекст сборки)</a></li><li><a href=#dockerfile>Dockerfile</a></li></ul></li><li><a href=#сборка-и-запуск>Сборка и запуск</a><ul><li><a href=#сборка>Сборка</a></li><li><a href=#запуск>Запуск</a></li><li><a href=#распространение-образа>Распространение образа</a></li><li><a href=#обновление-образа-на-другой-машине>Обновление образа на другой машине</a></li><li><a href=#обслуживание>Обслуживание</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=докеризация-php-приложения-в-единый-docker-образ-alpinephpnginxlogrotate>Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate
<a class=anchor href=#%d0%b4%d0%be%d0%ba%d0%b5%d1%80%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-php-%d0%bf%d1%80%d0%b8%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f-%d0%b2-%d0%b5%d0%b4%d0%b8%d0%bd%d1%8b%d0%b9-docker-%d0%be%d0%b1%d1%80%d0%b0%d0%b7-alpinephpnginxlogrotate>#</a></h1><h2 id=идея>Идея
<a class=anchor href=#%d0%b8%d0%b4%d0%b5%d1%8f>#</a></h2><p>У меня есть несколько ультралегковесных PHP-скриптов, предоставляющих простой HTTP-API для тех или иных целей. Например, один из таких скриптов выполняет функции управления сетью (реализует протоколы SNMP, Telnet и т.д.) с доступом по HTTP-API. Но чтобы клиент мог эксплуатировать такой простой скрипт, ему необходимо установить и настроить WEB-сервер, РНР со всеми необходимыми расширениями, системные зависимости, такие как iproute2 и прочие и для многих клиентов это оказалось нетривиальной задачей. Так родилась идея поместить в один Docker-образ и скрипт и всё окружение, вместе со всеми необходимыми настройками. По идее, пользователь должен выполнить простую команду <code>docker run ...</code> чтобы всё это магическим образом сразу же заработало без какой-либо необходимости что-то устанавливать и настраивать самостоятельно.</p><h2 id=цель>Цель
<a class=anchor href=#%d1%86%d0%b5%d0%bb%d1%8c>#</a></h2><ol><li>Нам нужен крайне легковесный Docker-образ, включающий в себя сам PHP-скрипт, php-fpm, nginx и остальное окружение, необходимое для работы.</li><li>Доступ по HTTP должен быть только к единственному файлу index.php.</li><li>Службы внутри контейнера должны работать от имени непривилегированного пользователя <strong>nobody</strong>, чтобы сделать контейнер чуточку безопасней.</li><li>Так как клиенты разбросаны по всему миру, нужно чтобы часовой пояс клиента был корректным внутри контейнера, в том числе и для PHP.</li><li>Все сообщения системных процессов (nginx, php и т.д.) должны выводиться на стандартный вывод <code>stdout</code> и <code>stderr</code>, как это требуется для процессов, работающих в контейнерах. Но выводить туда же логи самого PHP-скрипта может быть не совсем целесообразно, хотя и вполне допустимо. Всё же для логов PHP-скрипта условимся использовать отдельный лог-файл, который к тому же должен автоматически ротироваться без участия пользователя.</li></ol><p>Вроде бы всё. Поехали.</p><p>Все необходимые файлы-примеры находятся в репозитории на <a href=https://github.com/denisbondar/alpine-php-nginx-example>GitHub</a>.</p><h2 id=реализация>Реализация
<a class=anchor href=#%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f>#</a></h2><p>Следующее описание будет для нового проекта, который только создается, без привязки к моему конкретному примеру. Итак, начнем с самого минимума.</p><h3 id=структура-файлов-контекст-сборки>Структура файлов (контекст сборки)
<a class=anchor href=#%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2-%d0%ba%d0%be%d0%bd%d1%82%d0%b5%d0%ba%d1%81%d1%82-%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b8>#</a></h3><pre tabindex=0><code>.
├── app
│   └── public
│       └── index.php
├── Dockerfile
└── rootfs
    ├── etc
    │   ├── crontabs
    │   │   └── nobody
    │   ├── logrotate.conf
    │   ├── nginx
    │   │   └── nginx.conf
    │   ├── php7
    │   │   ├── conf.d
    │   │   │   └── custom.ini
    │   │   └── php-fpm.d
    │   │       └── www.conf
    │   └── supervisor
    │       └── conf.d
    │           └── supervisord.conf
    └── usr
        └── bin
            └── docker-entrypoint.sh
</code></pre><p>Показная здесь структура файлов подразумевает, что ваш PHP-проект на локальном компьютере находится в подкаталоге <code>app</code> текущего каталога (например, <code>/home/coolhacker/my-cool-project/app</code>). Если это не так — не страшно. Нужно будет чуть больше манипуляций при создании образа, но не существенно. Далее будет понятно, что и где будет отличаться.</p><p>В данном примере файлы PHP находятся в подкаталоге <code>app</code> проекта, в котором, в свою очередь, находится подкаталог <code>public</code>, содержащий файл <code>index.php</code> — к нему будет указан путь в конфигурации nginx.</p><p>Всё это дерево каталогов и файлов представляет собой контекст сборки Docker-образа.</p><p>Начинать будем с создания файла <code>Dockerfile</code> в корне каталога. В нашем примере это <code>/home/coolhacker/my-cool-project/Dockerfile</code>.</p><h3 id=dockerfile>Dockerfile
<a class=anchor href=#dockerfile>#</a></h3><h4 id=исходный-образ>Исходный образ
<a class=anchor href=#%d0%b8%d1%81%d1%85%d0%be%d0%b4%d0%bd%d1%8b%d0%b9-%d0%be%d0%b1%d1%80%d0%b0%d0%b7>#</a></h4><p>Для сборки собственного образа лучше всего брать исходный образ <strong>Alpine</strong>. Я пробовал построить свой образ на основе образа <strong>php-fpm-alpine</strong>, но в итоге остановился на использовании базового образа <strong>Alpine</strong> в качестве исходного. Первой строкой <code>Dockerfile</code> прописываем инструкцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.14</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Это означает, что за исходный будет взят образ alpine версии 3.14.</p><p>Далее нужно установить весь необходимый софт.</p><h4 id=установка-служб-и-системных-зависимостей>Установка служб и системных зависимостей
<a class=anchor href=#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d1%81%d0%bb%d1%83%d0%b6%d0%b1-%d0%b8-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d1%8b%d1%85-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d0%be%d1%81%d1%82%d0%b5%d0%b9>#</a></h4><p>Здесь остановимся подробней.</p><p>Во-первых, нужно точно понимать, что и зачем добавляется в образ. И, если можно избежать добавления лишних файлов — лучше так и поступить. К счастью, идея Alpine заключается как раз в том, что сама операционная система и дополнительные пакеты содержат минимум файлов, необходимый для их работы. Некоторые пакеты вообще могут состоять из одного единственного файла (как, например, php8). Поэтому важно понимать, что при установке php вы получите только PHP без расширений вообще. То есть только то, что фактически входит в ядро. Не больше.</p><p>Во-вторых, все пакеты легко можно отыскать на сайте <a href=https://pkgs.alpinelinux.org/>https://pkgs.alpinelinux.org/</a> либо по названию пакета, либо по файлу, который необходим.</p><p>В-третьих, расширения PHP лучше устанавливать из пакетов, но можно также воспользоваться и <code>docker-php-ext-install</code>, однако, в таком случае придется устанавливать все зависимости вручную из пакетов.</p><p>Чтобы установить пакеты, в Alpine используется команда <code>apk add</code> после которой идут опции и список пакетов, разделенный пробелом. Пока что добавим в <code>Dockerfile</code> выполнение самой команды и укажем две опции <code>--update</code> чтобы обновить кэш репозитория и <code>--no-cache</code> чтобы не кэшировать индекс (он нам не понадобится внутри образа). Для выполнения команд используется инструкций <code>RUN</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.14</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk add --no-cache --update <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><p>Обратный слэш в конце указывает на то, что команда не завершается и продолжается со следующей строки. Так принято составлять длинные команды, чтобы не писать их целиком в одной длинной нечитаемой строке. Простое удобство форматирования длинной строки.</p><p>Далее будем добавлять строки с необходимыми пакетами.</p><h5 id=nginx>Nginx
<a class=anchor href=#nginx>#</a></h5><p>Установим пакет nginx. Просто добавим название пакета, чтобы получилось:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apk add --no-cache --update <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    nginx <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><h5 id=php>PHP
<a class=anchor href=#php>#</a></h5><p>В данном примере показана установка php7 (по факту будет установлена последняя версия 7.4) и некоторых базовых расширений. Добавляем их:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apk add --no-cache --update <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    nginx <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-fpm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-ctype <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-mbstring <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-json <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-opcache <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><p>Если вы хотите использовать php8 — не проблема. Только следует помнить, что пакет php8 включает один исполняемый файл с именем <code>php8</code>, а пакет php7 включает два исполняемых файла <code>php</code> и <code>php7</code>. Это может быть важно, если вы запускаете какие-то сценарии php из консоли.</p><p>Если вам нужны другие расширения — находите их <a href=https://pkgs.alpinelinux.org/>здесь</a> и добавляйте в список.</p><h5 id=необходимые-системные-утилиты>Необходимые системные утилиты
<a class=anchor href=#%d0%bd%d0%b5%d0%be%d0%b1%d1%85%d0%be%d0%b4%d0%b8%d0%bc%d1%8b%d0%b5-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d1%8b%d0%b5-%d1%83%d1%82%d0%b8%d0%bb%d0%b8%d1%82%d1%8b>#</a></h5><p>Далее добавим следующие системные утилиты, которые понадобятся для работы контейнера:</p><ul><li><strong>curl</strong> — для использования в директиве <code>HEALTHCHECK</code> в <code>Dockerfile</code> для проверки состояния контейнера. Можно не использовать эту директиву, но тогда есть шанс, что зависший php-fpm или nginx остановит работу вашего сервиса, в то время как контейнер будет считаться выполняемым (running);</li><li><strong>tzdata</strong> — для обеспечения поддержки часовых поясов внутри контейнера;</li><li><strong>tini</strong> — не обязательная, но очень желательная утилита — инициализатор процессов init, специально разработанный для запуска в контейнере. Позволяет корректно управлять процессами внутри контейнера и убивать зомби-процессы, не позволяя исчерпать пространство PID. Вместо использования этой утилиты можно запускать контейнер с параметром <code>--init</code>, однако добавление этой утилиты ни коем образом не вредит контейнеру в любом случае;</li><li><strong>supervisor</strong> — так как идеология запуска процессов в линукс-контейнерах подразумевает запуск только одного процесса на контейнер, то в качестве этого одного процесса можно использовать супервизор, задача которого лежит в запуске остальных процессов;</li><li><strong>logrotate</strong> — инструмент для ротации логов, если таковые есть. Вовсе не обязательно использовать ротацию логов внутри контейнера и можно сделать это внешним logrotate из операционной системы хоста. Либо же вообще не писать логи в файлы, а писать их на стандартный вывод. В общем, если необходимо иметь самодостаточный контейнер, который сам еще и логи приложения ротирует, то добавляем;</li><li><strong>dcron</strong> — легковесный crontab. Необходим для периодического запуска процессов внутри контейнера. В данном примере он будет запускать logrotate для периодической ротации логов. Также может пригодиться для периодического запуска каки-то фоновых процессов вашего приложения. Если ни в чем из этого нет необходимости, можно не устанавливать;</li><li><strong>libcap</strong> — инструмент, который используется для запуска cron от имени непривилегированного пользователя. Так как все процессы в целях безопасности в контейнере будут запускаться от имени пользователя <code>nobody</code>, то и cron должен запускаться от имени этого пользователя, что по умолчанию невозможно. Данный инструмент позволяет решить эту задачу. Если не устанавливали dcron, то в этом инструменте тоже нет необходимости.</li></ul><p>Добавляем далее в инструкцию <code>RUN</code> эти инструменты:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> apk add --no-cache --update <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    nginx <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-fpm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-ctype <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-mbstring <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-json <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-opcache <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    curl <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tzdata <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tini <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    supervisor <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    dcron <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    libcap <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><h5 id=действия-после-установки>Действия после установки
<a class=anchor href=#%d0%b4%d0%b5%d0%b9%d1%81%d1%82%d0%b2%d0%b8%d1%8f-%d0%bf%d0%be%d1%81%d0%bb%d0%b5-%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b8>#</a></h5><p>Сперва нужно разобраться с <strong>dcron</strong>. Нам нужно, чтобы он запускался от имени непривилегированного пользователя (что обычно невозможно). Для этого мы установили <strong>libcap</strong>. Назначим владельца файла <code>crond</code> нашего пользователя <code>nobody</code> и изменим setuid-бита на capabilities. Если dcron не устанавливали, то и строки эти добавлять не нужно. Если устанавливали, то добавляем:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> chown nobody:nobody /usr/sbin/crond <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> setcap cap_setgid<span style=color:#f92672>=</span>ep /usr/sbin/crond <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><p>Теперь создадим все необходимые каталоги. Как минимум каталог <code>/app</code> для PHP-файлов. В нашем примере также существует каталог <code>/logs</code> для размещения файлов логов в нем. Добавляем в <code>Dockerfile</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> mkdir -p /app /logs <span style=color:#960050;background-color:#1e0010>\
</span></span></span></code></pre></div><p>Последим действием будет очистка от ненужных файлов. Нужно удалить все временные файлы, все логи, кэши, чтобы образ занимал как можно меньше места. Также удалить все базовые кронтабы (конфиги для cron) и удалить каталог с подключаемыми конфигами ротатора логов logratate — они нам точно не нужны, т.к. мы всё настроим в одном файле. Это ведь контейнер. Добавляем далее:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> rm -rf /tmp/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /var/<span style=color:#f92672>{</span>cache,log<span style=color:#f92672>}</span>/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/logrotate.d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/crontabs/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/periodic/daily/logrotate<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Как видно, последняя строка не содержит обратного слеша в конце — это означает конец строки.</p><p>Целиком весь файл <code>Dockerfile</code> на данный момент выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.14</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk add --no-cache --update <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    nginx <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-fpm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-ctype <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-mbstring <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-json <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    php7-opcache <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    curl <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tzdata <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tini <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    supervisor <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    dcron <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    libcap <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown nobody:nobody /usr/sbin/crond <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> setcap cap_setgid<span style=color:#f92672>=</span>ep /usr/sbin/crond <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> mkdir -p /app /logs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> rm -rf /tmp/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /var/<span style=color:#f92672>{</span>cache,log<span style=color:#f92672>}</span>/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/logrotate.d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/crontabs/* <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    /etc/periodic/daily/logrotate<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Такая длинная строка, состоящая из множества разных команд создает один слой в образе Docker. Чем меньше слоев — тем лучше.</p><p>Поехали дальше.</p><h4 id=копирование-корневой-файловой-системы>Копирование корневой файловой системы
<a class=anchor href=#%d0%ba%d0%be%d0%bf%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%ba%d0%be%d1%80%d0%bd%d0%b5%d0%b2%d0%be%d0%b9-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2%d0%be%d0%b9-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d1%8b>#</a></h4><p>Теперь нам нужно подготовить различные файлы конфигураций, которые будут скопированы в образ с сохранением иерархии. Создадим каталог <code>rootfs</code> там же, где находится файл <code>Dockerfile</code> и всю структуру каталогов внутри (подкаталоги <code>etc</code>, <code>usr</code> и все подкаталоги). Если вам не нужен cron, то не создавайте каталог <code>crontabs</code> и файл крона <code>nobody</code> внутри него; если не нужна ротация логов, не создавайте файл <code>logrotate.conf</code>. Всё остальное повторяйте в точности как есть.</p><p>Далее содержимое каталога <code>rootfs</code> нужно скопировать в корень Docker-образа. Добавляем в <code>Dockerfile</code> следующую инструкцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> rootfs /<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Далее подробней о каждом файле из <code>rootfs</code>:</p><h5 id=etccrontabs>etc/crontabs
<a class=anchor href=#etccrontabs>#</a></h5><p>Внутри <code>crontabs</code> находятся файлы расписаний cron. Имя файла соответствует имени пользователю, от которого будут запущены процессы внутри этого файла расписания. Так как пользователь, от имени которого будут работать все процессы внутри контейнера — <strong>nobody</strong>, то и файл должен иметь <em>такое же имя</em>. Внутри файла одна единственная строка, запускающая службу logrotate ежедневно в 6:30 утра:</p><pre tabindex=0><code>30 6 * * *    /usr/sbin/logrotate -v /etc/logrotate.conf
</code></pre><p>Если вам нужны какие-то еще задачи — добавляйте строки в этот файл, как обычно в crontab.</p><h5 id=etcnginxnginxconf>etc/nginx/nginx.conf
<a class=anchor href=#etcnginxnginxconf>#</a></h5><p>Внутри <code>nginx</code> находятся файлы конфигураций сервера Nginx. Мы изменим только главный файл <code>nginx.conf</code>, остальные оставим как есть. Прямо в главный файл впишем настройку <code>server</code>, так как внутри контейнера он все равно будет один — нет смысла загружать группу конфигураций, как это сделан по умолчанию.</p><p>Логирование в этом файле настраивается на стандартный вывод — <code>/dev/stdout</code> и <code>/dev/stderr</code>.</p><p>В <code>nginx.conf</code> внутри блока <code>server</code> настраивается единственный в контейнере сервер. Причем настраивается таким образом, что доступ разрешен <strong>только к файлу index.php</strong> (и к корню сервера, который считается тем же индексом). Вместо такой конфигурации можно использовать любую другую — как необходимо в вашем конкретном случае. Помимо этого настраивается <code>location ~ ^/(fpm-status|fpm-ping)</code>, необходимый для контроля состояния пула php-fpm.</p><p>Подключения принимаются на порту <strong>8080</strong>, так как nginx будет работать не от суперпользователя и в этом случае желательно использовать порты с номерами выше 1023 во избежание проблем с правами доступа.</p><h5 id=etcphp7confdcustomini>etc/php7/conf.d/custom.ini
<a class=anchor href=#etcphp7confdcustomini>#</a></h5><p>В файле <code>custom.ini</code> настраивается вся необходимая конфигурация php. Вывод ошибок выполняется в <code>/dev/stderr</code> Обратите внимание на настройку часового пояса — он читается из переменной окружения <code>${TZ}</code>. К ней мы еще вернемся позже.</p><h5 id=etcphp7php-fpmdwwwconf>etc/php7/php-fpm.d/www.conf
<a class=anchor href=#etcphp7php-fpmdwwwconf>#</a></h5><p>Файл <code>www.conf</code> содержит настройки пула fpm. В качестве назначения для сообщений об ошибках также указан <code>/dev/stderr</code>. Кроме того, используется файловый сокет (который указан в <code>nginx.conf</code>), включаются служебные эндпоинты для контроля состояния fpm пула. Настраивается менеджер процессов на усредненные значения (так как мы не знаем, какие ресурсы будут доступны контейнеру у клиента).</p><h5 id=etcsupervisorconfdsupervisordconf>etc/supervisor/conf.d/supervisord.conf
<a class=anchor href=#etcsupervisorconfdsupervisordconf>#</a></h5><p>Так как в контейнере можно запустить только один основной процесс, а нам нужно целых три (nginx, php, cron), воспользуемся супервизором — он будет тем самым основным процессом, который породит остальные нужные процессы.</p><p>Здесь стоит отметить важный нюанс: процессы, запускаемые в контейнере, должны работать в foreground, то есть не должны демонизироваться. Обычно у каждого демона есть такой режим работы. Так что, если вам нужно запустить еще какой-то процесс в контейнере, обязательно учитывайте это требование.</p><p>Файл <code>supervisord.conf</code> помимо основной секции настроек содержит три одинаковые секции, отличающиеся только командой, которая будет выполнена. Для каждого из сервисов указывается стандартный вывод в качестве потока вывода журнала.</p><h5 id=etclogrotateconf>etc/logrotate.conf
<a class=anchor href=#etclogrotateconf>#</a></h5><p>Этот файл содержит минимальную базовую конфигурацию ротации лога, а также одну единственную настройку размещения логов с пустыми настройками (будут браться настройки по умолчанию). Если вам нужно задать какие-то иные параметры ротации — укажите их в базовых настройках. Этого будет достаточно. Если же вам нужно ротировать разные файлы журналов по-разному, то внутри фигурных скобок пропишите отличающиеся параметры — они перекроют параметры по умолчанию.</p><p>После того, как файлы скопированы, необходимо изменить владельцев некоторых из них, а также каталогов, которые были созданы ранее. Добавляем в <code>Dockerfile</code> следующую команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> chown -R nobody:nobody /app <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown -R nobody:nobody /logs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown -R nobody:nobody /run <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown -R nobody:nobody /var/lib <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown -R nobody:nobody /var/log/nginx <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> chown -R nobody:nobody /etc/crontabs <span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=переключаемся-на-непривилегированного-пользователя>Переключаемся на непривилегированного пользователя
<a class=anchor href=#%d0%bf%d0%b5%d1%80%d0%b5%d0%ba%d0%bb%d1%8e%d1%87%d0%b0%d0%b5%d0%bc%d1%81%d1%8f-%d0%bd%d0%b0-%d0%bd%d0%b5%d0%bf%d1%80%d0%b8%d0%b2%d0%b8%d0%bb%d0%b5%d0%b3%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d0%be%d0%b3%d0%be-%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d0%b5%d0%bb%d1%8f>#</a></h4><p>Далее нужно сменить пользователя на <strong>nobody</strong>, так как все последующие действия должны быть выполнены от его имени. Добавляем в <code>Dockerfile</code> следующую инструкцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>USER</span><span style=color:#e6db74> nobody</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Делаем каталог <code>/app</code> внутри образа текущим рабочим каталогом. При запуске контейнера из этого образа этот каталог будет каталогом по умолчанию, относительно которого будет выполняться все в контейнере:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=копирование-файлов-php-скрипта-в-docker-образ>Копирование файлов PHP-скрипта в Docker-образ
<a class=anchor href=#%d0%ba%d0%be%d0%bf%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2-php-%d1%81%d0%ba%d1%80%d0%b8%d0%bf%d1%82%d0%b0-%d0%b2-docker-%d0%be%d0%b1%d1%80%d0%b0%d0%b7>#</a></h4><p>Так как все рабочие PHP-файлы находятся в подкаталоге <code>app</code> текущего каталога, то скопировать их в каталог <code>/app</code> образа можно за одно действие. Здесь важно то, что владелец файлов и подкаталогов должен быть <strong>nobody</strong>. Добавляем в <code>Dockerfile</code> следующую инструкцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>COPY</span> --chown<span style=color:#f92672>=</span>nobody:nobody app /app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Если у вас PHP-файлы расположены не в подкаталоге (как в данном примере в подкаталге app), то в простейшем случае придется перечислить все подкаталоги и файлы в инструкции <code>COPY</code>. Последний аргумент — путь назначения.</p><h4 id=объявление-внешних-томов-и-портов>Объявление внешних томов и портов
<a class=anchor href=#%d0%be%d0%b1%d1%8a%d1%8f%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b2%d0%bd%d0%b5%d1%88%d0%bd%d0%b8%d1%85-%d1%82%d0%be%d0%bc%d0%be%d0%b2-%d0%b8-%d0%bf%d0%be%d1%80%d1%82%d0%be%d0%b2>#</a></h4><p>Если приложение ведет файл журнала в каталоге <code>/logs</code>, как это было задано в изначальной задаче, то было бы правильным разместить этот каталог за пределами контейнера в файловой системе хоста, даже если к нему не будет осуществляться доступ напрямую с хоста.</p><p>Ну и единственный порт, который принимает подключения — это порт <strong>8080</strong>. Так как мы запускаем nginx не от имени суперпользователя, то не желательно либо даже невозможно использовать порты с номерами ниже 1024 (они доступны только пользователю root). Поэтому используем привычный порт 8080. В любом случае при запуске контейнера можно опубликовать этот порт на любой другой порт хоста, например, на порт 80.</p><p>Добавляем в <code>Dockerfile</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>VOLUME</span><span style=color:#e6db74> &#34;/logs&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 8080</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=точка-входа-entrypoint>Точка входа ENTRYPOINT
<a class=anchor href=#%d1%82%d0%be%d1%87%d0%ba%d0%b0-%d0%b2%d1%85%d0%be%d0%b4%d0%b0-entrypoint>#</a></h4><p>Инструкция <code>ENTRYPOINT</code> определяет точку входа в контейнер. Команду, вместе с аргументами, которая должна быть выполнена в контейнере при его старте. В качестве дополнительных аргументов для точки входа передаются команда и ее аргументы, указанные при старте контейнера.</p><p>Обычно точкой входа является скрипт с именем наподобие <code>entrypoint.sh</code>, который инициализирует контейнер при старте. Мы будем в такой инициализации устанавливать переменную окружения <code>${TZ}</code>, в которую запишем часовой пояс. Обычно, но не всегда, в самом конце скрипта entrypoint.sh присутствует команда <code>exec</code> которая запускает переданную в аргументах команду.</p><p>Наш скрипт находится в <strong>rootfs</strong> по пути <code>usr/bin/docker-entrypoint.sh</code> и будет скопирован вместе с остальными файлами на сервер. Этот скрипт обязательно должен быть исполняемым (то есть иметь установленный флаг <code>x</code>).</p><p>Для большинства случаев будет достаточно добавить в <code>Dockerfile</code> следующую команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/usr/bin/docker-entrypoint.sh&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Это значит, что если запустить контейнер, указав, например, команду <code>pwd</code>, то фактически при старте контейнера будет выполнена команда <code>/usr/bin/docker-entrypoint.sh pwd</code>.</p><p>Так как у нас установлен специальный инициализатор процессов для контейнеров — <strong>tini</strong>, воспользуемся им в точке входа. Вместо примера выше добавляем в <code>Dockerfile</code> следующую строку:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;/sbin/tini&#34;</span>, <span style=color:#e6db74>&#34;--&#34;</span>, <span style=color:#e6db74>&#34;/usr/bin/docker-entrypoint.sh&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h4 id=выполняемая-по-умолчанию-команда>Выполняемая по умолчанию команда
<a class=anchor href=#%d0%b2%d1%8b%d0%bf%d0%be%d0%bb%d0%bd%d1%8f%d0%b5%d0%bc%d0%b0%d1%8f-%d0%bf%d0%be-%d1%83%d0%bc%d0%be%d0%bb%d1%87%d0%b0%d0%bd%d0%b8%d1%8e-%d0%ba%d0%be%d0%bc%d0%b0%d0%bd%d0%b4%d0%b0>#</a></h4><p>Теперь необходимо указать выполняемую по умолчанию команду. Это та основная команда, которая будет выполняться в контейнере по умолчанию, если при запуске не указать её явно в аргументах <code>docker run</code>.</p><p>Для нашего контейнера таким основным процессом будет супервизор. Именно он должен запуститься как главный процесс и затем он породит все необходимые процессы (nginx, php-fpm, crond), которые будут работать в foreground без демонизации.</p><p>Эту команду можно легко переопределить, передав другую команду в качестве главного аргумента команд <code>docker run</code> или <code>docker exec</code>.</p><p>Однако стоит понимать, что в любом случае команда будет передана в аргументы скрипта, указанного как <code>ENTRYPOINT</code>.</p><p>Добавим в <code>Dockerfile</code> команду по умолчанию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;/usr/bin/supervisord&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;/etc/supervisor/conf.d/supervisord.conf&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Теперь при старте контейнера будет фактически вызываться точка входа вместе с командой, что будет выглядеть следующим образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>/sbin/tini -- /usr/bin/docker-entrypoint.sh /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf
</span></span></code></pre></div><p>На этом можно было бы и закончить, но так как наш контейнер будет выполнять несколько различных процессов, то есть вероятность того, что какой-то из них перестанет работать так, как от него ожидается, в то время как основной процесс (супервизор) будет продолжать работу. В таком случае контейнер будет отображаться как работающий (running), но фактически он будет нерабочий.</p><h4 id=проверка-состояния-контейнера>Проверка состояния контейнера
<a class=anchor href=#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d1%81%d0%be%d1%81%d1%82%d0%be%d1%8f%d0%bd%d0%b8%d1%8f-%d0%ba%d0%be%d0%bd%d1%82%d0%b5%d0%b9%d0%bd%d0%b5%d1%80%d0%b0>#</a></h4><p>Благодаря инструкции <code>HEALTHCHECK</code> можно запускать периодическую проверку жизнеспособности контейнера. В данном примере будем обращаться каждые 30 секунд (по умолчанию) к эндпоинту <code>http://127.0.0.1:8080/fpm-ping</code>. Если последние 3 проверки (по умолчанию) будут провалены, контейнер будет считаться нерабочим.</p><p>Данная проверка позволяет проверить одновременно работу nginx и php-fpm, что довольно неплохо, но вместо этого можно пойти еще дальше и реализовать подобный проверочный эндпоинт у себя в PHP-скрипте, чтобы наверняка проверить работоспособность целиком всей службы, работающей в контейнере.</p><p>Добавим в <code>Dockerfile</code> инструкцию:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>HEALTHCHECK --timeout=10s </span><span style=color:#66d9ef>CMD</span> curl --silent --fail http://127.0.0.1:8080/fpm-ping<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>На этом создание <code>Dockerfile</code> можно считать завершенным.</p><h2 id=сборка-и-запуск>Сборка и запуск
<a class=anchor href=#%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0-%d0%b8-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba>#</a></h2><p>Здесь будут рассмотрен простой способ создания образа, его распространения и запуска. Справку по всем командам и параметрам можно получить из <a href=https://docs.docker.com/engine/reference/commandline/docker/>официальной документации</a>.</p><h3 id=сборка>Сборка
<a class=anchor href=#%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0>#</a></h3><p>При выполнении сборки в файловое пространство демона <code>containerd</code> копируются все файлы из контекста. В нашем случае контекст — это все каталоги и файлы, расположенные там же, где и файл <code>Dockerfile</code>, но если этот файл расположен в другом месте — это можно указать отдельно. В общем случае этот файл располагается там же, где и остальные файлы и здесь рассматривается именно такой вариант.</p><p>Если есть какие-либо файлы или каталоги, попадание которых в пространство сборки не имеет смысла, целесообразно добавить их имена в специальный файл <code>.dockerignore</code>, синтаксис которого целиком аналогичен синтаксису <strong>.gitignore</strong>. Обычно этот файл, как минимум, дублирует <strong>.gitignore</strong>, однако чаще содержит больше записей, ведь игнорируемых при сборке Docker-образа файлов может быть значительно больше, чем игнорируемых для репозитория.</p><p>Для построения образа на основании созданного <code>Dockerfile</code> необходимо запустить команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build --pull --tag<span style=color:#f92672>=</span>my-app-bundle-image .
</span></span></code></pre></div><p>Здесь:</p><ul><li><code>--pull</code> — загружать свежие версии Docker-образов, от которых зависит сборка.</li><li><code>--tag=my-app-bundle-image</code> — финальному образу будет автоматически назначена данная метка. Если образ планируется разместить в <a href=hub.docker.com>Docker-хабе</a>, метка должна состоять из имени пользователя (предприятия) Docker-хаба и через слеш имени образа. Также через двоеточие можно указывать версию. Если версию не указать, она автоматически устанавливается в <code>latest</code>. У одного и того же образа может быть сколько угодно меток. Чаще всего это используется для версионирования, когда новая версия получает новый номер, а также <code>latest</code>.</li><li><code>.</code> — точка в конце строки указывает на путь к контексту. В данном случае это «текущий каталог». Так как не указан параметр <code>--file</code>, то <code>Dockerfile</code> будет использоваться из контекста.</li></ul><p>После выполненя команды получаем готовый Docker-образ, который можно эксплуатировать.</p><h3 id=запуск>Запуск
<a class=anchor href=#%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba>#</a></h3><p>Для запуска контейнера из образа служит комнада <code>docker run</code>. В качестве аргументов этой команде в нашем случае необходимо обязательно передать каталог, который будет отображаться на каталог <code>/logs</code> внутри контейнера (для записи логов), а также опубликовать порт контейнера на порт хоста (по умолчанию в режиме моста).</p><p>Сперва необходимо создать каталог для логов. Создадим его прямо здесь, после чего добавим его в <code>.gitignore</code> и в <code>.dockerignore</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir -p log
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>777</span> log
</span></span></code></pre></div><p>Помимо этого мы передадим некоторые дополнительные аргументы, значение которых будет описано далее.</p><p>Для проверочного запуска контейнера из образа выполните команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -it --name<span style=color:#f92672>=</span>my-app-container <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -p 80:8080 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v <span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span>/log:/logs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/localtime:/etc/localtime:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/timezone:/etc/timezone:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    my-app-bundle-image
</span></span></code></pre></div><p>Где:</p><ul><li><code>-it</code> — запуск в интерактивном режиме (подключение STDIN/STDOUT) и с созданием псевдо-TTY.</li><li><code>--name=my-app-container</code> — контейнер после запуска будет иметь имя <strong>my-app-container</strong>, чтобы можно было обращаться к нему по этому заведомо известному имени. Если не задать имя, то оно будет выбрано случайным образом.</li><li><code>-p 80:8080</code> — публикация порта контейнера 8080 на 80й порт локального хоста.</li><li><code>-v $(pwd)/log:/logs</code> — подключение локального тома <code>log</code> к каталогу <code>/logs</code> внутри контейнера.</li><li><code>-v /etc/localtime:/etc/localtime:ro</code> и <code>-v /etc/timezone:/etc/timezone:ro</code> — транслировать внутрь контейнера файлы с часовым поясом и локальным временем. Это позволит получить часовой пояс внутри контейнера точно такой же, как и на хосте, а при старте контейнера скрипт точки входа дополнительно установит переменную окружения с часовым поясом, которую использует php.</li><li><code>my-app-bundle-image</code> — имя образа (метка), на базе которого будет запущен контейнер</li></ul><p>Запустится контейнер. В консоль начнут поступать сообщения о запуске процессов супервизором. Попробуйте открыть страницу в браузере http://127.0.0.1/ — вы увидите вывод <code>phpinfo()</code>. Также будет создан файл журнала, в который будет помещена одна строка. Проверьте это.</p><p>Чтобы контейнер работал в фоне, автоматически запускался при старте системы и перезапускался при падении, аргументы запуска следует немного изменить. Остановите выполнение текущего контейнера комбинацией клавиш <code>Ctrl+C</code> и выполните следующую команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d --name<span style=color:#f92672>=</span>my-app-container <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --restart<span style=color:#f92672>=</span>always
</span></span><span style=display:flex><span>    -p 80:8080 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v <span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span>/log:/logs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/localtime:/etc/localtime:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/timezone:/etc/timezone:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    my-app-bundle-image
</span></span></code></pre></div><p>Здесь:</p><ul><li><code>-d</code> — запускать контейнер в фоне (поэтому ключи <code>-it</code> больше не нужны);</li><li><code>--restart=always</code> — запускать контейнер при старте системы и всегда перезапускать при сбое (бесконечное число попыток). Вместо этого можно задать <a href=https://docs.docker.com/engine/reference/commandline/run/#restart-policies---restart>другие варианты</a>.</li></ul><p>Контейнер будет запущен в фоне и вы получите командную строку оболочки. Попробуйте снова открыть страницу в браузере, понаблюдайте за логом при многократном обновлении страницы.</p><p>Теперь, чтобы остановить контейнер, выполните команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker stop my-app
</span></span></code></pre></div><p>Контейнер при этом не удаляется. Чтобы его снова запустить. выполните команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker start my-app
</span></span></code></pre></div><h3 id=распространение-образа>Распространение образа
<a class=anchor href=#%d1%80%d0%b0%d1%81%d0%bf%d1%80%d0%be%d1%81%d1%82%d1%80%d0%b0%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%b0>#</a></h3><h4 id=hubdockercom>hub.docker.com
<a class=anchor href=#hubdockercom>#</a></h4><p>Самый простой способ распространения — загрузка в Docker-hub. Для этого нужно создать учетную запись на сайте <a href=https://hub.docker.com/>https://hub.docker.com/</a> и присвоить метку образу в требуемом формате <code>имя_пользователя/название_образа:версия</code>. Версию можно не указывать — в этом случае будет автоматически использовано <code>latest</code>.</p><p>Чтобы назначить еще одну метку образу, выплоните команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker tag my-app-bundle-image coolhacker/my-app-bundle-image
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker images | grep my-app-bundle
</span></span></code></pre></div><p>Теперь в спике образов видны два образа с одинаковым хэшем. На самом деле это один и тот же образ, но с двумя разными метками.</p><p>Тоже самое, если необходимо версионировать образы.</p><p>Для загрузки испльзуется команда:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker push coolhacker/my-app-bundle-image
</span></span></code></pre></div><p>Если нужно загрузить все метки, которые присвоены указанному образу, можно просто воспользоваться аргументом <code>--all</code>.</p><h4 id=tarball>tarball
<a class=anchor href=#tarball>#</a></h4><p>Второй способ распространения — сохранение образа в <strong>tar</strong>. Это стандартный архив UNIX без сжатия. Чтобы сохранить образ в архив просто выполните команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker save my-app-bundle-image -o my-app-bundle-image.tar
</span></span></code></pre></div><p>Вместо сохранения в файл можно вывести содержимое на стандартный вывод и перенаправить поток в gzip для сжатия.</p><p>Чтобы загрузить сохраненный таким способом образ на другой машине, скопируйте туда файл и выполните:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker load -i my-app-bundle-image.tar
</span></span></code></pre></div><p>Вместо этого можно воспользоваться стандартный вводом, чтобы прочитать tar или сжатый архив.</p><h3 id=обновление-образа-на-другой-машине>Обновление образа на другой машине
<a class=anchor href=#%d0%be%d0%b1%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%b0-%d0%bd%d0%b0-%d0%b4%d1%80%d1%83%d0%b3%d0%be%d0%b9-%d0%bc%d0%b0%d1%88%d0%b8%d0%bd%d0%b5>#</a></h3><p>Если вы распространяете образ с вашим приложением клиентам, но чтобы они имели возможность обновиться, нужно выполнить следующие действия:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker stop my-app
</span></span><span style=display:flex><span>docker rm my-app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dockrt pull coolhacker/my-app-bundle-image <span style=color:#75715e># если используется docker-hub</span>
</span></span><span style=display:flex><span>docker load -i my-app-bundle-image.tar <span style=color:#75715e># если используется распространение tarball</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker run -d --name<span style=color:#f92672>=</span>my-app-container <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --restart<span style=color:#f92672>=</span>always
</span></span><span style=display:flex><span>    -p 80:8080 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v <span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span>/log:/logs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/localtime:/etc/localtime:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -v /etc/timezone:/etc/timezone:ro <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    my-app-bundle-image
</span></span></code></pre></div><p>Принцип теперь уже точно должен быть понятен.</p><h3 id=обслуживание>Обслуживание
<a class=anchor href=#%d0%be%d0%b1%d1%81%d0%bb%d1%83%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5>#</a></h3><p>В процессе эксплуатации возможно понадобиться подключиться к работающему контейнеру, чтобы что-то проверить.
Это можно сделать при помощи команды:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker exec -it my-app-container sh
</span></span></code></pre></div><p>Вызов этой команды приведет к тому, что в работающем контейнере через точку входа будет выполнена команда <code>sh</code> а также будет подключен стандартный ввод/вывод и создан псевдо-TTY. В результате вы получите shell-доступ в контейнер, который выполняется. Можно посмотреть список процессов либо что угодно еще. Для отключения — <code>Ctrl+C</code>.</p><p>Уничтожить контейнер можно при помощи команды:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker stop my-app-container
</span></span><span style=display:flex><span>docker rm my-add-container
</span></span></code></pre></div><p>Уничтожить метку образа можно при помощи команды:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker rmi my-app-bundle-image
</span></span></code></pre></div><p>Если у образа больше не осталось меток, то будет уничтожен и сам образ.</p><p>Спасибо за внимание.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-denisbondar-com.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#идея>Идея</a></li><li><a href=#цель>Цель</a></li><li><a href=#реализация>Реализация</a><ul><li><a href=#структура-файлов-контекст-сборки>Структура файлов (контекст сборки)</a></li><li><a href=#dockerfile>Dockerfile</a></li></ul></li><li><a href=#сборка-и-запуск>Сборка и запуск</a><ul><li><a href=#сборка>Сборка</a></li><li><a href=#запуск>Запуск</a></li><li><a href=#распространение-образа>Распространение образа</a></li><li><a href=#обновление-образа-на-другой-машине>Обновление образа на другой машине</a></li><li><a href=#обслуживание>Обслуживание</a></li></ul></li></ul></nav></div></aside></main></body></html>