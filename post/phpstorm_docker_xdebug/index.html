<!doctype html><html lang=uk dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PhpStorm + Docker + Xdebug # Внимание! Статья технически устарела. Обратитесь к репозиторию — он поддерживается в актуальном состоянии.
В этой небольшой статье я опишу рабочее решение настройки Xdebug для использования его при отладке в PhpStorm с использованием удаленного интерпретатора PHP, работающего внутри Docker-контейнера.
В итоге получится конфигурация на базе окружения в Docker-контейнерах, которая позволит производить отладку Web-приложения, консольного приложения, тестов, запускаемых из консоли и запускаемых из PhpStorm.
Исходные данные # У вас должны быть установлены Linux, PhpStorm, Docker, Docker-compose."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="PhpStorm + Docker + Xdebug"><meta property="og:description" content="PhpStorm + Docker + Xdebug # Внимание! Статья технически устарела. Обратитесь к репозиторию — он поддерживается в актуальном состоянии.
В этой небольшой статье я опишу рабочее решение настройки Xdebug для использования его при отладке в PhpStorm с использованием удаленного интерпретатора PHP, работающего внутри Docker-контейнера.
В итоге получится конфигурация на базе окружения в Docker-контейнерах, которая позволит производить отладку Web-приложения, консольного приложения, тестов, запускаемых из консоли и запускаемых из PhpStorm.
Исходные данные # У вас должны быть установлены Linux, PhpStorm, Docker, Docker-compose."><meta property="og:type" content="article"><meta property="og:url" content="https://denisbondar.github.io/post/phpstorm_docker_xdebug/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-18T00:00:00+00:00"><title>PhpStorm + Docker + Xdebug | Notes</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6e9dc01763201e1138d92988ddb76ac12def039312e5473a6847a96d89bc05af.css integrity="sha256-bp3AF2MgHhE42SmI3bdqwS3vA5MS5Uc6aEepbYm8Ba8=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/uk.search.min.116be503d01279adbfac91e74b7f8dd1aa2b055df09079810e93fad4c4fc9902.js integrity="sha256-EWvlA9ASea2/rJHnS3+N0aorBV3wkHmBDpP61MT8mQI=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-8991816-14","auto"),ga("send","pageview"))</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Notes</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Пошук aria-label=Пошук maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/post/openvpn-server/>OpenVPN Server</a></li><li><a href=/post/alpine-php-nginx-logrotate-docker-image/>Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate</a></li><li><a href=/post/postfix-dkim-spf-tls-dmarc/>Персональный почтовый сервер</a></li><li><a href=/post/winbox-wine-tahoma-font/>Winbox в Wine как исправить кривой шрифт</a></li><li><a href=/post/how-to-install-docker-on-linux/>Установка Docker в Linux</a></li><li><a href=/post/phpstorm_docker_xdebug/ class=active>PhpStorm + Docker + Xdebug</a></li><li><a href=/post/zfs-manual-rus/>ZFS — Справочник команд</a></li><li><a href=/post/midi-keybiard-jack-bitwig-studio/>Как подключить MIDI клавиатуру к Bitwig Studio</a></li><li><a href=/post/how-to-install-debian-8/>Как установить Debian 8 без знаний и опыта</a></li><li><a href=/post/install-nginx-php7-mysql57-mariadb11-debian-ubuntu/>Установка Nginx 1.13, PHP 7, MySQL 5.7, MariaDB 10.1, PostgreSQL 11 в Debian и Ubuntu</a></li><li><a href=/post/asterisk-13-chan_dongle-debian-8/>Установка Asterisk 13 + chan_dongle (E1550, E1750) на Debian 8</a></li><li><a href=/post/asterisk11-chan_dongle_e1550-ubuntu14/>Asterisk11 Chan_dongle_e1550 Ubuntu14</a></li><li><a href=/post/asterisk-example-2-dongle-call-management/>Asterisk. Пример 2 — SIP и DONGLE</a></li><li><a href=/post/apache24php7win10/>Apache 2.4 + PHP 7 на Windows 7­, 10</a></li><li><a href=/post/simply-install-freebsd/>Как установить FreeBSD с флешки</a></li><li><a href=/post/resize-gpt-psrtition-freebsd/>Изменить размер раздела GPT FreeBSD vmWare</a></li><li><a href=/post/material-design-product-icon-ai/>Как создать иконку приложения в стиле Material Design. Наиболее правильная инструкция</a></li><li><a href=/post/asterisk-example-1-call-between-two-sip-line/>Asterisk. Пример 1 — вызов между двумя линиями SIP</a></li><li><a href=/post/manual-freebsd-install/>Ручная установка FreeBSD на USB flash или HDD</a></li><li><a href=/post/apache24php56win7/>Apache 2.4 + PHP 5.6 + MySQL 5.6 на Windows 7, 10</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>PhpStorm + Docker + Xdebug</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#исходные-данные>Исходные данные</a></li><li><a href=#пример-конфигурации>Пример конфигурации</a><ul><li><a href=#docker-composeyml>docker-compose.yml</a></li><li><a href=#dockerphp-fpmdockerfile>docker/php-fpm/Dockerfile</a></li><li><a href=#dockerphp-fpmphpini>docker/php-fpm/php.ini</a></li><li><a href=#dockernginxdockerfile>docker/nginx/Dockerfile</a></li><li><a href=#dockernginxdefaultconf>docker/nginx/default.conf</a></li></ul></li><li><a href=#настройка-phpstorm>Настройка PhpStorm</a><ul><li><a href=#добавить-docker-сервер>Добавить Docker сервер</a></li><li><a href=#добавить-внешний-интерпретатор>Добавить внешний интерпретатор</a></li><li><a href=#проверить-конфигурацию-xdebug>Проверить конфигурацию Xdebug</a></li><li><a href=#добавить-php-сервер>Добавить PHP сервер</a></li><li><a href=#добавить-конфигурацию-для-запуска>Добавить конфигурацию для запуска</a></li></ul></li><li><a href=#упрощенный-способ-взаимодействия-с-контейнерами>Упрощенный способ взаимодействия с контейнерами</a></li><li><a href=#запуск-отладки>Запуск отладки</a><ul><li><a href=#отладка-web-приложения>Отладка WEB-приложения</a></li><li><a href=#отладка-консольного-приложения-cli>Отладка консольного приложения (CLI)</a></li><li><a href=#отладка-тестов-phpunit>Отладка тестов (PhpUnit)</a></li></ul></li><li><a href=#резюме>Резюме</a></li></ul></nav></aside></header><article class=markdown><h1 id=phpstorm--docker--xdebug>PhpStorm + Docker + Xdebug
<a class=anchor href=#phpstorm--docker--xdebug>#</a></h1><p><img src=banner.png alt>
<strong>Внимание! Статья технически устарела. Обратитесь <a href=https://github.com/denisbondar/docker_php-fpm_xdebug>к репозиторию</a> — он поддерживается в актуальном состоянии.</strong></p><p>В этой небольшой статье я опишу рабочее решение настройки <a href=https://xdebug.org/>Xdebug</a> для использования его при отладке в PhpStorm с использованием удаленного интерпретатора PHP, работающего внутри Docker-контейнера.</p><p>В итоге получится конфигурация на базе окружения в Docker-контейнерах, которая позволит производить отладку Web-приложения, консольного приложения, тестов, запускаемых из консоли и запускаемых из PhpStorm.</p><h2 id=исходные-данные>Исходные данные
<a class=anchor href=#%d0%b8%d1%81%d1%85%d0%be%d0%b4%d0%bd%d1%8b%d0%b5-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5>#</a></h2><p>У вас должны быть установлены Linux, PhpStorm, Docker, Docker-compose. У меня в блоге <a href=https://denisbondar.github.io/post/how-to-install-docker-on-linux/>есть небольшая памятка</a>, как установить Docker и docker-compose в Linux. Если Вы ведете разработку не на Linux, то Вам, наверное, придется чуть сложнее, но раз Вы читаете эту статью, значит Вы уже озадачились вопросом отладки с использованием php в контейнере Docker и у Вас уже всё давно установлено. Если настройки для MacOS или Windows будут отличаться от приведенных в статье, я обязательно укажу на это.</p><p>Статья будет рассмотрена на следующем примере. Каталог на локальной машине (хосте), в котором планируется разработать некоторое приложение: <code>/home/denis/code/docker-xdebug</code>. При этом корень Web-сервера находится в подкаталоге <code>public</code>. Основной каталог проекта отображается внутрь Docker-контейнеров на каталог <code>/var/www</code>. Внутри Docker-контейнера, при этом, получаем путь к корневому каталогу Web-сервера <code>/var/www/public</code> — именно на него настроен Web-сервер nginx.</p><h2 id=пример-конфигурации>Пример конфигурации
<a class=anchor href=#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80-%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b0%d1%86%d0%b8%d0%b8>#</a></h2><p>На самом деле, поставленная задача достаточно тривиальная. Все решения, которые мне удавалось находить ранее, были завязаны на IP-адресе хоста и их невозможно было использовать остальными членами команды, так как в каждом новом случае IP-адрес хоста был случайный и каждому члену команды приходилось бы менять IP-адрес на свой в общем файле конфигурации бандла, что крайне неудобно.</p><p>Решение проблемы оказалось достаточно простым. Я просто создал общую сеть для бандла в docker-compose (192.168.220.0/28) и таким образом добился одинакового IP-адреса хоста (192.168.220.1) на всех машинах членов команды разработки.</p><p>Если Вы используете MacOS или Windows, то вместо адреса <strong>192.168.220.1</strong> Вам нужно будет указать <strong>host.docker.internal</strong> в приведенном ниже <code>docker-compose.yml</code>.</p><p>Ниже приведу подробную инструкцию и все файлы, необходимые для сборки бандла с рабочей отладкой Xdebug.</p><p>В файлах отсутствует установка каких либо дополнительных зависимостей и расширений, так как в каждом проекте они свои. Это выходит за рамки данной статьи. Вы должны сами добавить их при необходимости.</p><h3 id=docker-composeyml>docker-compose.yml
<a class=anchor href=#docker-composeyml>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#39;3&#39;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>php-fpm</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>docker/php-fpm</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./:/var/www</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>XDEBUG_CONFIG</span>: <span style=color:#e6db74>&#34;remote_host=192.168.220.1 remote_enable=1&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>PHP_IDE_CONFIG</span>: <span style=color:#e6db74>&#34;serverName=Docker&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>internal</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>nginx</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>build</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>context</span>: <span style=color:#ae81ff>docker/nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./:/var/www</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;80:80&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>depends_on</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>php-fpm</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>internal</span>
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>internal</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>driver</span>: <span style=color:#ae81ff>bridge</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ipam</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>driver</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>config</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>subnet</span>: <span style=color:#ae81ff>192.168.220.0</span><span style=color:#ae81ff>/28</span>
</span></span></code></pre></div><p>Если у вас MacOS или Windows, то вместо <code>remote_host=192.168.220.1</code> используйте <code>remote_host=host.docker.internal</code>.</p><h3 id=dockerphp-fpmdockerfile>docker/php-fpm/Dockerfile
<a class=anchor href=#dockerphp-fpmdockerfile>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> php:7.2-fpm</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y wget git unzip <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> pecl install xdebug-2.7.1 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> docker-php-ext-enable xdebug<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> ./php.ini /usr/local/etc/php/php.ini<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> wget https://getcomposer.org/installer -O - -q <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    | php -- --install-dir<span style=color:#f92672>=</span>/bin --filename<span style=color:#f92672>=</span>composer --quiet<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /var/www</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=dockerphp-fpmphpini>docker/php-fpm/php.ini
<a class=anchor href=#dockerphp-fpmphpini>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>max_execution_time</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>1000</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>max_input_time</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>1000</span>
</span></span></code></pre></div><p>Это необходимо для того, чтобы Вы успели изучить результаты отладки до истечения таймаута запроса.</p><h3 id=dockernginxdockerfile>docker/nginx/Dockerfile
<a class=anchor href=#dockernginxdockerfile>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> nginx</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ADD</span> ./default.conf /etc/nginx/conf.d/default.conf<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /var/www</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=dockernginxdefaultconf>docker/nginx/default.conf
<a class=anchor href=#dockernginxdefaultconf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=display:flex><span><span style=color:#66d9ef>server</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>listen</span> <span style=color:#ae81ff>80</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>index</span> <span style=color:#e6db74>index.php</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>server_name</span> <span style=color:#ae81ff>127</span><span style=color:#e6db74>.0.0.1</span> <span style=color:#e6db74>localhost</span>;
</span></span><span style=display:flex><span>    <span style=color:#f92672>root</span> <span style=color:#e6db74>/var/www/public</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> <span style=color:#e6db74>/</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>try_files</span> $uri <span style=color:#e6db74>/index.php?</span>$args;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>location</span> ~ <span style=color:#e6db74>\.php$</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_split_path_info</span> <span style=color:#e6db74>^(.+\.php)(/.+)</span>$;
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_pass</span> php-fpm:<span style=color:#ae81ff>9000</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_index</span> <span style=color:#e6db74>index.php</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_read_timeout</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>include</span> <span style=color:#e6db74>fastcgi_params</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_param</span> <span style=color:#e6db74>SCRIPT_FILENAME</span> $document_root$fastcgi_script_name;
</span></span><span style=display:flex><span>        <span style=color:#f92672>fastcgi_param</span> <span style=color:#e6db74>PATH_INFO</span> $fastcgi_path_info;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Теперь просто запускаем бандл docker-контейнеров:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker-compose up -d --build
</span></span></code></pre></div><h2 id=настройка-phpstorm>Настройка PhpStorm
<a class=anchor href=#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0-phpstorm>#</a></h2><p>Настройка отладки в PhpStorm типичная для подобных ситуаций. Необходимо в настройках <code>File » Settings</code> проделать следующее.</p><h3 id=добавить-docker-сервер>Добавить Docker сервер
<a class=anchor href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%b8%d1%82%d1%8c-docker-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80>#</a></h3><p>Если он у Вас еще не добавлен, конечно. Для этого откройте настройки: <code>Build, Execution, Deployment » Docker</code>. Затем нажмите плюсик, чтобы добавить новое подключение к докеру. У меня все подключилось сразу же в режиме <strong>Unix socket</strong>. Нажмите <code>Apply</code>.
<img src=Add-Docker-Server.png alt>
<em>Добавление нового Docker сервера</em></p><h3 id=добавить-внешний-интерпретатор>Добавить внешний интерпретатор
<a class=anchor href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%b8%d1%82%d1%8c-%d0%b2%d0%bd%d0%b5%d1%88%d0%bd%d0%b8%d0%b9-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d0%bf%d1%80%d0%b5%d1%82%d0%b0%d1%82%d0%be%d1%80>#</a></h3><p>Откройте настройки: <code>Languages & Frameworks » PHP</code>. Справа от CLI Interpreter нажмите кнопку с тремя точками.
<img src=Languages-PHP72.png alt>
<em>Выбор версии PHP и добавление интерпретатора</em></p><p>В открывшемся окне CLI Interpreters нажмите плюс слева вверху и выберите там <code>From Docker...</code>.</p><p>Далее нужно выбрать <strong>Docker</strong> (либо в новых версиях PhpStorm можно также выбрать <strong>Docker Compose</strong>). Второй вариант мне показался удобней, так как в этом случае я вижу контейнеры только данного проекта, а не все существующие на хосте (у меня их довольно много).
<img src=Configure-remote-interpreter-docker.png alt>
<em>Docker</em>
<img src=Configure-remote-interpreter-docker-compose.png alt>
<em>Docker Compose</em></p><p>Не забывайте правильно указывать наименование образа или сервиса. Нажмите ОК, после чего будет произведена попытка добавления выбранного интерпретатора из Docker.</p><p>В случае удачи, вы увидите следующее окно (здесь видно, что была определена версия PHP, конфигурационный файл PHP, а также, что очень важно, версия Xdebug. Переименуйте интерпретатор в нечто более понятное, например, как на скриншоте ниже.</p><p>Начиная с версии PhpStorm 2019.1 появилась возможность выбора, каким образом запускать тесты в контейнере. Если у вас контейнер с постоянно работающей службой, такой как <strong>php-fpm</strong>, то выбирайте <strong>Connect to existent container</strong>. Если же у вас в качестве интерпретатора используется <strong>php-cli</strong>, который не выполняется постоянно, то выберите опцию <strong>Always start a new container</strong>. Нажмите OK.
<img src=CLI-Interpreters-Docker-PHP72.png alt>
<em>Настройка интерпретатора PHP</em></p><p>Теперь Вы должны увидеть следующее:
<img src=Languages-PHP72-With-Docker.png alt>
<em>Path mappings берется из docker-compose.yml</em></p><p>Нажмите <code>Apply</code>.</p><h3 id=проверить-конфигурацию-xdebug>Проверить конфигурацию Xdebug
<a class=anchor href=#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%b8%d1%82%d1%8c-%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b0%d1%86%d0%b8%d1%8e-xdebug>#</a></h3><p>Откройте настройки: <code>Languages & Frameworks » PHP » Debug</code>. И нажмите на ссылку <code>Validate</code>.
<img src=Languages-PHP-Debug.png alt>
<em>Нажмите Validate для проверки настройки</em></p><p>Откроется окно, в котором Вы должны указать полный путь к web-корню (в нашем примере это подкаталог проекта <strong>public</strong>) и адрес сервера (в нашем примере порт 80 контейнера nginx транслируется в порт 80 хоста, поэтому в адресе порт не указывается. Если Вы транслировали в другой порт хоста — укажите обязательно его, например, http://127.0.0.1:8080). Нажмите <code>Validate</code>.
<img src=Xdebug271-validate-result.png alt>
<em>Результаты проверки Xdebug</em></p><p>Если у Вас результат проверки выглядит так же, то Вы все настроили правильно. Закройте окно Validate Debugger Configuration.</p><p>Если у Вас проблема с валидацией имени сервера, значит вы в настройках сервера nginx не указали 127.0.0.1 в качестве одного из <code>server_name</code>. Если проблема с загрузкой php.ini, значит вы использовали другой способ конфигурирования PHP вместо загрузки php.ini в каталог контейнера <code>/usr/local/etc/php/</code> — это не страшно, если Вы понимаете, что делаете.</p><h3 id=добавить-php-сервер>Добавить PHP сервер
<a class=anchor href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%b8%d1%82%d1%8c-php-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80>#</a></h3><p>Откройте настройки: <code>Languages & Frameworks » PHP » Servers</code> и нажмите плюсик, чтобы добавить новый.</p><p>Укажите имя сервера <strong>Docker</strong> (должно совпадать с переменной окружения <code>PHP_IDE_CONFIG</code> в docker-compose.yml) и хост <strong>127.0.0.1</strong>. Затем ниже включите опцию <strong>Use path mappings</strong> и укажите соответствие между локальным каталогом проекта и этим же каталогом проекта внутри Docker-контейнера. Это соответствие изначально настраивается в docker-composer.yml для службы php-fpm в разделе <code>volumes</code>. Затем нажмите <code>OK</code>.
<img src=PHP-Server-with-Mapping.png alt>
<em>Новый PHP сервер с отображением локального каталога на каталог контейнера</em></p><h3 id=добавить-конфигурацию-для-запуска>Добавить конфигурацию для запуска
<a class=anchor href=#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%b8%d1%82%d1%8c-%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b0%d1%86%d0%b8%d1%8e-%d0%b4%d0%bb%d1%8f-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba%d0%b0>#</a></h3><p>Остался последний штрих — добавление конфигурации запуска. Мы добавим простую Web-страницу.</p><p>В главном меню <strong>Run</strong> перейдите в <strong>Edit configurations&mldr;</strong></p><p>В открывшемся окне нажимайте плюсик вверху слева и выбирайте <strong>PHP Web page</strong>. Укажите имя для данной страницы, например, <strong>WWW</strong>, затем укажите сервер, с которым связана эта страница (мы создали его на предыдущем шаге) и нажмите <code>OK</code>.
<img src=Run-Debug-Configuration.png alt>
<em>Конфигурация Web сервера для отладки</em></p><h2 id=упрощенный-способ-взаимодействия-с-контейнерами>Упрощенный способ взаимодействия с контейнерами
<a class=anchor href=#%d1%83%d0%bf%d1%80%d0%be%d1%89%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9-%d1%81%d0%bf%d0%be%d1%81%d0%be%d0%b1-%d0%b2%d0%b7%d0%b0%d0%b8%d0%bc%d0%be%d0%b4%d0%b5%d0%b9%d1%81%d1%82%d0%b2%d0%b8%d1%8f-%d1%81-%d0%ba%d0%be%d0%bd%d1%82%d0%b5%d0%b9%d0%bd%d0%b5%d1%80%d0%b0%d0%bc%d0%b8>#</a></h2><p>Для управления контейнерами, вам придется использовать длинные команды вроде:</p><pre tabindex=0><code>docker-compose up -d
docker-compose down -v --remove-orphans
docker-compose logs -f
и так далее...
</code></pre><p>Но это не самое сложное. Самое сложное заключается в том, что теперь для запуска тестов вам придется вызывать сценарии внутри контейнеров. Например, чтобы запустить конкретный набор тестов, вам придется ввести следующую команду:</p><pre tabindex=0><code>docker-compose run --rm php-fpm vendor/bin/phpunit --testsuite unit
</code></pre><p>Постоянный ввод таких команд — вырабатывает хорошую привычку, но быстро надоест. Ведь это можно упростить!</p><p>Для этого создайте в корне проекта файл (например, с именем <code>alias.bash</code>), содержащий псевдонимы команд, а затем настройте PhpStorm таким образом, чтобы он подключал его при открытии терминала. В Git-репозитории, ссылка на который приведена в конце статьи, вы найдете все необходимые файлы из этой статьи, включая файл <code>alias.bash</code>, который уже содержит некоторые самые необходимые команды в более развернутом виде, который будет удобней для редактирования и поддержки.</p><p>Ваш файл <code>alias.bash</code> может, например, выглядеть следующим, упрощенным образом:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>alias env-up<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker-compose up -d&#39;</span>
</span></span><span style=display:flex><span>alias env-stop<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker-compose stop&#39;</span>
</span></span><span style=display:flex><span>alias phpunit<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker-compose run --rm php-fpm vendor/bin/phpunit&#39;</span>
</span></span></code></pre></div><p>Псевдонимы могут работать с параметрами. Это видно в последнем псевдониме — сценарию phpunit передаются все параметры, с которыми был вызван псевдоним. Такие псевдонимы можно назвать своего рода прокси-командами.</p><p>Чтобы файл с псевдонимами применялся при открытии сессии терминала в PhpStorm, откройте настройки: <code>Tools » Terminal</code> и в поле <strong>Shell path</strong> введите:</p><pre tabindex=0><code>/bin/bash --rcfile alias.bash
</code></pre><p><img src=phpstorm-shell-command.png alt>
<em>Настройка загрузки файла с псевдонимами при старте сессии оболочки в PhpStorm</em></p><p>Теперь откройте терминал в PhpStorm <code>Alt+F12</code>. Если он уже был открыт, то нужно закрыть и открыть снова. Теперь попробуйте просто выполнить команду <code>env-up</code> и Вы увидите, что фактически выполнилась команда <code>docker-compose up -d</code>.</p><p>Вы можете составлять псевдонимы любой сложности, включая составные, состоящие из других псевдонимов. Это позволяет сосредоточиться на разработке, не отвлекаясь на составление команд для запуска чего либо внутри контейнера вручную.</p><h2 id=запуск-отладки>Запуск отладки
<a class=anchor href=#%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d0%ba-%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b8>#</a></h2><p>Теперь пришло время приступить к самой отладке.</p><p>В подкаталоге проекта <code>public</code> создайте файл <code>index.php</code> с следующим содержимым:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span>$s <span style=color:#f92672>=</span> $_SERVER;
</span></span><span style=display:flex><span><span style=color:#a6e22e>phpinfo</span>();
</span></span></code></pre></div><p>Вверху справа на панели запуска выберите созданную конфигурацию и нажмите зеленый треугольник.
<img src=Run.png alt></p><p>Это действие должно запустить сервер, который откроет в браузере файл index.php, в результате чего в браузере должен быть отображен результат работы <code>phpinfo()</code>.
<img src=Phpinfo-result.png alt>
<em>Результат работы index.php через браузер</em></p><h3 id=отладка-web-приложения>Отладка WEB-приложения
<a class=anchor href=#%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0-web-%d0%bf%d1%80%d0%b8%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f>#</a></h3><p>Устанавливаем точку останова на строку <code>phpinfo();</code>
<img src=Breakpoint.png alt></p><p>И вместо зеленого треугольника нажмем кнопку с зеленым жуком — это запустит сервер в режиме отладки.
<img src=Debug.png alt></p><p>При первом запуске отладки в браузере вам возможно понадобится специальное расширение JetBrains IDE Support, которое обычно предлагается к установке автоматически. Установите его.</p><p>При запуске отладки, откроется браузер с URL, к которому будет добавлен параметр с идентификатором сессии отладки, что-то вроде: <code>http://127.0.0.1/?XDEBUG_SESSION_START=11223</code>.</p><p>При этом вывод в браузер не будет выполнен, так как сработает точка останова. Вернитесь в окно PhpStorm. Активная точка останова выглядит вот так:
<img src=Active-Break-Poing.png alt>
<em>Активная точка останова</em></p><p>В данном случае птичкой обозначается та точка (а их может быть несколько), на которой произошел останов. Все переменные выше будут подсвечены их значениями для удобства.</p><p>Теперь переместимся ниже — на панель отладки.
<img src=Debug-Panel.png alt>
<em>Панель отладки PhpStorm</em></p><p>На ней видна вся отладочная информация. Справа — значения всех переменных в текущей области видимости (здесь также видна наша переменная <code>$s</code>), слева виден стек вызовов (сейчас он пуст, так как у нас примитивный пример). Имеются кнопки на левой панели, при помощи которых можно перезапустить отладку, прервать отладки продолжить выполнение с этого места, остановить отладку и другие. На верхней панели имеются кнопки, при помощи которых можно управлять отладкой: проходить пошагово каждое действие, начиная с точки останова, перепрыгивать функции, не заходя во внутрь и т.д.</p><p>Также существует другой способ отладки - при помощи «прослушивания». Нажмите кнопку с телефонной трубкой, чтобы активировать режим прослушивания.
<img src=Start-Listening-for-PHP-Debug-Connections-button.png alt></p><p>После того, как кнопка изменит вид (с красного запрещающего знака на зеленые полоски), Вы можете просто открыть веб-приложение в браузере и, если в коде проставлены точки останова, режим отладки запустится автоматически.
<img src=Start-Listening-for-PHP-Debug-Connections-button.png alt></p><h3 id=отладка-консольного-приложения-cli>Отладка консольного приложения (CLI)
<a class=anchor href=#%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0-%d0%ba%d0%be%d0%bd%d1%81%d0%be%d0%bb%d1%8c%d0%bd%d0%be%d0%b3%d0%be-%d0%bf%d1%80%d0%b8%d0%bb%d0%be%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f-cli>#</a></h3><p>Для отладки консольного приложения можно нажать кнопку с трубкой, чтобы включить режим прослушивания, как</p><p>Теперь можно запустить консольный скрипт следующей командой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker-compose exec php-fpm php ./public/index.php
</span></span></code></pre></div><p>Также можно создать псевдоним для вызова php-сценариев и поместить его в файл <code>alias.bash</code>. Например, вот такой:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>alias php<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;docker-compose exec php-fpm php&#39;</span>
</span></span></code></pre></div><p>И теперь тоже самое можно будет сделать выполнив следующую команду:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>php ./public/index.php
</span></span></code></pre></div><p>Если при этом отладка не сработала, убедитесь, чтобы имя сервера, которое создавали выше, совпадало с именем сервера в файле <strong>docker-compose.yml</strong> в переменной окружения <code>PHP_IDE_CONFIG</code>.</p><p>После окончания отладки не забудьте отключить режим прослушивания.</p><h3 id=отладка-тестов-phpunit>Отладка тестов (PhpUnit)
<a class=anchor href=#%d0%be%d1%82%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0-%d1%82%d0%b5%d1%81%d1%82%d0%be%d0%b2-phpunit>#</a></h3><p>С отладкой тестов дела обстоят точно так же, как и с консольным приложением. Включайте прослушивание (кнопку с трубкой) и запускайте тесты следующим псевдонимом (прокси-командой):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>phpunit
</span></span></code></pre></div><p>Но используя PhpStorm намного удобней и практичней использовать встроенные средства запуска тестов, которые предоставляют удобную навигацию по тестам, а также множество других полезных функций. Для того чтобы запустить тестирование средствами PhpStorm, необходимо настроить тестовый фреймворк.</p><p>Откройте настройки: <code>Languages & Frameworks » PHP » Test Frameworks</code>. И добавьте новый фреймворк (нажмите кнопку с плюсиком) - <strong>PHPUnit by Remote Interpreter</strong>. В открывшимся окне выберите наш интерпретатор и нажмите ОК.
<img src=phpunit72-remote-interpreter.png alt>
<em>Настройка интерпретатора для PHPUnit</em></p><p>Затем необходимо указать путь к <code>phpunit.xml</code>, убедиться, что путь к <strong>Composer autoloader</strong> автоматически добавился (добавить вручную, если нет) и нажать ОК.
<img src=Test-framework-phpunit-settings.png alt>
<em>Настройка PHPUnit</em></p><p>Тестовый фреймворк настроен. Теперь необходимо добавить <strong>конфигурацию запуска</strong> тестов, подобно той, которую мы добавляли чуть выше для запуска веб-приложения.</p><p>Для этого в главном меню <strong>Run</strong> перейдите в <strong>Edit configurations&mldr;</strong></p><p>Нажмите плюсик и добавьте <strong>PhpUnit</strong>. Укажите удобное Вам имя, например <em>Tests</em> и установите переключатель запуска в <strong>Defined in the configuration file</strong>. Теперь Вы можете настраивать тесты через конфигурационный файл <code>phpunit.xml</code>.
<img src=Run-Test-Configuration.png alt>
<em>Конфигурация запуска тестов PHPUnit</em></p><p>Теперь точно так же кнопкой с зеленым треугольником на панели запуска Вы можете запускать тесты в обычном режиме, кнопкой с жуком — запускать тесты в режиме отладки и кнопки с щитом запускать тесты в режиме расчета покрытия тестами (для расчета покрытия Вы должны настроить блок <code>whitelist</code> в конфигурационном файле <code>phpunit.xml</code>).
<img src=Test-run-panel.png alt></p><p>При этом активировать режим прослушивания (кнопка с трубкой) <strong>уже не нужно</strong>.</p><h2 id=резюме>Резюме
<a class=anchor href=#%d1%80%d0%b5%d0%b7%d1%8e%d0%bc%d0%b5>#</a></h2><p>В данной статье был описан простой способ настройки и использования отладчика Xdebug в PhpStorm, если используется удаленный интерпретатор в виде Docker-контейнера.</p><p>Все файлы можно скачать на GitHub: <a href=https://github.com/denisbondar/docker_php-fpm_xdebug>https://github.com/denisbondar/docker_php-fpm_xdebug</a></p><p>После того, как Вы склонируете себе репозиторий, не забудьте выполнить <code>composer install</code> для установки зависимостей и создания автозагрузчика. Для этого можно воспользоваться уже входящим в набор псевдонимов псевдонимом <code>composer</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>composer install
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-denisbondar-com.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#исходные-данные>Исходные данные</a></li><li><a href=#пример-конфигурации>Пример конфигурации</a><ul><li><a href=#docker-composeyml>docker-compose.yml</a></li><li><a href=#dockerphp-fpmdockerfile>docker/php-fpm/Dockerfile</a></li><li><a href=#dockerphp-fpmphpini>docker/php-fpm/php.ini</a></li><li><a href=#dockernginxdockerfile>docker/nginx/Dockerfile</a></li><li><a href=#dockernginxdefaultconf>docker/nginx/default.conf</a></li></ul></li><li><a href=#настройка-phpstorm>Настройка PhpStorm</a><ul><li><a href=#добавить-docker-сервер>Добавить Docker сервер</a></li><li><a href=#добавить-внешний-интерпретатор>Добавить внешний интерпретатор</a></li><li><a href=#проверить-конфигурацию-xdebug>Проверить конфигурацию Xdebug</a></li><li><a href=#добавить-php-сервер>Добавить PHP сервер</a></li><li><a href=#добавить-конфигурацию-для-запуска>Добавить конфигурацию для запуска</a></li></ul></li><li><a href=#упрощенный-способ-взаимодействия-с-контейнерами>Упрощенный способ взаимодействия с контейнерами</a></li><li><a href=#запуск-отладки>Запуск отладки</a><ul><li><a href=#отладка-web-приложения>Отладка WEB-приложения</a></li><li><a href=#отладка-консольного-приложения-cli>Отладка консольного приложения (CLI)</a></li><li><a href=#отладка-тестов-phpunit>Отладка тестов (PhpUnit)</a></li></ul></li><li><a href=#резюме>Резюме</a></li></ul></nav></div></aside></main></body></html>