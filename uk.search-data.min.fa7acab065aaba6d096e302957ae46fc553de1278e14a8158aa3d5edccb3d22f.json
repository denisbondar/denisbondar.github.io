[{"id":0,"href":"/post/winbox-macos-retina/","title":"Launching Winbox on macOS","section":"Posts","content":" Launching Winbox on macOS with Retina # Installing Wine # Download latest version of Winehq macOS Builds. You need only wine-devel-x.x-osx64.tar.xz version! Unzip the downloaded file to Applications. Run Wine Devel. After initialization, the console will be opened. The commands described below should be entered in this console. Execute the regedit command The registry editor will open. In it you need to go to the branch: HKEY_CURRENT_USER\\Software\\Wine Create a key in this branch named Mac Driver. Inside the created Mac Driver folder, create a string value named RetinaMode with a value of y. Close regedit window Execute the wineboot command. Execute the winecfg command. Navigate to Graphics tab and select a screen resolution scaling of 220 dpi. Click OK. Execute the wineboot command. Close console. Dowload Winbox # Go to the download page of mikrotik.com and download the 64-bit version of Winbox. Or use this direct download link: https://mt.lv/winbox64\nLaunching Winbox # Right click on the winbox64.exe file and select \u0026ldquo;open file with\u0026rdquo; — Wine Devel.\nLinks # https://help.mikrotik.com/docs/display/ROS/WinBox https://gist.github.com/mcxiaoke/bd0c779a01f21baad787f49e7b330faa "},{"id":1,"href":"/post/openvpn-server/","title":"OpenVPN Server","section":"Posts","content":" Настройка собственного OpenVPN сервера # Регистрация собственного виртуального сервера # Существует множество хостинговых компаний, предоставляющих в аренду виртуальные серверы за относительно небольшую плату, порядка $5 в месяц. Даже самых простых и дешевых виртуальных серверов обычно достаточно для использования в качестве VPN-сервера.\nОдна из таких компаний — «Digital Ocean». Виртуальные серверы в терминологии этой компании называются каплями (Droplets) и могут быть различной производительности. Капли можно создавать как на базе образов популярных операционных систем, так и на базе множества других образов, как доступных прямо в панели управления Digital Ocean так и собственных, которые можно загрузить самостоятельно. Данная инструкция предполагает, что используется чистая операционная система Linux дистрибутива Debian или его производных (например, Ubuntu). Для других дистрибутивов придется использовать другие команды в некоторых местах данной инструкции, так что лучше всего использовать рекомендуемый Debian.\nВместо этого Вы можете развернуть Каплю на основе готового образа OpenVPN, который существует в панели Digital Ocean, но этот способ мной не проверялся и я ничего не могу сказать об удобстве его использования.\nКроме того, Вы можете получить кредит на $100 на два месяца, который Вы можете тратить на любые услуги Digital Ocean, чтобы попробовать всё, что вам хочется. Для этого достаточно зарегистрировать учетную запись в Digital Ocean по специальной реферальной ссылке.\nВ любом случае, при регистрации в Digital Ocean Вы должны будете подключить банковскую карту (или PayPal) для списаний в будущем, если продолжите пользоваться Digital Ocean. При регистрации Digital Ocean списывает с карты сумму приблизительно $5 для верификации карты и через время возвращает обратно.\nСоздание капли # После регистрации создайте каплю (droplet). Для этого находясь в панели по адресу https://cloud.digitalocean.com/ нажмите вверху зеленую кнопку Create и выберите там Droplets. Затем выберите образ (Image): Ubuntu или Debian. Затем выберите план: Basic. CPU-options: Regular Intel with SSD. Самый минимальный дроплет за $5. Листайте ниже. На панели выбора «Choose a datacenter region» выберите регион расположения вашего виртуального сервера: подойдет любой европейский регион. Ниже на панели Аутентификации выберите аутентификацию по RSA-ключу или паролю, как вам удобно. Среди дополнительных опций не нужно выбирать ничего (можно, разве что, выбрать Монторинг, но он Вам все равно не пригодится). По желанию можете указать имя хоста в поле «Choose a hostname».\nНа этом всё. Нажмите большую зеленую кнопку «Create Droplet».\nЧерез несколько минут капля будет создана и появится в панели Droplets, где Вы сможете скопировать ее IP-адрес. Теперь Вы сможете подключиться к ней используя имя пользователя root и пароль или RSA-ключ, смотря какой способ аутентификации выбрали.\nЕсли на Вашем компьютере установлен Windows, то используйте приложение PuTTY для подключения по протоколу SSH к серверу. Если установлен Linux или MacOS, то просто введите команду:\nssh root@droplet_ip-addr Вместо droplet_ip-addr укажите IP-адрес вашей капли.\nУстановка # Вам необходимо установить OpenVPN, EasyRSA и EasyTLS (если не планируется использовать MikroTik в качестве клиентов).\nOpenVPN # sudo apt update \u0026amp;\u0026amp; sudo apt full-upgrade -y sudo apt install openvpn -y EasyRSA-3 # Ссылка на репозиторий.\ncd ~ wget -O easyrsa.tgz https://github.com/OpenVPN/easy-rsa/releases/download/v3.1.0/EasyRSA-3.1.0.tgz tar xf easyrsa.tgz rm easyrsa.tgz mv EasyRSA-3.1.0 easyrsa cd easyrsa Важно! Каталог easyrsa является текущим каталогом на всей протяженности данной инструкции. EasyTLS # Обратите внимание, что RouterOS (оборудование MikroTik) не поддерживает TLS-аутентификацию и, если планируется использовать MikroTik в качестве клиента, устанавливать EasyTLS не нужно. Также ненужно включать в конфигурацию параметры, связанные с TLS и TLS-ключ.\nСсылка на репозиторий.\nwget -O easytls https://raw.githubusercontent.com/TinCanTech/easy-tls/master/easytls chmod a+x easytls Инфраструктура открытых ключей (PKI) # Что такое EasyRSA # EasyRSA — это инструмент для управления инфраструктурой открытых ключей (X.509 PKI), которая основана на понятии доверия к конкретному органу для аутентификации удаленного клиента.\nОсновные понятия # PKI — Public Key Infrastructure (инфраструктурой открытых ключей). Описывает коллекцию файлов и ассоциации между ЦС, парами ключей, запросами и сертификатами. CA — Certificate Authority (центр сертификации, ЦС). Это «главный сертификат» в корне PKI. Является сердцем PKI и наиболее чувствительным к безопасности. Закрытый ключ ЦС используется для подписания всех выпущенных сертификатов, поэтому его безопасность критически важна для обеспечения безопасности всей PKI. Рекомендуется хранить CA на максимально безопасной системе, а не на той, где генерируются и используются сертификаты конечных объектов. (Но для простого VPN сервера, используемого для удаленного доступа в интернет, это правило можно мягко игнорировать). cert — Certificate (сертификат) — это запрос, подписанный центром сертификации. Сертификат содержит открытый ключ, некоторые детали, описывающие сам сертификат, и цифровую подпись ЦС. request — Certificate Request (запрос сертификата), иногда просто «req» (просто «запрос»). Запрос на сертификат, который после создания отправляется в центр сертификации для подписания. Запрос содержит требуемую информацию о сертификате вместе с цифровой подписью закрытого ключа. Запрос не чувствителен к безопасности и может быть передан любыми открытыми каналами. Чтобы удостовериться в аутентичности запроса, можно, например, использовать проверку его контрольной суммы. keypair — (пара ключей) — это асимметричная криптографическая пара ключей. Эти ключи делятся на две части: открытый и закрытый ключи. Открытый ключ содержится в запросе и сертификате. Обратите внимание!\nТак как эта статья посвещена настройке простого VPN-сервера для удаленного доступа в Интернет и не предполагает никаких сложных настроек безопасности, то и Центр Сертификации и сертификаты сервера и клиента будут созданы на одном и том же хосте — на том, где установлен OpenVPN сервер, без использования запросов сертификатов (поскольку сертификаты будут генерироваться и подписываться сразу же в PKI). Абсолютно то же самое можно сделать и на своем домашнем компьютере.\nЕсли же Вам нужен корпоративный VPN сервер с управлением доступом к нему на уровне сертификатов с достаточно высоким уровнем безопасности, обратитесь, пожалуйста, к соответствующей документации и статьям в интернете. В таком случае крейне рекомендую начать с более углубленного изучения основ, чтобы четко понимать, как это работает, что Вы делаете и для чего.\nИнициализация PKI # Предполагается, что текущий каталог easyrsa, в который был осуществлен переход в разделе установки EasyRSA-3. Выполните:\n./easyrsa init-pki В результате будет создан подкаталог pki, содержащий необходимые файлы.\nПредварительная конфигурация # Если есть необходимость изменения базовых переменных (для простого доступа в интернет через VPN в этом нет необходимости), отредактируйте файл vars в только что созданном каталоге pki:\nnano pki/vars Не забудьте удалить комментарии строк с переменными, значения которых необходимо изменить.\nСкорее всего будет интересен следующий блок переменных:\n#set_var EASYRSA_REQ_COUNTRY \u0026#34;US\u0026#34; #set_var EASYRSA_REQ_PROVINCE \u0026#34;California\u0026#34; #set_var EASYRSA_REQ_CITY \u0026#34;San Francisco\u0026#34; #set_var EASYRSA_REQ_ORG \u0026#34;Copyleft Certificate Co\u0026#34; #set_var EASYRSA_REQ_EMAIL \u0026#34;me@example.net\u0026#34; #set_var EASYRSA_REQ_OU \u0026#34;My Organizational Unit\u0026#34; Также может быть необходимо изменить количество дней действия сертификата ЦС и конечных сертификатов:\n#set_var EASYRSA_CA_EXPIRE 3650 #set_var EASYRSA_CERT_EXPIRE 825 Создание главного сертификата — CA # Для создания главного сертификата выполните:\n./easyrsa build-ca nopass Здесь для создания CA указан параметр nopass, означающий, что закрытый ключ будет создан без пароля. Это очень небезопасный способ создания ЦС, однако, учитывая поставленную цель, более удобный, т.к. не придется далее вводить каждый раз пароль закрытого ключа. Если считаете это неприемлемым в вашем случае, не используйте параметр nopass.\nПри создании сертификата будет предложено указать Common Name, но в данной конфигурации можно просто оставить значение по умолчанию — CA.\nПосле этого действия будет создан файл сертификата ЦС pki/ca.crt и файл закрытого ключа pki/private/ca.key (он является секретным).\nСоздание сертификата сервера # Создадим сертификат сервера с именем server. Имя может быть любым, но в данном случае удобней, если оно будет именно таким.\n./easyrsa build-server-full server nopass Будет создан сертификат сервера pki/issued/server.crt и приватный ключ pki/private/server.key (он является секретным).\nСоздание сертификата клиента # Для данной задачи создадим один единственный сертификат клиента с именем client, который будем испльзовать на всех своих устройствах и даже на не своих устройствах тоже. Для решения поставленной задачи этого более чем достаточно.\nЕсли же есть необходимость в создании разных сертификатов, то указывайте для каждого из них понятное имя.\n./easyrsa build-client-full client nopass Будет создан сертификат сервера pki/issued/client.crt и приватный ключ pki/private/client.key (он является секретным).\nИнициализация и создание TLS-ключа # Обратите внимание, что RouterOS (оборудование MikroTik) не поддерживает TLS-аутентификацию и, если планируется использовать MikroTik в качестве клиента, создавать TLS-ключ не нужно.\n./easytls init-tls ./easytls build-tls-crypt Будет создан файл ключа pki/easytls/tls-crypt.key.\nСервер # Конфигурация OpenVPN сервера # Содержимое файлов сертификатов и ключей можно вставить прямо в конфигурационный файл сервера. Для этого нужно сначала создать заголовок конфигурационного файла, а затем вставить в него все необходимые ключи.\nСоздайте файл /etc/openvpn/server.conf с конфигурацией сервера:\nsudo tee /etc/openvpn/server.conf \u0026lt;\u0026lt;EOT port 1194 proto tcp local :: dev-type tun dev tun1 user nobody group nogroup topology subnet persist-key persist-tun server 10.100.0.0 255.255.255.0 remote-cert-tls client tls-version-min 1.2 tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384 ; Если TLS не используется, то заменить шифр AES-256-GCM на AES-256-CBC ncp-ciphers AES-256-GCM cipher AES-256-GCM ; Если среди клиентов есть RouterOS, то раскомментировать следующую строку ;auth sha1 dh none reneg-sec 36000 max-clients 128 keepalive 10 120 script-security 2 explicit-exit-notify 0 tcp-nodelay push \u0026#34;redirect-gateway def1 block-local\u0026#34; push \u0026#34;block-outside-dns\u0026#34; push \u0026#34;dhcp-option DNS 8.8.8.8\u0026#34; push \u0026#34;dhcp-option DNS 1.1.1.1\u0026#34; log /dev/null ;log /var/log/openvpn/openvpn-debug.log ;log-append /var/log/openvpn/openvpn-debug.log status /var/log/openvpn/openvpn-status.log EOT И теперь выполняйте следующие строки, чтобы добавить в этот файл необходимые сертификаты и ключи:\necho \u0026#34;\u0026lt;ca\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf cat pki/ca.crt | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;/ca\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;cert\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf cat pki/issued/server.crt | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;/cert\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;key\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf cat pki/private/server.key | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;/key\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf # Блок tls-crypt добавлять только если все клиенты поддерживают TLS echo \u0026#34;\u0026lt;tls-crypt\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf cat pki/easytls/tls-crypt.key | sudo tee -a /etc/openvpn/server.conf echo \u0026#34;\u0026lt;/tls-crypt\u0026gt;\u0026#34; | sudo tee -a /etc/openvpn/server.conf Настройка сети сервера # IP Forwarding уровня ядра # Необходимо разрешить IP-пакетам ходить между интерфейсами сервера. Для этого выполните:\nsudo tee -a /etc/sysctl.conf \u0026lt;\u0026lt;EOT net.ipv4.ip_forward=1 EOT sudo sysctl -p Фаервол # IP-пакетам, отправляемым из VPN-сети через шлюз, необходимо выполнять процедуру трансляции адресов. Это связано с тем, что IP-адреса VPN клиентов «серые» и не могут быть маршрутированы из интернет напряму. Точно так же, как это происходит в обычном домашнем маршрутизаторе. За это отвечает модуль фаервола — NAT.\nUFW # Если до этого Вы не имели дел с фаерволом на данном сервере, то, скорее всего, он отключен. Чтобы включить его и управлять им, удобней всего использовать инструмент UFW.\nsudo apt install -y ufw Далее нужно будет включить фаервол, а перед тем, как это сделать, нужно сначала добавить правило, разрешающее подключение к порту 22 (SSH) и уже после этого активировать фаервол. Обратите внимание! Если вы изменяли порт для SSH, то вместо указания имени application нужно будет указать порт и протокол. Оба варианта представлены ниже:\n# Если используется порт SSH по умолчанию sudo ufw allow OpenSSH # Если используется какой-то другой порт для SSH, например 2255 sudo ufw allow 2255/tcp Также добавьте правило, разрешающее подключение к OpenVPN серверу:\nsudo ufw allow 1194/tcp Теперь нужно в разрешить фаерволу прохождение пакетов между интерфейсами (форвардинг на уровне фаервола). Для этого выполните:\nsudo sed -i \u0026#39;s@DEFAULT_FORWARD_POLICY=\u0026#34;DROP\u0026#34;@DEFAULT_FORWARD_POLICY=\u0026#34;ACCEPT\u0026#34;@\u0026#39; /etc/default/ufw Активировать фаервол:\nsudo ufw enable Ответить y на просьбу подтвердить включение и убедиться, что после включения связь с сервером не потерялась. Также убедиться, что подключение по необходимым портам разрешено:\nsudo ufw status NAT # Теперь нужно настроить NAT. Сперва нужно узнать имя интерфейса, через который сервер подключен к интернет. Это можно сделать посмотрев на маршрут по умолчанию.\nip route | grep default В выводе будет нечто подобное:\ndefault via 1.2.3.4 dev eth0 onlink Значит интересующий нас интерфейс называется eth0 — позже он пригодится для правила NAT фаервола.\nРедактируем файл /etc/ufw/before.rules.\nsudo nano /etc/ufw/before.rules Сразу после шапки файла (заголовка с комментариями) перед блоком с правилами *filter добавляем блок с настройками NAT, предварительно убедившись в корректности имени интерфейса -o eth0:\n# START OPENVPN RULES # NAT table rules *nat :POSTROUTING ACCEPT [0:0] # Allow traffic from OpenVPN client to eth0 (change to the interface you discovered!) -A POSTROUTING -s 10.100.0.0/24 -o eth0 -j MASQUERADE COMMIT # END OPENVPN RULES Обратите внимание, если Вы изменяли адрес подсети в конфигурации сервера выше, то не забудьте здесь также указать эту подсеть и корректную маску.\nПереактивировать фаервол, чтобы сработали правила NAT и политика форвардинга пакетов, которые были добавлены в файл:\nsudo ufw disable sudo ufw enable Запуск OpenVPN сервера # sudo systemctl start openvpn@server Проверьте состояние сервера:\nsudo systemctl status openvpn@server Проверить интерфейс, на котором сервер держит подключенных клиентов:\nip addr show tun1 Если все в порядке и не требует исправлений, добавить службу openvpn@server в автозагрузку:\nsudo systemctl enable openvpn@server Клиент # Ниже показано формирования конфигурации для VPN клиента. Так как нет необходимости в разделении доступа разных клиентов, а VPN используется исключительно как удаленный доступ в интернет, то конфигурация клиента будет тоже одна единственная как и один единственный созданный клиентский сертификат.\nСоздайте файл в своей домашней директории с конфигурацией клиента. В параметре remote вместо 1.2.3.4 укажите IP адрес вашего сервера (к которому будет подключаться клиент) и порт, если вы его изменили для сервера:\ntee ~/client.ovpn \u0026lt;\u0026lt;EOT dev tun client remote 1.2.3.4 1194 tcp nobind verb 3 server-poll-timeout 10 ; Если TLS не используется, то заменить шифр AES-256-GCM на AES-256-CBC ncp-ciphers AES-256-GCM cipher AES-256-GCM ; Если используется RouterOS, то раскомментировать следующую строку ;auth sha1 reneg-sec 0 remote-cert-tls server tls-version-min 1.2 tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384 ; Для LINUX клиента раскомментировать три следующие строки ;script-security 2 ;up /etc/openvpn/update-resolv-conf ;down /etc/openvpn/update-resolv-conf EOT Далее, как это было при формировании конфигурации сервера, добавляем в файл конфигурации клиента сертификаты и ключи. Обратите внимание, что сертификат и ключ используется клиентский, а не серверный:\necho \u0026#34;\u0026lt;ca\u0026gt;\u0026#34; | tee -a ~/client.ovpn cat pki/ca.crt | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;/ca\u0026gt;\u0026#34; | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;cert\u0026gt;\u0026#34; | tee -a ~/client.ovpn cat pki/issued/client.crt | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;/cert\u0026gt;\u0026#34; | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;key\u0026gt;\u0026#34; | tee -a ~/client.ovpn cat pki/private/client.key | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;/key\u0026gt;\u0026#34; | tee -a ~/client.ovpn # Если TLS-ключ не был создан - следующие строки не выполнять echo \u0026#34;\u0026lt;tls-crypt\u0026gt;\u0026#34; | tee -a ~/client.ovpn cat pki/easytls/tls-crypt.key | tee -a ~/client.ovpn echo \u0026#34;\u0026lt;/tls-crypt\u0026gt;\u0026#34; | tee -a ~/client.ovpn Настройка клиента # Скопируйте файл client.ovpn на ваш компьютер и/или смартфон, установите OpenVPN клиент и просто откройте в нем файл client.ovpn.\nLinux # Скопируйте файл client.ovpn в каталог /etc/openvpn. Затем раскомментируйте в нем строки:\nscript-security 2 up /etc/openvpn/update-resolv-conf down /etc/openvpn/update-resolv-conf И запустите службу openvpn:\nsudo systemctl start openvpn@client RouterOS и MikroTik # Операционная система RouterOS в оборудовании MikroTik не поддерживает TLS аутентификацию, поэтому вместо шифра (cipher) AES-256-GCM нужно использовать AES-256-CBC. Разница между GCM и CBC, помимо прочего, заключается во встроенном алгоритме аутентификации. Также следует явно указать аутентификацию sha1 в конфигурации сервера и в конфигурации остальных клиентов.\nТакже в конфигурации сервера необходимо закомментировать или удалить целиком блок с TLS-ключем, начинающийся с \u0026lt;tls-crypt\u0026gt; и заканчивающийся \u0026lt;/tls-crypt\u0026gt;, либо не добавлять его туда изначально (если вы не создавали TLS-ключи, то и добавлять будет нечего).\nСоздание подключения на MikroTik # Загрузите файл client.ovpn в маршрутизатор В меню Winbox перейдите в System » Certificates и импортируйте файл client.ovpn задав ему понятное имя сертификата, например «digitalocean-vpn». В результате будет импортирован СЦ (ca.crt) с именем digitalocean-vpn и клиентский сертификат с приватным ключем с именем digitalocean-vpn_1, который лучше переименовать, например, в digitalocean-vpn_client. В меню PPP создайте OVPN Client, где нужно будет указать: IP-адрес сервера, порт (по умолчанию 1194), Mode: ip, User: none, Certificate: digitalocean-vpn_client, Cipher: aes 256 "},{"id":2,"href":"/post/alpine-php-nginx-logrotate-docker-image/","title":"Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate","section":"Posts","content":" Докеризация PHP-приложения в единый Docker-образ Alpine+PHP+NGINX+logrotate # Идея # У меня есть несколько ультралегковесных PHP-скриптов, предоставляющих простой HTTP-API для тех или иных целей. Например, один из таких скриптов выполняет функции управления сетью (реализует протоколы SNMP, Telnet и т.д.) с доступом по HTTP-API. Но чтобы клиент мог эксплуатировать такой простой скрипт, ему необходимо установить и настроить WEB-сервер, РНР со всеми необходимыми расширениями, системные зависимости, такие как iproute2 и прочие и для многих клиентов это оказалось нетривиальной задачей. Так родилась идея поместить в один Docker-образ и скрипт и всё окружение, вместе со всеми необходимыми настройками. По идее, пользователь должен выполнить простую команду docker run ... чтобы всё это магическим образом сразу же заработало без какой-либо необходимости что-то устанавливать и настраивать самостоятельно.\nЦель # Нам нужен крайне легковесный Docker-образ, включающий в себя сам PHP-скрипт, php-fpm, nginx и остальное окружение, необходимое для работы. Доступ по HTTP должен быть только к единственному файлу index.php. Службы внутри контейнера должны работать от имени непривилегированного пользователя nobody, чтобы сделать контейнер чуточку безопасней. Так как клиенты разбросаны по всему миру, нужно чтобы часовой пояс клиента был корректным внутри контейнера, в том числе и для PHP. Все сообщения системных процессов (nginx, php и т.д.) должны выводиться на стандартный вывод stdout и stderr, как это требуется для процессов, работающих в контейнерах. Но выводить туда же логи самого PHP-скрипта может быть не совсем целесообразно, хотя и вполне допустимо. Всё же для логов PHP-скрипта условимся использовать отдельный лог-файл, который к тому же должен автоматически ротироваться без участия пользователя. Вроде бы всё. Поехали.\nВсе необходимые файлы-примеры находятся в репозитории на GitHub.\nРеализация # Следующее описание будет для нового проекта, который только создается, без привязки к моему конкретному примеру. Итак, начнем с самого минимума.\nСтруктура файлов (контекст сборки) # . ├── app │ └── public │ └── index.php ├── Dockerfile └── rootfs ├── etc │ ├── crontabs │ │ └── nobody │ ├── logrotate.conf │ ├── nginx │ │ └── nginx.conf │ ├── php7 │ │ ├── conf.d │ │ │ └── custom.ini │ │ └── php-fpm.d │ │ └── www.conf │ └── supervisor │ └── conf.d │ └── supervisord.conf └── usr └── bin └── docker-entrypoint.sh Показная здесь структура файлов подразумевает, что ваш PHP-проект на локальном компьютере находится в подкаталоге app текущего каталога (например, /home/coolhacker/my-cool-project/app). Если это не так — не страшно. Нужно будет чуть больше манипуляций при создании образа, но не существенно. Далее будет понятно, что и где будет отличаться.\nВ данном примере файлы PHP находятся в подкаталоге app проекта, в котором, в свою очередь, находится подкаталог public, содержащий файл index.php — к нему будет указан путь в конфигурации nginx.\nВсё это дерево каталогов и файлов представляет собой контекст сборки Docker-образа.\nНачинать будем с создания файла Dockerfile в корне каталога. В нашем примере это /home/coolhacker/my-cool-project/Dockerfile.\nDockerfile # Исходный образ # Для сборки собственного образа лучше всего брать исходный образ Alpine. Я пробовал построить свой образ на основе образа php-fpm-alpine, но в итоге остановился на использовании базового образа Alpine в качестве исходного. Первой строкой Dockerfile прописываем инструкцию:\nFROM alpine:3.14 Это означает, что за исходный будет взят образ alpine версии 3.14.\nДалее нужно установить весь необходимый софт.\nУстановка служб и системных зависимостей # Здесь остановимся подробней.\nВо-первых, нужно точно понимать, что и зачем добавляется в образ. И, если можно избежать добавления лишних файлов — лучше так и поступить. К счастью, идея Alpine заключается как раз в том, что сама операционная система и дополнительные пакеты содержат минимум файлов, необходимый для их работы. Некоторые пакеты вообще могут состоять из одного единственного файла (как, например, php8). Поэтому важно понимать, что при установке php вы получите только PHP без расширений вообще. То есть только то, что фактически входит в ядро. Не больше.\nВо-вторых, все пакеты легко можно отыскать на сайте https://pkgs.alpinelinux.org/ либо по названию пакета, либо по файлу, который необходим.\nВ-третьих, расширения PHP лучше устанавливать из пакетов, но можно также воспользоваться и docker-php-ext-install, однако, в таком случае придется устанавливать все зависимости вручную из пакетов.\nЧтобы установить пакеты, в Alpine используется команда apk add после которой идут опции и список пакетов, разделенный пробелом. Пока что добавим в Dockerfile выполнение самой команды и укажем две опции --update чтобы обновить кэш репозитория и --no-cache чтобы не кэшировать индекс (он нам не понадобится внутри образа). Для выполнения команд используется инструкций RUN:\nFROM alpine:3.14 RUN apk add --no-cache --update \\ Обратный слэш в конце указывает на то, что команда не завершается и продолжается со следующей строки. Так принято составлять длинные команды, чтобы не писать их целиком в одной длинной нечитаемой строке. Простое удобство форматирования длинной строки.\nДалее будем добавлять строки с необходимыми пакетами.\nNginx # Установим пакет nginx. Просто добавим название пакета, чтобы получилось:\nRUN apk add --no-cache --update \\ nginx \\ PHP # В данном примере показана установка php7 (по факту будет установлена последняя версия 7.4) и некоторых базовых расширений. Добавляем их:\nRUN apk add --no-cache --update \\ nginx \\ php7 \\ php7-fpm \\ php7-ctype \\ php7-mbstring \\ php7-json \\ php7-opcache \\ Если вы хотите использовать php8 — не проблема. Только следует помнить, что пакет php8 включает один исполняемый файл с именем php8, а пакет php7 включает два исполняемых файла php и php7. Это может быть важно, если вы запускаете какие-то сценарии php из консоли.\nЕсли вам нужны другие расширения — находите их здесь и добавляйте в список.\nНеобходимые системные утилиты # Далее добавим следующие системные утилиты, которые понадобятся для работы контейнера:\ncurl — для использования в директиве HEALTHCHECK в Dockerfile для проверки состояния контейнера. Можно не использовать эту директиву, но тогда есть шанс, что зависший php-fpm или nginx остановит работу вашего сервиса, в то время как контейнер будет считаться выполняемым (running); tzdata — для обеспечения поддержки часовых поясов внутри контейнера; tini — не обязательная, но очень желательная утилита — инициализатор процессов init, специально разработанный для запуска в контейнере. Позволяет корректно управлять процессами внутри контейнера и убивать зомби-процессы, не позволяя исчерпать пространство PID. Вместо использования этой утилиты можно запускать контейнер с параметром --init, однако добавление этой утилиты ни коем образом не вредит контейнеру в любом случае; supervisor — так как идеология запуска процессов в линукс-контейнерах подразумевает запуск только одного процесса на контейнер, то в качестве этого одного процесса можно использовать супервизор, задача которого лежит в запуске остальных процессов; logrotate — инструмент для ротации логов, если таковые есть. Вовсе не обязательно использовать ротацию логов внутри контейнера и можно сделать это внешним logrotate из операционной системы хоста. Либо же вообще не писать логи в файлы, а писать их на стандартный вывод. В общем, если необходимо иметь самодостаточный контейнер, который сам еще и логи приложения ротирует, то добавляем; dcron — легковесный crontab. Необходим для периодического запуска процессов внутри контейнера. В данном примере он будет запускать logrotate для периодической ротации логов. Также может пригодиться для периодического запуска каки-то фоновых процессов вашего приложения. Если ни в чем из этого нет необходимости, можно не устанавливать; libcap — инструмент, который используется для запуска cron от имени непривилегированного пользователя. Так как все процессы в целях безопасности в контейнере будут запускаться от имени пользователя nobody, то и cron должен запускаться от имени этого пользователя, что по умолчанию невозможно. Данный инструмент позволяет решить эту задачу. Если не устанавливали dcron, то в этом инструменте тоже нет необходимости. Добавляем далее в инструкцию RUN эти инструменты:\nRUN apk add --no-cache --update \\ nginx \\ php7 \\ php7-fpm \\ php7-ctype \\ php7-mbstring \\ php7-json \\ php7-opcache \\ curl \\ tzdata \\ tini \\ supervisor \\ logrotate \\ dcron \\ libcap \\ Действия после установки # Сперва нужно разобраться с dcron. Нам нужно, чтобы он запускался от имени непривилегированного пользователя (что обычно невозможно). Для этого мы установили libcap. Назначим владельца файла crond нашего пользователя nobody и изменим setuid-бита на capabilities. Если dcron не устанавливали, то и строки эти добавлять не нужно. Если устанавливали, то добавляем:\n\u0026amp;\u0026amp; chown nobody:nobody /usr/sbin/crond \\ \u0026amp;\u0026amp; setcap cap_setgid=ep /usr/sbin/crond \\ Теперь создадим все необходимые каталоги. Как минимум каталог /app для PHP-файлов. В нашем примере также существует каталог /logs для размещения файлов логов в нем. Добавляем в Dockerfile:\n\u0026amp;\u0026amp; mkdir -p /app /logs \\ Последим действием будет очистка от ненужных файлов. Нужно удалить все временные файлы, все логи, кэши, чтобы образ занимал как можно меньше места. Также удалить все базовые кронтабы (конфиги для cron) и удалить каталог с подключаемыми конфигами ротатора логов logratate — они нам точно не нужны, т.к. мы всё настроим в одном файле. Это ведь контейнер. Добавляем далее:\n\u0026amp;\u0026amp; rm -rf /tmp/* \\ /var/{cache,log}/* \\ /etc/logrotate.d \\ /etc/crontabs/* \\ /etc/periodic/daily/logrotate Как видно, последняя строка не содержит обратного слеша в конце — это означает конец строки.\nЦеликом весь файл Dockerfile на данный момент выглядит следующим образом:\nFROM alpine:3.14 RUN apk add --no-cache --update \\ nginx \\ php7 \\ php7-fpm \\ php7-ctype \\ php7-mbstring \\ php7-json \\ php7-opcache \\ curl \\ tzdata \\ tini \\ supervisor \\ logrotate \\ dcron \\ libcap \\ \u0026amp;\u0026amp; chown nobody:nobody /usr/sbin/crond \\ \u0026amp;\u0026amp; setcap cap_setgid=ep /usr/sbin/crond \\ \u0026amp;\u0026amp; mkdir -p /app /logs \\ \u0026amp;\u0026amp; rm -rf /tmp/* \\ /var/{cache,log}/* \\ /etc/logrotate.d \\ /etc/crontabs/* \\ /etc/periodic/daily/logrotate Такая длинная строка, состоящая из множества разных команд создает один слой в образе Docker. Чем меньше слоев — тем лучше.\nПоехали дальше.\nКопирование корневой файловой системы # Теперь нам нужно подготовить различные файлы конфигураций, которые будут скопированы в образ с сохранением иерархии. Создадим каталог rootfs там же, где находится файл Dockerfile и всю структуру каталогов внутри (подкаталоги etc, usr и все подкаталоги). Если вам не нужен cron, то не создавайте каталог crontabs и файл крона nobody внутри него; если не нужна ротация логов, не создавайте файл logrotate.conf. Всё остальное повторяйте в точности как есть.\nДалее содержимое каталога rootfs нужно скопировать в корень Docker-образа. Добавляем в Dockerfile следующую инструкцию:\nCOPY rootfs / Далее подробней о каждом файле из rootfs:\netc/crontabs # Внутри crontabs находятся файлы расписаний cron. Имя файла соответствует имени пользователю, от которого будут запущены процессы внутри этого файла расписания. Так как пользователь, от имени которого будут работать все процессы внутри контейнера — nobody, то и файл должен иметь такое же имя. Внутри файла одна единственная строка, запускающая службу logrotate ежедневно в 6:30 утра:\n30 6 * * * /usr/sbin/logrotate -v /etc/logrotate.conf Если вам нужны какие-то еще задачи — добавляйте строки в этот файл, как обычно в crontab.\netc/nginx/nginx.conf # Внутри nginx находятся файлы конфигураций сервера Nginx. Мы изменим только главный файл nginx.conf, остальные оставим как есть. Прямо в главный файл впишем настройку server, так как внутри контейнера он все равно будет один — нет смысла загружать группу конфигураций, как это сделан по умолчанию.\nЛогирование в этом файле настраивается на стандартный вывод — /dev/stdout и /dev/stderr.\nВ nginx.conf внутри блока server настраивается единственный в контейнере сервер. Причем настраивается таким образом, что доступ разрешен только к файлу index.php (и к корню сервера, который считается тем же индексом). Вместо такой конфигурации можно использовать любую другую — как необходимо в вашем конкретном случае. Помимо этого настраивается location ~ ^/(fpm-status|fpm-ping), необходимый для контроля состояния пула php-fpm.\nПодключения принимаются на порту 8080, так как nginx будет работать не от суперпользователя и в этом случае желательно использовать порты с номерами выше 1023 во избежание проблем с правами доступа.\netc/php7/conf.d/custom.ini # В файле custom.ini настраивается вся необходимая конфигурация php. Вывод ошибок выполняется в /dev/stderr Обратите внимание на настройку часового пояса — он читается из переменной окружения ${TZ}. К ней мы еще вернемся позже.\netc/php7/php-fpm.d/www.conf # Файл www.conf содержит настройки пула fpm. В качестве назначения для сообщений об ошибках также указан /dev/stderr. Кроме того, используется файловый сокет (который указан в nginx.conf), включаются служебные эндпоинты для контроля состояния fpm пула. Настраивается менеджер процессов на усредненные значения (так как мы не знаем, какие ресурсы будут доступны контейнеру у клиента).\netc/supervisor/conf.d/supervisord.conf # Так как в контейнере можно запустить только один основной процесс, а нам нужно целых три (nginx, php, cron), воспользуемся супервизором — он будет тем самым основным процессом, который породит остальные нужные процессы.\nЗдесь стоит отметить важный нюанс: процессы, запускаемые в контейнере, должны работать в foreground, то есть не должны демонизироваться. Обычно у каждого демона есть такой режим работы. Так что, если вам нужно запустить еще какой-то процесс в контейнере, обязательно учитывайте это требование.\nФайл supervisord.conf помимо основной секции настроек содержит три одинаковые секции, отличающиеся только командой, которая будет выполнена. Для каждого из сервисов указывается стандартный вывод в качестве потока вывода журнала.\netc/logrotate.conf # Этот файл содержит минимальную базовую конфигурацию ротации лога, а также одну единственную настройку размещения логов с пустыми настройками (будут браться настройки по умолчанию). Если вам нужно задать какие-то иные параметры ротации — укажите их в базовых настройках. Этого будет достаточно. Если же вам нужно ротировать разные файлы журналов по-разному, то внутри фигурных скобок пропишите отличающиеся параметры — они перекроют параметры по умолчанию.\nПосле того, как файлы скопированы, необходимо изменить владельцев некоторых из них, а также каталогов, которые были созданы ранее. Добавляем в Dockerfile следующую команду:\nRUN chown -R nobody:nobody /app \\ \u0026amp;\u0026amp; chown -R nobody:nobody /logs \\ \u0026amp;\u0026amp; chown -R nobody:nobody /run \\ \u0026amp;\u0026amp; chown -R nobody:nobody /var/lib \\ \u0026amp;\u0026amp; chown -R nobody:nobody /var/log/nginx \\ \u0026amp;\u0026amp; chown -R nobody:nobody /etc/crontabs Переключаемся на непривилегированного пользователя # Далее нужно сменить пользователя на nobody, так как все последующие действия должны быть выполнены от его имени. Добавляем в Dockerfile следующую инструкцию:\nUSER nobody Делаем каталог /app внутри образа текущим рабочим каталогом. При запуске контейнера из этого образа этот каталог будет каталогом по умолчанию, относительно которого будет выполняться все в контейнере:\nWORKDIR /app Копирование файлов PHP-скрипта в Docker-образ # Так как все рабочие PHP-файлы находятся в подкаталоге app текущего каталога, то скопировать их в каталог /app образа можно за одно действие. Здесь важно то, что владелец файлов и подкаталогов должен быть nobody. Добавляем в Dockerfile следующую инструкцию:\nCOPY --chown=nobody:nobody app /app Если у вас PHP-файлы расположены не в подкаталоге (как в данном примере в подкаталге app), то в простейшем случае придется перечислить все подкаталоги и файлы в инструкции COPY. Последний аргумент — путь назначения.\nОбъявление внешних томов и портов # Если приложение ведет файл журнала в каталоге /logs, как это было задано в изначальной задаче, то было бы правильным разместить этот каталог за пределами контейнера в файловой системе хоста, даже если к нему не будет осуществляться доступ напрямую с хоста.\nНу и единственный порт, который принимает подключения — это порт 8080. Так как мы запускаем nginx не от имени суперпользователя, то не желательно либо даже невозможно использовать порты с номерами ниже 1024 (они доступны только пользователю root). Поэтому используем привычный порт 8080. В любом случае при запуске контейнера можно опубликовать этот порт на любой другой порт хоста, например, на порт 80.\nДобавляем в Dockerfile:\nVOLUME \u0026#34;/logs\u0026#34; EXPOSE 8080 Точка входа ENTRYPOINT # Инструкция ENTRYPOINT определяет точку входа в контейнер. Команду, вместе с аргументами, которая должна быть выполнена в контейнере при его старте. В качестве дополнительных аргументов для точки входа передаются команда и ее аргументы, указанные при старте контейнера.\nОбычно точкой входа является скрипт с именем наподобие entrypoint.sh, который инициализирует контейнер при старте. Мы будем в такой инициализации устанавливать переменную окружения ${TZ}, в которую запишем часовой пояс. Обычно, но не всегда, в самом конце скрипта entrypoint.sh присутствует команда exec которая запускает переданную в аргументах команду.\nНаш скрипт находится в rootfs по пути usr/bin/docker-entrypoint.sh и будет скопирован вместе с остальными файлами на сервер. Этот скрипт обязательно должен быть исполняемым (то есть иметь установленный флаг x).\nДля большинства случаев будет достаточно добавить в Dockerfile следующую команду:\nENTRYPOINT [\u0026#34;/usr/bin/docker-entrypoint.sh\u0026#34;] Это значит, что если запустить контейнер, указав, например, команду pwd, то фактически при старте контейнера будет выполнена команда /usr/bin/docker-entrypoint.sh pwd.\nТак как у нас установлен специальный инициализатор процессов для контейнеров — tini, воспользуемся им в точке входа. Вместо примера выше добавляем в Dockerfile следующую строку:\nENTRYPOINT [\u0026#34;/sbin/tini\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;/usr/bin/docker-entrypoint.sh\u0026#34;] Выполняемая по умолчанию команда # Теперь необходимо указать выполняемую по умолчанию команду. Это та основная команда, которая будет выполняться в контейнере по умолчанию, если при запуске не указать её явно в аргументах docker run.\nДля нашего контейнера таким основным процессом будет супервизор. Именно он должен запуститься как главный процесс и затем он породит все необходимые процессы (nginx, php-fpm, crond), которые будут работать в foreground без демонизации.\nЭту команду можно легко переопределить, передав другую команду в качестве главного аргумента команд docker run или docker exec.\nОднако стоит понимать, что в любом случае команда будет передана в аргументы скрипта, указанного как ENTRYPOINT.\nДобавим в Dockerfile команду по умолчанию:\nCMD [\u0026#34;/usr/bin/supervisord\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;/etc/supervisor/conf.d/supervisord.conf\u0026#34;] Теперь при старте контейнера будет фактически вызываться точка входа вместе с командой, что будет выглядеть следующим образом:\n/sbin/tini -- /usr/bin/docker-entrypoint.sh /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf На этом можно было бы и закончить, но так как наш контейнер будет выполнять несколько различных процессов, то есть вероятность того, что какой-то из них перестанет работать так, как от него ожидается, в то время как основной процесс (супервизор) будет продолжать работу. В таком случае контейнер будет отображаться как работающий (running), но фактически он будет нерабочий.\nПроверка состояния контейнера # Благодаря инструкции HEALTHCHECK можно запускать периодическую проверку жизнеспособности контейнера. В данном примере будем обращаться каждые 30 секунд (по умолчанию) к эндпоинту http://127.0.0.1:8080/fpm-ping. Если последние 3 проверки (по умолчанию) будут провалены, контейнер будет считаться нерабочим.\nДанная проверка позволяет проверить одновременно работу nginx и php-fpm, что довольно неплохо, но вместо этого можно пойти еще дальше и реализовать подобный проверочный эндпоинт у себя в PHP-скрипте, чтобы наверняка проверить работоспособность целиком всей службы, работающей в контейнере.\nДобавим в Dockerfile инструкцию:\nHEALTHCHECK --timeout=10s CMD curl --silent --fail http://127.0.0.1:8080/fpm-ping На этом создание Dockerfile можно считать завершенным.\nСборка и запуск # Здесь будут рассмотрен простой способ создания образа, его распространения и запуска. Справку по всем командам и параметрам можно получить из официальной документации.\nСборка # При выполнении сборки в файловое пространство демона containerd копируются все файлы из контекста. В нашем случае контекст — это все каталоги и файлы, расположенные там же, где и файл Dockerfile, но если этот файл расположен в другом месте — это можно указать отдельно. В общем случае этот файл располагается там же, где и остальные файлы и здесь рассматривается именно такой вариант.\nЕсли есть какие-либо файлы или каталоги, попадание которых в пространство сборки не имеет смысла, целесообразно добавить их имена в специальный файл .dockerignore, синтаксис которого целиком аналогичен синтаксису .gitignore. Обычно этот файл, как минимум, дублирует .gitignore, однако чаще содержит больше записей, ведь игнорируемых при сборке Docker-образа файлов может быть значительно больше, чем игнорируемых для репозитория.\nДля построения образа на основании созданного Dockerfile необходимо запустить команду:\ndocker build --pull --tag=my-app-bundle-image . Здесь:\n--pull — загружать свежие версии Docker-образов, от которых зависит сборка. --tag=my-app-bundle-image — финальному образу будет автоматически назначена данная метка. Если образ планируется разместить в Docker-хабе, метка должна состоять из имени пользователя (предприятия) Docker-хаба и через слеш имени образа. Также через двоеточие можно указывать версию. Если версию не указать, она автоматически устанавливается в latest. У одного и того же образа может быть сколько угодно меток. Чаще всего это используется для версионирования, когда новая версия получает новый номер, а также latest. . — точка в конце строки указывает на путь к контексту. В данном случае это «текущий каталог». Так как не указан параметр --file, то Dockerfile будет использоваться из контекста. После выполненя команды получаем готовый Docker-образ, который можно эксплуатировать.\nЗапуск # Для запуска контейнера из образа служит комнада docker run. В качестве аргументов этой команде в нашем случае необходимо обязательно передать каталог, который будет отображаться на каталог /logs внутри контейнера (для записи логов), а также опубликовать порт контейнера на порт хоста (по умолчанию в режиме моста).\nСперва необходимо создать каталог для логов. Создадим его прямо здесь, после чего добавим его в .gitignore и в .dockerignore:\nmkdir -p log chmod 777 log Помимо этого мы передадим некоторые дополнительные аргументы, значение которых будет описано далее.\nДля проверочного запуска контейнера из образа выполните команду:\ndocker run -it --name=my-app-container \\ -p 80:8080 \\ -v $(pwd)/log:/logs \\ -v /etc/localtime:/etc/localtime:ro \\ -v /etc/timezone:/etc/timezone:ro \\ my-app-bundle-image Где:\n-it — запуск в интерактивном режиме (подключение STDIN/STDOUT) и с созданием псевдо-TTY. --name=my-app-container — контейнер после запуска будет иметь имя my-app-container, чтобы можно было обращаться к нему по этому заведомо известному имени. Если не задать имя, то оно будет выбрано случайным образом. -p 80:8080 — публикация порта контейнера 8080 на 80й порт локального хоста. -v $(pwd)/log:/logs — подключение локального тома log к каталогу /logs внутри контейнера. -v /etc/localtime:/etc/localtime:ro и -v /etc/timezone:/etc/timezone:ro — транслировать внутрь контейнера файлы с часовым поясом и локальным временем. Это позволит получить часовой пояс внутри контейнера точно такой же, как и на хосте, а при старте контейнера скрипт точки входа дополнительно установит переменную окружения с часовым поясом, которую использует php. my-app-bundle-image — имя образа (метка), на базе которого будет запущен контейнер Запустится контейнер. В консоль начнут поступать сообщения о запуске процессов супервизором. Попробуйте открыть страницу в браузере http://127.0.0.1/ — вы увидите вывод phpinfo(). Также будет создан файл журнала, в который будет помещена одна строка. Проверьте это.\nЧтобы контейнер работал в фоне, автоматически запускался при старте системы и перезапускался при падении, аргументы запуска следует немного изменить. Остановите выполнение текущего контейнера комбинацией клавиш Ctrl+C и выполните следующую команду:\ndocker run -d --name=my-app-container \\ --restart=always -p 80:8080 \\ -v $(pwd)/log:/logs \\ -v /etc/localtime:/etc/localtime:ro \\ -v /etc/timezone:/etc/timezone:ro \\ my-app-bundle-image Здесь:\n-d — запускать контейнер в фоне (поэтому ключи -it больше не нужны); --restart=always — запускать контейнер при старте системы и всегда перезапускать при сбое (бесконечное число попыток). Вместо этого можно задать другие варианты. Контейнер будет запущен в фоне и вы получите командную строку оболочки. Попробуйте снова открыть страницу в браузере, понаблюдайте за логом при многократном обновлении страницы.\nТеперь, чтобы остановить контейнер, выполните команду:\ndocker stop my-app Контейнер при этом не удаляется. Чтобы его снова запустить. выполните команду:\ndocker start my-app Распространение образа # hub.docker.com # Самый простой способ распространения — загрузка в Docker-hub. Для этого нужно создать учетную запись на сайте https://hub.docker.com/ и присвоить метку образу в требуемом формате имя_пользователя/название_образа:версия. Версию можно не указывать — в этом случае будет автоматически использовано latest.\nЧтобы назначить еще одну метку образу, выплоните команду:\ndocker tag my-app-bundle-image coolhacker/my-app-bundle-image docker images | grep my-app-bundle Теперь в спике образов видны два образа с одинаковым хэшем. На самом деле это один и тот же образ, но с двумя разными метками.\nТоже самое, если необходимо версионировать образы.\nДля загрузки испльзуется команда:\ndocker push coolhacker/my-app-bundle-image Если нужно загрузить все метки, которые присвоены указанному образу, можно просто воспользоваться аргументом --all.\ntarball # Второй способ распространения — сохранение образа в tar. Это стандартный архив UNIX без сжатия. Чтобы сохранить образ в архив просто выполните команду:\ndocker save my-app-bundle-image -o my-app-bundle-image.tar Вместо сохранения в файл можно вывести содержимое на стандартный вывод и перенаправить поток в gzip для сжатия.\nЧтобы загрузить сохраненный таким способом образ на другой машине, скопируйте туда файл и выполните:\ndocker load -i my-app-bundle-image.tar Вместо этого можно воспользоваться стандартный вводом, чтобы прочитать tar или сжатый архив.\nОбновление образа на другой машине # Если вы распространяете образ с вашим приложением клиентам, но чтобы они имели возможность обновиться, нужно выполнить следующие действия:\ndocker stop my-app docker rm my-app dockrt pull coolhacker/my-app-bundle-image # если используется docker-hub docker load -i my-app-bundle-image.tar # если используется распространение tarball docker run -d --name=my-app-container \\ --restart=always -p 80:8080 \\ -v $(pwd)/log:/logs \\ -v /etc/localtime:/etc/localtime:ro \\ -v /etc/timezone:/etc/timezone:ro \\ my-app-bundle-image Принцип теперь уже точно должен быть понятен.\nОбслуживание # В процессе эксплуатации возможно понадобиться подключиться к работающему контейнеру, чтобы что-то проверить. Это можно сделать при помощи команды:\ndocker exec -it my-app-container sh Вызов этой команды приведет к тому, что в работающем контейнере через точку входа будет выполнена команда sh а также будет подключен стандартный ввод/вывод и создан псевдо-TTY. В результате вы получите shell-доступ в контейнер, который выполняется. Можно посмотреть список процессов либо что угодно еще. Для отключения — Ctrl+C.\nУничтожить контейнер можно при помощи команды:\ndocker stop my-app-container docker rm my-add-container Уничтожить метку образа можно при помощи команды:\ndocker rmi my-app-bundle-image Если у образа больше не осталось меток, то будет уничтожен и сам образ.\nСпасибо за внимание.\n"},{"id":3,"href":"/post/postfix-dkim-spf-tls-dmarc/","title":"Персональный почтовый сервер","section":"Posts","content":" Персональный почтовый сервер # Если у Вас онлайн магазин или блог или любой другой сайт, которому требуется рассылать почтовые сообщения клиентам и Вы хотите, чтобы почта отправлялась с вашего домена — Вам нужен собственный SMTP сервер, построенный с использованием правильно настроенных Postfix и DKIM. Вы можете воспользоваться уже готовыми многофункциональными SMTP серверами, которые предоставляют различные почтовые службы, например, «GMAIL» или «Yandex.Почта», но если Вам нужен именно ваш собственный сервер, то эта небольшая, но полноценная инструкция для Вас!\nКак всегда, инструкция состоит из простых коротких шагов с минимумом текста. По возможности, конечно же…\nБудет рассмотрена установка почтового агента (SMTP) Postfix, а также DKIM, TLS и всех необходимых записей на NS-серверах, чтобы добиться результата в 10 баллов на mail-tester.com.\nВсе примеры показаны на базе ОС Debian. Они также должны подойти без изменения для Ubuntu. Также за основу берется настройка почты для моего домена denisbondar.com.\nDNS # Здесь и далее под доменом будет пониматься полное имя домена (FQDN). Я буду использовать везде имя своего домена denisbondar.com. Обратите внимание на то, что мой блог имеет адрес blog.denisbondar.com.\nДля работы нашего почтового сервера необходимы три основные обязательные записи на NS-сервере, обслуживающем этот домен.\nВам необходимо открыть раздел управления серверами имен (NS) панели управления вашим хостингом. Она может называться как-то иначе, например, в DigitalOcean она называется Domains.\nA-запись # Для вашего домена должна быть обязательно настроена A-запись (соответствие IP-адреса доменному имени). Но если на этом же домене работает ваш сайт, то запись уже есть. В моем случае сайт имеет адрес blog.denisbondar.com, а в качестве почтового я буду использовать denisbondar.com, поэтому я должен создать A-запись для denisbondar.com. Если у вас несколько субдоменов, то для каждого из них должна быть такая запись.\nMX-запись # Эта запись указывает, какой mail exchanger используется в нашем домене. Так как мы используем наш собственный mail exchanger, то необходимо добавить следующую запись:\n@ IN MX 0 \u0026#34;denisbondar.com.\u0026#34; Если у вас несколько субдоменов, то для каждого из них должна быть такая запись.\nВ пользовательском интерфейсе DigitailOcean это выглядит следующим образом. MX-запись для домена в панели управления DigitalOcean\nPTR-запись # Также Вам необходимо настроить PTR-запись для Вашего IP-адреса сервера. Обычно это делается автоматически, если Вы пользуетесь услугами хостинговых компаний. Но в некоторых случаях, если Ваш сервер находится у Вас, а не в облаках, то эту настройку должен выполнить ваш интернет-провайдер, которому принадлежит IP-адрес вашего сервера. Также обратите внимание, есть ли у вас PTR для IPv6 — это пригодится далее.\nВ DigitalOcean ничего для этого делать не нужно — там PTR создается автоматически и соответствует указанному доменному имени вашего Droplet. У меня это выглядит вот так. PTR-запись для моего IP-адреса в панели DigitalOcean\nПодтвердить домен в Google # Google может и скорее всего будет отклонять почту с неподтвержденных доменов. Поэтому подтвердите домен перейдя по ссылке https://postmaster.google.com — это займет всего минуту.\nБольше информации здесь.\nPostfix # Установка и настройка SMTP агента Postfis.\nsudo apt update sudo apt install -y postfix mailutils Во время установки вам нужно будет выбрать Internet Site и далее указать ваш домен (в моем случае это denisbondar.com).\nПосле установки отредактируйте файл /etc/postfix/main.cf\nsudo nano /etc/postfix/main.cf Найдите строку inet_interfaces и замените ее значение по умолчанию all на loopback-only. Это необходимо для того чтобы почтовый сервер принимал подключения только на локальном интерфейсе. Нам ведь нужно чтобы только наш сайт/блог/магазин мог отправлять почту через наш сервер, а не весь интернет. Если в будущем понадобится отправлять почту с других ваших серверов через этот, нужно будет добавить интерфейсы здесь.\nНайдите строку mydestination и отредактируйте ее указав все домены, с которых сервер будет отправлять почту (через запятую):\nmydestination = $myhostname, denisbondar.com Здесь первым в списке идет переменная $myhostname, значение которой соответствует имени вашего хоста. В моем случае оно denisbondar.com и конкретно в моем случае нет смысла также добавлять denisbondar.com в этот список, но у Вас имя хоста и почтовый домен могут отличаться. Обратите на это внимание.\nЕсли ваш хостер не поддерживает PTR IPv6, то нужно оставить только протокол IPv4, иначе при попытке работы через IPv6 возникнут проблемы с PTR:\ninet_protocols = ipv4 Работа с файлом main.cf завершена.\nДалее настроим псевдонимы, если это необходимо. Было бы правильным это сделать. Системные сообщения на сервере обычно отправляются пользователю root. Мы же можем указать в качестве псевдонима для root настоящий адрес электронной почты, на который будут приходить эти письма.\necho \u0026#34;root: myreadlemail@gmail.com\u0026#34; | sudo tee -a /etc/aliases sudo newaliases Вместо myreadlemail@gmail.com укажите свой настоящий адрес электронной почты.\nТеперь перезагрузите postfix.\nsudo systemctl restart postfix На этом базовая настройка Postfix завершена и уже можно проверить его работу. Отправьте почту пользователю root или же на любой другой адрес электронной почты для проверки (укажите его вместо root):\necho \u0026#34;Test email body\u0026#34; | mail -s \u0026#34;Test email subject\u0026#34; root TLS-шифрование # Шифрование можно не применять, однако почтовые клиенты ваших получателей будут видеть красный предупреждающий замок, что письма не зашифрованы. Например, gmail отображает такие письма следующим образом:\nОтсутствие шифрования письма выглядит как красный замок\nПодробная информация. Домен не шифрует почту.\nИсправим это.\nСоздадим сертификат (это всё одна строка):\nsudo openssl req -new -nodes -x509 -days 3650 \\ -out /etc/postfix/smtpd.pem \\ -keyout /etc/postfix/smtpd.pem И снова отредактируем файл /etc/postfix/main.cf\nsudo nano /etc/postfix/main.cf Отыщите в файле блок настроек TLS и измените либо добавьте параметры в нем следующим образом:\nsmtp_use_tls = yes smtpd_use_tls = yes smtpd_tls_auth_only = yes smtp_tls_note_starttls_offer = yes smtpd_tls_key_file = /etc/postfix/smtpd.pem smtpd_tls_cert_file = /etc/postfix/smtpd.pem smtpd_tls_CAfile = /etc/postfix/smtpd.pem smtpd_tls_loglevel = 1 smtpd_tls_received_header = yes smtpd_tls_session_cache_timeout = 3600s tls_random_source = dev:/dev/urandom Теперь необходимо настроить Postfix на прием подключений на TLS порту (465/SMTPS). Отредактируйте файл /etc/postfix/master.cf\nsudo nano /etc/postfix/master.cf Необходимо дополнительно раскомментировать строки таким образом, чтобы команда выглядела вот так (каждый параметр в этом файле находится в отдельной строке, так что придется найти их в отдельности и расскомментировать и изменить при необходимости):\nsmtps inet n - y - - smtpd -o smtpd_tls_wrappermode=yes -o smtpd_sasl_auth_enable=yes Перезапустите Postfix и снова проверьте его работу.\nsudo systemctl restart postfix echo \u0026#34;Test email body with TLS\u0026#34; | mail -s \u0026#34;Test email subject with TLS\u0026#34; root Теперь в почтовом клиенте вы должны увидеть, что письмо зашифровано. Красного замка нет\nПодробная информация с TLS шифрованием\nSPF (Sender Policy Framework) # SPF позволяет настроить список различных серверов, которые могут отправлять почту с вашего домена.\nЭта настройка производится на NS-серверах, обслуживающих Ваш домен.\nВам необходимо добавить запись типа TXT для вашего домена, которая определяет, какие хосты могут отправлять почту используя ваш домен. Добавим сюда только IP-адреса нашего сервера, чтобы только наш сервер считался авторизованным. Для всех остальных будет применено правило «жесткий отказ» -all, чтобы гарантировать, что с нашего домена никакие другие серверы не смогут отправлять сообщения.\nВ моем случае я добавляю запись:\n@ IN TXT \u0026#34;v=spf1 a mx ip4:207.154.240.75 -all\u0026#34; Если у вас несколько субдоменов (сайтов), то нужно добавить такую запись для каждого из них.\nВ панели DigitalOcean это выглядит следующим образом. Добавление TXT-записи SPF в консоли DigitalOcean\nDKIM (DomainKeysIdentifiedMail) # DKIM — цифровая подпись, подтверждающая подлинность отправителя.\nНеобходимо установить пакет OpenDKIM и произвести его настройку.\nsudo apt install -y opendkim opendkim-tools Стандартный файл конфигурации /etc/opendkim.conf содержит слишком много комментариев и лишних опций, поэтому лучше сразу переименовать его в backup на всякий случай и начать работу с новым конфигом.\nsudo mv /etc/opendkim.conf /etc/opendkim.conf.backup sudo nano /etc/opendkim.conf Приведём файл к виду:\nAutoRestart Yes AutoRestartRate 10/1h Background yes DNSTimeout 5 Umask 002 Syslog yes SyslogSuccess Yes LogWhy Yes Canonicalization relaxed/simple ExternalIgnoreList refile:/etc/opendkim/trusted.hosts InternalHosts refile:/etc/opendkim/trusted.hosts KeyTable refile:/etc/opendkim/key.table SigningTable refile:/etc/opendkim/signing.table Mode sv PidFile /run/opendkim/opendkim.pid SignatureAlgorithm rsa-sha256 UserID opendkim Socket local:/var/spool/postfix/opendkim/opendkim.sock Создадим все необходимые каталоги и файлы:\nsudo mkdir -p /etc/opendkim/keys sudo chown -R opendkim:opendkim /etc/opendkim sudo chmod go-rw /etc/opendkim/keys sudo mkdir -p /var/spool/postfix/opendkim sudo chown opendkim:opendkim /var/spool/postfix/opendkim sudo touch /etc/opendkim/key.table sudo touch /etc/opendkim/signing.table Теперь в файл /etc/opendkim/trusted.hosts и помещаем доверенные узлы, с которых может осуществляться отправка. В будущем, если нужно будет разрешить отправку почты с каких-то еще узлов, нужно будет добавить их в этот файл.\nsudo tee -a /etc/opendkim/trusted.hosts \u0026lt;\u0026lt;EOT 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 localhost denisbondar.com *.denisbondar.com EOT Теперь редактируем файл /etc/default/opendkim\nsudo nano /etc/default/opendkim Здесь нужно изменить (добавить) сокет, на котором OpenDKIM будет принимать соединения.\nSOCKET=local:/var/spool/postfix/opendkim/opendkim.sock Включаем и запускаем службу opendkim.\nsudo systemctl enable opendkim sudo systemctl restart opendkim Создание ключей # Описанные действия также необходимо будет выполнить при добавлении новых доменов, с которых ваш почтовый сервер будет уполномочен отправлять почту. Например, если у вас на сервере появится еще один сайт, работающий на другом домене, почта с которого должна отправляться с его доменного имени.\nДля создания сертификата можно воспользоваться онлайн инструментом dkimcore.org или же создать самому следующим образом:\nsudo mkdir -p /etc/opendkim/keys/denisbondar.com sudo opendkim-genkey -b 2048 --selector mail --domain denisbondar.com -D /etc/opendkim/keys/denisbondar.com/ sudo chown opendkim:opendkim /etc/opendkim/keys/denisbondar.com/mail.private sudo chmod 600 /etc/opendkim/keys/denisbondar.com/mail.private В результате будет создана пара ключей: mail.private (закрытый) и mail.txt (открытый). Открытый ключ далее необходимо будет прописать в NS-сервере. В данном случае mail — это селектор (он может быть любым).\nЕсли доменов/субдоменов несколько, нужно повторить эту процедуру для каждого из них.\nСоздаем таблицу /etc/opendkim/key.table — в ней находится список соответствий между селекторами, доменами и файлами с закрытыми ключами.\nФормат таблицы следующий:\n\u0026lt;селектор\u0026gt;._domainkey.\u0026lt;домен\u0026gt; \u0026lt;домен\u0026gt;:\u0026lt;селектор\u0026gt;:\u0026lt;путь к закрытому ключу\u0026gt; В нашем случае таблица будет создана следующим образом:\necho \u0026#34;mail._domainkey.denisbondar.com denisbondar.com:mail:/etc/opendkim/keys/denisbondar.com/mail.private\u0026#34; \\ | sudo tee -a /etc/opendkim/key.table Создаем таблицу /etc/opendkim/signing.table — в ней находится список соответствия между определенными email-адресами и записями в key.table.\necho \u0026#34;*@denisbondar.com mail._domainkey.denisbondar.com\u0026#34; \\ | sudo tee -a /etc/opendkim/signing.table Перезапускаем OpenDKIM.\nsudo systemctl restart opendkim Настройки DNS # Теперь необходимо внести следующие изменения в настройки вашего домена (NS-серверов).\nНеобходимо создать запись типа TXT и содержимым из файла открытого ключа.\nВыводим в консоль содержимое файла открытого ключа:\nsudo cat /etc/opendkim/keys/denisbondar.com/mail.txt | awk -F\u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $2}\u0026#39; ORS=\u0026#39;\u0026#39; Теперь создаем TXT-запись следующего вида (значением записи является заключенная в кавычки строка, полученная по команде выше):\nmail._domainkey IN TXT \u0026#34;v=DKIM1; ...\u0026#34; Добавьте также следующие TXT записи (для каждого своего субдомена):\n_domainkey IN TXT \u0026#34;o=~; r=postmaster@denisbondar.com\u0026#34; _dmarc IN TXT \u0026#34;v=DMARC1; p=none\u0026#34; Проверка # Для проверки ключа, выполните:\nsudo opendkim-testkey -d denisbondar.com -s mail -vvv Postfix # Добавить пользователя postfix в группу opendkim:\nsudo adduser postfix opendkim Теперь необходимо внести изменения в /etc/postfix/main.cf\nsudo nano /etc/postfix/main.cf Редактируем либо добавляем следующие строки. Так как Postfix работает в chroot, то путь к файловому сокету будет относительно chroot:\nmilter_protocol = 6 milter_default_action = accept smtpd_milters = local:opendkim/opendkim.sock non_smtpd_milters = $smtpd_milters Перезапускаем Postfix.\nsudo systemctl restart opendkim postfix Проверка # Для полной проверки воспользуемся сервисом mail-tester.com.\nНа странице сервиса отображается адрес электронной почты, на который следует отправить письмо для теста. Копируем его и отправляем на него письмо из консоли сервера:\necho \u0026#34;Test letter.\u0026#34; | mail \\ -s \u0026#34;Testing denisbondar.com\u0026#34; \\ -a \u0026#34;Smtp: localhost:25\u0026#34; \\ -a \u0026#34;From: blog@denisbondar.com\u0026#34; \\ -a \u0026#34;List-Unsubscribe: \u0026lt;mailto: unsubscribe@denisbondar.com?subject=unsubscribe\u0026gt;\u0026#34; \\ test-xxxxxxx@srv1.mail-tester.com После чего нажимаем «Затем проверить оценку».\nВ приведенном выше примере отправки тестового письма содержится заголовок List-Unsubscribe. В данном случае он необходим только для того чтобы получить максимальный бал. Очень желательно, чтобы ваши письма по возможности имели такой заголовок — это требование для рассылок. В личной переписке в этом заголовке, конечно же, смысла нет.\nНу и, долгожданный результат!\nВсё настроено превосходно\n"},{"id":4,"href":"/post/winbox-wine-tahoma-font/","title":"Winbox в Wine как исправить кривой шрифт","section":"Posts","content":" Winbox в Wine как исправить кривой шрифт # Я работаю в Linux (KDE Neon) и единственное Windows-приложение, которое мне приходится использовать — это Winbox (утилита для управления оборудованием MikroTik). Раньше я работал в других дистрибутивах Linux и эта проблема присутствовала и в них тоже.\nТе, кто работал с Winbox в Linux, а может быть и в MacOS, если там эта проблема также присутствует, не могли не заметить проблемы со шрифтом, которая очень сильно влияет на комфортную работу, не позволяя нормально управлять курсором при редактировании значений полей и при выделении части поля для копирования.\nВыделен пароль, но размер выделения значительно превышает размер символов\nПри редактировании невозможно определить, где фактически находится\nПосле выхода WINE 5, я надеялся, что эту проблему исправят. Но нет. Пришлось разбираться сначала с причиной этой проблемы, а затем находить способы ее решения. (Статья редактировалась в февраля 2022 года, когда уже вышла 7я версия WINE, но проблему до сих пор не исправили и, видимо, никто не собирается это делать).\nПричина проблемы # Причина данной проблемы кроется в “кривом” шрифте Tahoma, который поставляется вместе с Wine. Конечно же, можно установить нормальный шрифт Tahoma в систему (либо в окружение пользователя), также можно, используя утилиту winetrix, установить нормальный шрифт прямо внутрь окружения Wine. Судя из документации Wine, шрифты пользователя имеют приоритет над системными, а системные имеют приоритет над шрифтами внутри Wine. Но ожидаемого чуда не произошло — Wine по прежнему использовал “кривой” шрифт Tahoma.\nЯвное отличие в начертаниях “кривого” и нормального варианта Tahoma заключается в цифре 9 и в ширине знакомест.\nНачертание \u0026ldquo;кривого\u0026rdquo; шрифта # Обычное начертание \u0026ldquo;кривого\u0026rdquo; шрифта\nЖирное начертание \u0026ldquo;кривого\u0026rdquo; шрифта\nНачертание нормального шрифта # Обычное начертание нормального шрифта\nЖирное начертание нормального шрифта\nРешение проблемы # Вариант с заменой шрифта Tahoma на корректный # Немного покопавшись в реестре я нашел ветку со шрифтами, в которой каждому шрифту соответствует его путь в файловой системе. Я попробовал заменить пути на свои (куда я установил нормальные шрифты), но Wine не сохраняет эти значения и сбрасывает эти значения на первоначальные.\nЯ решил зайти с другой стороны и заменил файлы шрифтов по пути из реестра на свои. И это сработало! Теперь у меня наконец-то нормальный Winbox, с которым можно работать!\nВозможно, достаточно просто установить нормальные шрифты в Wine (например, используя winetrix), а затем просто удалить “кривые” шрифты. Я так не пробовал. Если у кого-то сработает этот вариант - дайте, пожалуйста, знать.\nСкачать нормальные шрифты вручную, или через winetrix или при помощи команды:\ncd /tmp \u0026amp;\u0026amp; \\ wget https://blog.denisbondar.com/file/tahoma.tar.gz Разархивировать нормальные шрифты и скопировать их на место старых:\ntar xzf tahoma.tar.gz sudo mv tahoma/* /opt/wine-stable/share/wine/fonts rm -rf tahoma* Теперь Winbox выглядит ровно. Размер выделения соответствует размеру текста, курсор отображается корректно. Выделен пароль. Размер выделения совпадает с размером текста.\nКурсор находится точно в тех позициях, где и должен быть.\nВариант с использованием другого шрифта # Чуть позже я нашел способ проще. Достаточно в реестре (в том самом, который бывает в Windows) указать другой используемый шрифт для MS Shell Dlg и MS Shell Dlg 2. По умолчанию для них указан шрифт Tahoma.\nСделать это можно редактированием ветки реестра HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes напрямую через утилиту regeidit или же просто выполнив простую замену в файле реестра, например вот так:\nsed -i \u0026#39;s@\u0026#34;MS Shell Dlg\u0026#34;=\u0026#34;Tahoma\u0026#34;@\u0026#34;MS Shell Dlg\u0026#34;=\u0026#34;Lato\u0026#34;@\u0026#39; ~/.wine/system.reg sed -i \u0026#39;s@\u0026#34;MS Shell Dlg 2\u0026#34;=\u0026#34;Tahoma\u0026#34;@\u0026#34;MS Shell Dlg 2\u0026#34;=\u0026#34;Lato\u0026#34;@\u0026#39; ~/.wine/system.reg Или вот так:\nsed -i \u0026#39;s@\u0026#34;MS Shell Dlg\u0026#34;=\u0026#34;Tahoma\u0026#34;@\u0026#34;MS Shell Dlg\u0026#34;=\u0026#34;DejaVu Sans\u0026#34;@\u0026#39; ~/.wine/system.reg sed -i \u0026#39;s@\u0026#34;MS Shell Dlg 2\u0026#34;=\u0026#34;Tahoma\u0026#34;@\u0026#34;MS Shell Dlg 2\u0026#34;=\u0026#34;DejaVu Sans\u0026#34;@\u0026#39; ~/.wine/system.reg Или как либо еще. На ваш вкус.\n"},{"id":5,"href":"/post/how-to-install-docker-on-linux/","title":"Установка Docker в Linux","section":"Posts","content":" Установка Docker в Linux # В этой заметке пойдет речь об установке Docker и Docker Compose в Linux. Сначала приведу однострочный способ установки, а затем официальную инструкцию с сайта Docker. Так что, если вдруг не сработает короткий способ, то официальный способ будет подстраховкой.\nDocker # Однострочный # Однострочный способ установки заключается в запуске скрипта, который содержит необходимые команды под конкретный дистрибутив. Запустите в терминале:\ncurl -fsSL get.docker.com | sh Установка должна сразу же начаться. По окончании сценарий предложит добавить текущего пользователя в группу docker, чтобы текущий пользователь выполнял команды docker без использования sudo. Для этого лучше выполнить команды:\nsudo gpasswd -a $USER docker newgrp docker Если вместо установки отображается сообщение о дистрибутиве, который не поддерживается, с паузой в 10 секунд для остановки процесса, то лучше остановить процесс и произвести установку вручную. Такое случается, если дистрибутив не поддерживаются скриптом.\nОфициальный для Ubuntu # Если однострочный способ не сработал — пробуем инсталлировать вручную каждый компонент по отдельности. Далее следует набор команд для установки последней версии Docker для Ubuntu 20.04:\nsudo apt update \u0026amp;\u0026amp; sudo apt install -y ca-certificates curl gnupg lsb-release curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update \u0026amp;\u0026amp; sudo apt install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin sudo gpasswd -a $USER docker newgrp docker Официальный для Debian # sudo apt update \u0026amp;\u0026amp; sudo apt install -y ca-certificates curl gnupg lsb-release curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture)] https://download.docker.com/linux/debian $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update \u0026amp;\u0026amp; sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin sudo gpasswd -a $USER docker newgrp docker Для других операционных систем инструкции доступны на официальном сайте.\nПроверка после установки # docker run hello-world После выполнения этой команды загрузится образ hello-world и запустится контейнер на основе этого образа. В итоге Вы увидите следующее:\nHello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. Это означает, что установка и проверка прошли корректно.\n"},{"id":6,"href":"/post/phpstorm_docker_xdebug/","title":"PhpStorm + Docker + Xdebug","section":"Posts","content":" PhpStorm + Docker + Xdebug # Внимание! Статья технически устарела. Обратитесь к репозиторию — он поддерживается в актуальном состоянии.\nВ этой небольшой статье я опишу рабочее решение настройки Xdebug для использования его при отладке в PhpStorm с использованием удаленного интерпретатора PHP, работающего внутри Docker-контейнера.\nВ итоге получится конфигурация на базе окружения в Docker-контейнерах, которая позволит производить отладку Web-приложения, консольного приложения, тестов, запускаемых из консоли и запускаемых из PhpStorm.\nИсходные данные # У вас должны быть установлены Linux, PhpStorm, Docker, Docker-compose. У меня в блоге есть небольшая памятка, как установить Docker и docker-compose в Linux. Если Вы ведете разработку не на Linux, то Вам, наверное, придется чуть сложнее, но раз Вы читаете эту статью, значит Вы уже озадачились вопросом отладки с использованием php в контейнере Docker и у Вас уже всё давно установлено. Если настройки для MacOS или Windows будут отличаться от приведенных в статье, я обязательно укажу на это.\nСтатья будет рассмотрена на следующем примере. Каталог на локальной машине (хосте), в котором планируется разработать некоторое приложение: /home/denis/code/docker-xdebug. При этом корень Web-сервера находится в подкаталоге public. Основной каталог проекта отображается внутрь Docker-контейнеров на каталог /var/www. Внутри Docker-контейнера, при этом, получаем путь к корневому каталогу Web-сервера /var/www/public — именно на него настроен Web-сервер nginx.\nПример конфигурации # На самом деле, поставленная задача достаточно тривиальная. Все решения, которые мне удавалось находить ранее, были завязаны на IP-адресе хоста и их невозможно было использовать остальными членами команды, так как в каждом новом случае IP-адрес хоста был случайный и каждому члену команды приходилось бы менять IP-адрес на свой в общем файле конфигурации бандла, что крайне неудобно.\nРешение проблемы оказалось достаточно простым. Я просто создал общую сеть для бандла в docker-compose (192.168.220.0/28) и таким образом добился одинакового IP-адреса хоста (192.168.220.1) на всех машинах членов команды разработки.\nЕсли Вы используете MacOS или Windows, то вместо адреса 192.168.220.1 Вам нужно будет указать host.docker.internal в приведенном ниже docker-compose.yml.\nНиже приведу подробную инструкцию и все файлы, необходимые для сборки бандла с рабочей отладкой Xdebug.\nВ файлах отсутствует установка каких либо дополнительных зависимостей и расширений, так как в каждом проекте они свои. Это выходит за рамки данной статьи. Вы должны сами добавить их при необходимости.\ndocker-compose.yml # version: \u0026#39;3\u0026#39; services: php-fpm: build: context: docker/php-fpm volumes: - ./:/var/www environment: XDEBUG_CONFIG: \u0026#34;remote_host=192.168.220.1 remote_enable=1\u0026#34; PHP_IDE_CONFIG: \u0026#34;serverName=Docker\u0026#34; networks: - internal nginx: build: context: docker/nginx volumes: - ./:/var/www ports: - \u0026#34;80:80\u0026#34; depends_on: - php-fpm networks: - internal networks: internal: driver: bridge ipam: driver: default config: - subnet: 192.168.220.0/28 Если у вас MacOS или Windows, то вместо remote_host=192.168.220.1 используйте remote_host=host.docker.internal.\ndocker/php-fpm/Dockerfile # FROM php:7.2-fpm RUN apt-get update \u0026amp;\u0026amp; apt-get install -y wget git unzip \\ \u0026amp;\u0026amp; pecl install xdebug-2.7.1 \\ \u0026amp;\u0026amp; docker-php-ext-enable xdebug ADD ./php.ini /usr/local/etc/php/php.ini RUN wget https://getcomposer.org/installer -O - -q \\ | php -- --install-dir=/bin --filename=composer --quiet WORKDIR /var/www docker/php-fpm/php.ini # max_execution_time = 1000 max_input_time = 1000 Это необходимо для того, чтобы Вы успели изучить результаты отладки до истечения таймаута запроса.\ndocker/nginx/Dockerfile # FROM nginx ADD ./default.conf /etc/nginx/conf.d/default.conf WORKDIR /var/www docker/nginx/default.conf # server { listen 80; index index.php; server_name 127.0.0.1 localhost; root /var/www/public; location / { try_files $uri /index.php?$args; } location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass php-fpm:9000; fastcgi_index index.php; fastcgi_read_timeout 1000; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; } } Теперь просто запускаем бандл docker-контейнеров:\ndocker-compose up -d --build Настройка PhpStorm # Настройка отладки в PhpStorm типичная для подобных ситуаций. Необходимо в настройках File » Settings проделать следующее.\nДобавить Docker сервер # Если он у Вас еще не добавлен, конечно. Для этого откройте настройки: Build, Execution, Deployment » Docker. Затем нажмите плюсик, чтобы добавить новое подключение к докеру. У меня все подключилось сразу же в режиме Unix socket. Нажмите Apply. Добавление нового Docker сервера\nДобавить внешний интерпретатор # Откройте настройки: Languages \u0026amp; Frameworks » PHP. Справа от CLI Interpreter нажмите кнопку с тремя точками. Выбор версии PHP и добавление интерпретатора\nВ открывшемся окне CLI Interpreters нажмите плюс слева вверху и выберите там From Docker....\nДалее нужно выбрать Docker (либо в новых версиях PhpStorm можно также выбрать Docker Compose). Второй вариант мне показался удобней, так как в этом случае я вижу контейнеры только данного проекта, а не все существующие на хосте (у меня их довольно много). Docker Docker Compose\nНе забывайте правильно указывать наименование образа или сервиса. Нажмите ОК, после чего будет произведена попытка добавления выбранного интерпретатора из Docker.\nВ случае удачи, вы увидите следующее окно (здесь видно, что была определена версия PHP, конфигурационный файл PHP, а также, что очень важно, версия Xdebug. Переименуйте интерпретатор в нечто более понятное, например, как на скриншоте ниже.\nНачиная с версии PhpStorm 2019.1 появилась возможность выбора, каким образом запускать тесты в контейнере. Если у вас контейнер с постоянно работающей службой, такой как php-fpm, то выбирайте Connect to existent container. Если же у вас в качестве интерпретатора используется php-cli, который не выполняется постоянно, то выберите опцию Always start a new container. Нажмите OK. Настройка интерпретатора PHP\nТеперь Вы должны увидеть следующее: Path mappings берется из docker-compose.yml\nНажмите Apply.\nПроверить конфигурацию Xdebug # Откройте настройки: Languages \u0026amp; Frameworks » PHP » Debug. И нажмите на ссылку Validate. Нажмите Validate для проверки настройки\nОткроется окно, в котором Вы должны указать полный путь к web-корню (в нашем примере это подкаталог проекта public) и адрес сервера (в нашем примере порт 80 контейнера nginx транслируется в порт 80 хоста, поэтому в адресе порт не указывается. Если Вы транслировали в другой порт хоста — укажите обязательно его, например, http://127.0.0.1:8080). Нажмите Validate. Результаты проверки Xdebug\nЕсли у Вас результат проверки выглядит так же, то Вы все настроили правильно. Закройте окно Validate Debugger Configuration.\nЕсли у Вас проблема с валидацией имени сервера, значит вы в настройках сервера nginx не указали 127.0.0.1 в качестве одного из server_name. Если проблема с загрузкой php.ini, значит вы использовали другой способ конфигурирования PHP вместо загрузки php.ini в каталог контейнера /usr/local/etc/php/ — это не страшно, если Вы понимаете, что делаете.\nДобавить PHP сервер # Откройте настройки: Languages \u0026amp; Frameworks » PHP » Servers и нажмите плюсик, чтобы добавить новый.\nУкажите имя сервера Docker (должно совпадать с переменной окружения PHP_IDE_CONFIG в docker-compose.yml) и хост 127.0.0.1. Затем ниже включите опцию Use path mappings и укажите соответствие между локальным каталогом проекта и этим же каталогом проекта внутри Docker-контейнера. Это соответствие изначально настраивается в docker-composer.yml для службы php-fpm в разделе volumes. Затем нажмите OK. Новый PHP сервер с отображением локального каталога на каталог контейнера\nДобавить конфигурацию для запуска # Остался последний штрих — добавление конфигурации запуска. Мы добавим простую Web-страницу.\nВ главном меню Run перейдите в Edit configurations\u0026hellip;\nВ открывшемся окне нажимайте плюсик вверху слева и выбирайте PHP Web page. Укажите имя для данной страницы, например, WWW, затем укажите сервер, с которым связана эта страница (мы создали его на предыдущем шаге) и нажмите OK. Конфигурация Web сервера для отладки\nУпрощенный способ взаимодействия с контейнерами # Для управления контейнерами, вам придется использовать длинные команды вроде:\ndocker-compose up -d docker-compose down -v --remove-orphans docker-compose logs -f и так далее... Но это не самое сложное. Самое сложное заключается в том, что теперь для запуска тестов вам придется вызывать сценарии внутри контейнеров. Например, чтобы запустить конкретный набор тестов, вам придется ввести следующую команду:\ndocker-compose run --rm php-fpm vendor/bin/phpunit --testsuite unit Постоянный ввод таких команд — вырабатывает хорошую привычку, но быстро надоест. Ведь это можно упростить!\nДля этого создайте в корне проекта файл (например, с именем alias.bash), содержащий псевдонимы команд, а затем настройте PhpStorm таким образом, чтобы он подключал его при открытии терминала. В Git-репозитории, ссылка на который приведена в конце статьи, вы найдете все необходимые файлы из этой статьи, включая файл alias.bash, который уже содержит некоторые самые необходимые команды в более развернутом виде, который будет удобней для редактирования и поддержки.\nВаш файл alias.bash может, например, выглядеть следующим, упрощенным образом:\nalias env-up=\u0026#39;docker-compose up -d\u0026#39; alias env-stop=\u0026#39;docker-compose stop\u0026#39; alias phpunit=\u0026#39;docker-compose run --rm php-fpm vendor/bin/phpunit\u0026#39; Псевдонимы могут работать с параметрами. Это видно в последнем псевдониме — сценарию phpunit передаются все параметры, с которыми был вызван псевдоним. Такие псевдонимы можно назвать своего рода прокси-командами.\nЧтобы файл с псевдонимами применялся при открытии сессии терминала в PhpStorm, откройте настройки: Tools » Terminal и в поле Shell path введите:\n/bin/bash --rcfile alias.bash Настройка загрузки файла с псевдонимами при старте сессии оболочки в PhpStorm\nТеперь откройте терминал в PhpStorm Alt+F12. Если он уже был открыт, то нужно закрыть и открыть снова. Теперь попробуйте просто выполнить команду env-up и Вы увидите, что фактически выполнилась команда docker-compose up -d.\nВы можете составлять псевдонимы любой сложности, включая составные, состоящие из других псевдонимов. Это позволяет сосредоточиться на разработке, не отвлекаясь на составление команд для запуска чего либо внутри контейнера вручную.\nЗапуск отладки # Теперь пришло время приступить к самой отладке.\nВ подкаталоге проекта public создайте файл index.php с следующим содержимым:\n\u0026lt;?php $s = $_SERVER; phpinfo(); Вверху справа на панели запуска выберите созданную конфигурацию и нажмите зеленый треугольник. Это действие должно запустить сервер, который откроет в браузере файл index.php, в результате чего в браузере должен быть отображен результат работы phpinfo(). Результат работы index.php через браузер\nОтладка WEB-приложения # Устанавливаем точку останова на строку phpinfo(); И вместо зеленого треугольника нажмем кнопку с зеленым жуком — это запустит сервер в режиме отладки. При первом запуске отладки в браузере вам возможно понадобится специальное расширение JetBrains IDE Support, которое обычно предлагается к установке автоматически. Установите его.\nПри запуске отладки, откроется браузер с URL, к которому будет добавлен параметр с идентификатором сессии отладки, что-то вроде: http://127.0.0.1/?XDEBUG_SESSION_START=11223.\nПри этом вывод в браузер не будет выполнен, так как сработает точка останова. Вернитесь в окно PhpStorm. Активная точка останова выглядит вот так: Активная точка останова\nВ данном случае птичкой обозначается та точка (а их может быть несколько), на которой произошел останов. Все переменные выше будут подсвечены их значениями для удобства.\nТеперь переместимся ниже — на панель отладки. Панель отладки PhpStorm\nНа ней видна вся отладочная информация. Справа — значения всех переменных в текущей области видимости (здесь также видна наша переменная $s), слева виден стек вызовов (сейчас он пуст, так как у нас примитивный пример). Имеются кнопки на левой панели, при помощи которых можно перезапустить отладку, прервать отладки продолжить выполнение с этого места, остановить отладку и другие. На верхней панели имеются кнопки, при помощи которых можно управлять отладкой: проходить пошагово каждое действие, начиная с точки останова, перепрыгивать функции, не заходя во внутрь и т.д.\nТакже существует другой способ отладки - при помощи «прослушивания». Нажмите кнопку с телефонной трубкой, чтобы активировать режим прослушивания. После того, как кнопка изменит вид (с красного запрещающего знака на зеленые полоски), Вы можете просто открыть веб-приложение в браузере и, если в коде проставлены точки останова, режим отладки запустится автоматически. Отладка консольного приложения (CLI) # Для отладки консольного приложения можно нажать кнопку с трубкой, чтобы включить режим прослушивания, как\nТеперь можно запустить консольный скрипт следующей командой:\ndocker-compose exec php-fpm php ./public/index.php Также можно создать псевдоним для вызова php-сценариев и поместить его в файл alias.bash. Например, вот такой:\nalias php=\u0026#39;docker-compose exec php-fpm php\u0026#39; И теперь тоже самое можно будет сделать выполнив следующую команду:\nphp ./public/index.php Если при этом отладка не сработала, убедитесь, чтобы имя сервера, которое создавали выше, совпадало с именем сервера в файле docker-compose.yml в переменной окружения PHP_IDE_CONFIG.\nПосле окончания отладки не забудьте отключить режим прослушивания.\nОтладка тестов (PhpUnit) # С отладкой тестов дела обстоят точно так же, как и с консольным приложением. Включайте прослушивание (кнопку с трубкой) и запускайте тесты следующим псевдонимом (прокси-командой):\nphpunit Но используя PhpStorm намного удобней и практичней использовать встроенные средства запуска тестов, которые предоставляют удобную навигацию по тестам, а также множество других полезных функций. Для того чтобы запустить тестирование средствами PhpStorm, необходимо настроить тестовый фреймворк.\nОткройте настройки: Languages \u0026amp; Frameworks » PHP » Test Frameworks. И добавьте новый фреймворк (нажмите кнопку с плюсиком) - PHPUnit by Remote Interpreter. В открывшимся окне выберите наш интерпретатор и нажмите ОК. Настройка интерпретатора для PHPUnit\nЗатем необходимо указать путь к phpunit.xml, убедиться, что путь к Composer autoloader автоматически добавился (добавить вручную, если нет) и нажать ОК. Настройка PHPUnit\nТестовый фреймворк настроен. Теперь необходимо добавить конфигурацию запуска тестов, подобно той, которую мы добавляли чуть выше для запуска веб-приложения.\nДля этого в главном меню Run перейдите в Edit configurations\u0026hellip;\nНажмите плюсик и добавьте PhpUnit. Укажите удобное Вам имя, например Tests и установите переключатель запуска в Defined in the configuration file. Теперь Вы можете настраивать тесты через конфигурационный файл phpunit.xml. Конфигурация запуска тестов PHPUnit\nТеперь точно так же кнопкой с зеленым треугольником на панели запуска Вы можете запускать тесты в обычном режиме, кнопкой с жуком — запускать тесты в режиме отладки и кнопки с щитом запускать тесты в режиме расчета покрытия тестами (для расчета покрытия Вы должны настроить блок whitelist в конфигурационном файле phpunit.xml). При этом активировать режим прослушивания (кнопка с трубкой) уже не нужно.\nРезюме # В данной статье был описан простой способ настройки и использования отладчика Xdebug в PhpStorm, если используется удаленный интерпретатор в виде Docker-контейнера.\nВсе файлы можно скачать на GitHub: https://github.com/denisbondar/docker_php-fpm_xdebug\nПосле того, как Вы склонируете себе репозиторий, не забудьте выполнить composer install для установки зависимостей и создания автозагрузчика. Для этого можно воспользоваться уже входящим в набор псевдонимов псевдонимом composer:\ncomposer install "},{"id":7,"href":"/post/zfs-manual-rus/","title":"ZFS — Справочник команд","section":"Posts","content":" ZFS — Справочник команд # Данный справочник является переводом данной статьи. Авторы перевода: Евгений Ратников и Сгибнев Михаил. Огромное им спасибо за проделанную работу!\nДанная информация представлена в интернете на множестве ресурсов. Оригинальная статья оформлена в виде таблицы, я же оформлю ее в привычном для моего блога формате — в формате пошагового обучения.\nВ любом случае не забывайте про страницы справки по командам работы с ZFS.\nman zpool man zfs Так как включить в пул (zpool) можно любые сущности файловой системы, автор приводит примеры построения пулов и работы с ними с использованием простых файлов. Итак, создадим несколько файлов, с которыми будем работать подобно дискам.\ncd / mkfile 100m disk1 disk2 disk3 disk5 mkfile 50m disk4 Мы создали 5 «виртуальных дисков». Четыре имею размер по 100 Мб, а один — 50 Мб. Это пригодится для демонстрации работы с устройствами (разделами) разной ёмкости.\nРабота с пулом ZFS # Теперь создадим простой пул без избыточности, затем проверим его размер и использование.\nzpool create myzfs /disk1 /disk2 zpool list NAME SIZE USED AVAIL CAP HEALTH ALTROOT myzfs 191M 94K 191M 0% ONLINE - Созданы пул автоматически монтируется в каталог /myzfs. Посмотрим более детальную информацию о нашем хранилище.\nzpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Из вывода видно, что в пул включены два диска. Пул без избыточности (не mirror и не RAIDZ).\nТеперь попробуем удалить только что созданный пул. Должны же мы это уметь.\nzpool destroy myzfs zpool list no pools available Попробуем снова создать пул типа MIRROR (зеркало), но на этот раз попытаемся включить в него диски разного размера. Zpool не даст нам этого сделать. Чтобы безоговорочно создать такой пул, используйте опцию -f, но в этом случае помните — размер зеркала будет равен объему наименьшего диска.\nzpool create myzfs mirror /disk1 /disk4 invalid vdev specification use \u0026#39;-f\u0026#39; to override the following errors: mirror contains devices of different sizes Создать зеркалируемое (MIRROR) хранилище можно на двух и более устройствах. Сколько устройств в пуле типа MIRROR — столько у нас есть одинаковых копий данных.\nzpool create myzfs mirror /disk1 /disk2 /disk3 zpool list NAME SIZE USED AVAIL CAP HEALTH ALTROOT myzfs 95.5M 112K 95.4M 0% ONLINE - zpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 /disk3 ONLINE 0 0 0 errors: No known data errors Вместо зеркалирования можно использовать массивы RAID. Для этого необходимо создавать пул типа raidz вместо mirror. Подробнее в хендбуке.\nДавайте теперь исключим один из дисков из пула. Так как этот диск относится к зеркалу (MIRROR), то при его исключении никаких проблем не возникает.\nzpool detach myzfs /disk3 zpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Теперь давайте добавим к пулу новый диск. Если пул не был зеркальным, то он им станет после добавления нового диска.\nzpool attach myzfs /disk1 /disk3 zpool status -v pool: myzfs state: ONLINE scrub: resilver completed with 0 errors on Tue Sep 11 13:31:49 2007 config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 /disk3 ONLINE 0 0 0 errors: No known data errors А что будет, если попытаемся удалить, а не исключить устройство из пула? Zpool сообщит нам о том, что устройство не может быть удалено. Для начала его нужно отключить.\nzpool remove myzfs /disk3 cannot remove /disk3: only inactive hot spares can be removed zpool detach myzfs /disk3 Теперь давайте попробуем добавить диск горячей замены (hot spare) к нашему пулу.\nzpool add myzfs spare /disk3 zpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 spares /disk3 AVAIL errors: No known data errors А теперь удалим его из пула.\nzpool remove myzfs /disk3 zpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Теперь попробуем отключить один из дисков. Пока диск отключен, на него не будет производиться запись и с него не будет производиться чтение. Если использовать параметр -t, то при перезагрузке сервера диск вернется в состояние онлайн автоматически.\nzpool offline myzfs /disk1 zpool status -v pool: myzfs state: DEGRADED status: One or more devices has been taken offline by the administrator. Sufficient replicas exist for the pool to continue functioning in a degraded state. action: Online the device using \u0026#39;zpool online\u0026#39; or replace the device with \u0026#39;zpool replace\u0026#39;. scrub: resilver completed with 0 errors on Tue Sep 11 13:39:25 2007 config: NAME STATE READ WRITE CKSUM myzfs DEGRADED 0 0 0 mirror DEGRADED 0 0 0 /disk1 OFFLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Обратите внимание на состояние пула: DEGRADED\nТеперь включим этот диск.\nzpool online myzfs /disk1 zpool status -v pool: myzfs state: ONLINE scrub: resilver completed with 0 errors on Tue Sep 11 13:47:14 2007 config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Состояние пула снова ONLINE.\nВ данный момент в нашем пуле два диска: disc1 и disc2. Также в системе имеется диск disc3, но он не подключен к пулу. Предположим, что disc1 вышел из строя и его нужно заменить на disc3.\nzpool replace myzfs /disk1 /disk3 zpool status -v pool: myzfs state: ONLINE scrub: resilver completed with 0 errors on Tue Sep 11 13:25:48 2007 config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk3 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 errors: No known data errors Периодически для исправления ошибок необходимо выполнять процедуру чистки (scrubbing) для пулов типа MIRROR или RAID-Z. Данная процедура находит ошибки в контрольных суммах и исправляет их. Также восстанавливаются сбойные блоки.\nДанная операция слишком ресурсоемка! Следует выполнять ее только во время наименьшей нагрузки на пул.\nzpool scrub myzfs Если необходимо перенести пул в другую систему, то его необходимо сначала экспортировать.\nzpool export myzfs pool list no pools available А затем импортировать в новой системе.\nЕсли ключ -d не указать, то команда ищет /dev/dsk. Так как в данном примере мы используем файлы, необходимо указать директорию с файлами используемыми хранилищем.\nzpool import -d / myzfs zpool list NAME SIZE USED AVAIL CAP HEALTH ALTROOT myzfs 95.5M 114K 95.4M 0% ONLINE - Обновление версии пула. Показать версию используемого пула. Флаг -v показывает возможности, поддерживаемые данным пулом. Используйте флаг -a, чтобы обновить все доступные пулы до новейшей из них версии. Обновленные пулы больше не будут доступны из систем, на которых работают более старые версии.\nzpool upgrade This system is currently running ZFS pool version 8. All pools are formatted using this version. zpool upgrade -v This system is currently running ZFS pool version 8. The following versions are supported: VER DESCRIPTION --- -------------------------------------------------------- 1 Initial ZFS version 2 Ditto blocks (replicated metadata) 3 Hot spares and double parity RAID-Z 4 zpool history 5 Compression using the gzip algorithm 6 pool properties 7 Separate intent log devices 8 Delegated administration For more information on a particular version, including supported releases, see: http://www.opensolaris.org/os/community/zfs/version/N Where \u0026#39;N\u0026#39; is the version number. Если нужно получить статистику по операциям ввода/вывода пулов, выполняем команду.\nzpool iostat 5 capacity operations bandwidth pool used avail read write read write ---------- ----- ----- ----- ----- ----- ----- myzfs 112K 95.4M 0 4 26 11.4K myzfs 112K 95.4M 0 0 0 0 myzfs 112K 95.4M 0 0 0 0 Работа с файловой и другими системами ZFS # Файловая система # Создадим файловую систему в нашем пуле. Затем проверим автомонтирование новой файловой системы.\nzfs create myzfs/colin df -h Filesystem kbytes used avail capacity Mounted on ... myzfs/colin 64M 18K 63M 1% /myzfs/colin Получить список файловых систем ZFS можно следующей командой.\nzfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 139K 63.4M 19K /myzfs myzfs/colin 18K 63.4M 18K /myzfs/colin В данный момент в нашем пуле имеется одно зеркало, в которое входят два диска: disc2 и disc3.\nДавайте попробуем расширить наш пул. Попытаемся добавить к нему disc1\nzpool add myzfs /disk1 invalid vdev specification use \u0026#39;-f\u0026#39; to override the following errors: mismatched replication level: pool uses mirror and new vdev is file Попытка добавления не удалась, т.к. она неоднозначно и при добавлении диска к существующему зеркалу необходимо указать дополнительно один из существующих в этом зеркале дисков, либо добавить минимум два диска для формирования нового зеркала, которое будет входить в данный пул.\nДобавим к пулу новое зеркало, состоящее из дисков: disc1 и disc5\nzpool add myzfs mirror /disk1 /disk5 zpool status -v pool: myzfs state: ONLINE scrub: none requested config: NAME STATE READ WRITE CKSUM myzfs ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk3 ONLINE 0 0 0 /disk2 ONLINE 0 0 0 mirror ONLINE 0 0 0 /disk1 ONLINE 0 0 0 /disk5 ONLINE 0 0 0 errors: No known data errors Добавим теперь к пулу еще одну файловую систему и посмотрим, как это отразится на размере файловых систем, входящих в пул.\nzfs create myzfs/colin2 zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 172K 159M 21K /myzfs myzfs/colin 18K 159M 18K /myzfs/colin myzfs/colin2 18K 159M 18K /myzfs/colin2 Обе файловые системы, входящие в пул, по объему равны всему пулу. В этом заключается одно из преимуществ системы ZFS — по умолчанию нет никакого ограничения на файловые системы.\nЧтобы явно управлять объемом файловых систем, можно прибегнуть к резервированию — выделению гарантированного объема для файловой системы, либо квотированию — ограничению файловой системы по максимальному объему.\nДавайте зарезервируем для файловой системы /myzfs/colin место в пуле, равное 20 Мб. Остальные файловые системы, заполняя пул, в любом случае оставят для этой файловой системы 20 Мб места.\nzfs set reservation=20m myzfs/colin zfs list -o reservation RESERV none 20M none Теперь для файловой системы /myzfs/colin2 установим квоту в 20 Мб. Это означает, что данная файловая система не сможет занять в пуле более 20 Мб, даже если пул будет полностью свободным.\nzfs set quota=20m myzfs/colin2 zfs list -o quota myzfs/colin myzfs/colin2 QUOTA none 20M Также для файловой системы /myzfs/colin2 включим сжатие. Сжатие достаточно эффективно работает на уровне ZFS практически без потерь производительности (конечно же, при условии, что производительности сервера достаточно). Вместо compression=on можно использовать compression=gzip.\nzfs set compression=on myzfs/colin2 zfs list -o compression COMPRESS off off on Чтобы сделать файловую систему доступной по протоколу NFS, достаточно выполнить одну команду. Причем после перезагрузки сервера доступ к файловой системе утерян не будет. Никаких дополнительных настроек операционной системы производить не нужно.\nzfs set sharenfs=on myzfs/colin2 zfs get sharenfs myzfs/colin2 NAME PROPERTY VALUE SOURCE myzfs/colin2 sharenfs on local Точно так же в одну команду ресурс можно сделать доступным по протоколу SMB. Что пользователям ОС Windows наверняка пригодится.\nzfs set sharesmb=on myzfs/colin2 zfs get sharesmb myzfs/colin2 NAME PROPERTY VALUE SOURCE myzfs/colin2 sharesmb on local Для повышения надежности (если у вас обычный пул, без избыточности), можно использовать следующую опцию файловой системы.\nzfs set copies=2 myzfs/colin2 Теперь в файловой системе будет храниться по две копии каждого блока. Это имеет смысл, если пул без избыточности (mirror / raidz).\nSnapshots (снепшоты или снимки состояния) # Создать снепшот файловой системы очень просто. Давайте создадим снепшот для файловой системы myzfs/colin и назовем его test.\nzfs snapshot myzfs/colin@test zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 20.2M 139M 21K /myzfs myzfs/colin 18K 159M 18K /myzfs/colin myzfs/colin@test 0 - 18K - myzfs/colin2 18K 20.0M 18K /myzfs/colin2 Если появится необходимость отката к снепшоту, достаточно выполнить одну команду.\nzfs rollback myzfs/colin@test Снэпшот можно подмониторовать, как обычно. Например так.\nmount -t zfs myzfs/colin@test /mnt Даже можно клонировать файловую системы из снепшота в новую файловую систему.\nzfs clone myzfs/colin@test myzfs/colin3 zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 20.2M 139M 21K /myzfs myzfs/colin 18K 159M 18K /myzfs/colin myzfs/colin@test 0 - 18K - myzfs/colin2 18K 20.0M 18K /myzfs/colin2 myzfs/colin3 0 139M 18K /myzfs/colin3 Теперь давайте удалим наши файловые системы /myzfs/colin и /myzfs/colin2\nСперва удалим пустую файловую систему /myzfs/colin2\nzfs destroy myzfs/colin2 zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 20.1M 139M 22K /myzfs myzfs/colin 18K 159M 18K /myzfs/colin myzfs/colin@test 0 - 18K - myzfs/colin3 0 139M 18K /myzfs/colin3 Файловая система удалилась без проблем. Теперь удалим файловую систему, для которой существует снепшот.\nzfs destroy myzfs/colin cannot destroy \u0026#39;myzfs/colin\u0026#39;: filesystem has children use \u0026#39;-r\u0026#39; to destroy the following datasets: myzfs/colin@test Удаление невозможно, т.к. у файловой системы имеется дочерний объект. Можно воспользоваться параметром -r чтобы удалить файловую систему вместе со всеми дочерними объектами рекурсивно.\nМы можем отключить снепшот от /myzfs/colin и оставить его дочерним только для /myzfs/colin3\nzfs promote myzfs/colin3 zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 20.1M 139M 21K /myzfs myzfs/colin 0 159M 18K /myzfs/colin myzfs/colin3 18K 139M 18K /myzfs/colin3 myzfs/colin3@test 0 - 18K - zfs destroy myzfs/colin zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 147K 159M 21K /myzfs myzfs/colin3 18K 159M 18K /myzfs/colin3 myzfs/colin3@test 0 - 18K - Теперь сделанный ранее снепшот для /myzfs/colin стал дочерним объектом /myzfs/colin3. Таким образом у файловой системы /myzfs/colin больше нет дочерних объектов и ее можно без труда разобрать (удалить).\nЕсли вдруг понадобиться переименовать ранее созданную файловую систему или снепшот, то можно воспользоваться следующими командами.\nzfs rename myzfs/colin3 myzfs/bob zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 153K 159M 21K /myzfs myzfs/bob 18K 159M 18K /myzfs/bob myzfs/bob@test 0 - 18K - zfs rename myzfs/bob@test myzfs/bob@newtest zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 146K 159M 20K /myzfs myzfs/bob 18K 159M 18K /myzfs/bob myzfs/bob@newtest 0 - 18K - Снова вернемся к пулам # Получить полную информацию о пулах можно следующим образом.\nzfs get all NAME PROPERTY VALUE SOURCE myzfs type filesystem - myzfs creation Tue Sep 11 14:21 2007 - myzfs used 146K - myzfs available 159M - myzfs referenced 20K - [...] Если пул нам более не нужен, можем его удалить. Однако, нельзя удалить пул, в котором имеются активные файловые системы.\nzpool destroy myzfs cannot destroy \u0026#39;myzfs\u0026#39;: pool is not empty use \u0026#39;-f\u0026#39; to force destruction anyway Чтобы принудительно удалить пул, используйте параметр -f (не выполняйте это сейчас. Пул нам еще понадобится далее)\nzpool destroy -f myzfs zpool status -v no pools available Отключить файловую систему от пула можно следующим образом.\nzfs unmount myzfs/bob df -h myzfs 159M 20K 159M 1% /myzfs Подключить файловую систему к пулу вот так.\nzfs mount myzfs/bob df -h myzfs 159M 20K 159M 1% /myzfs myzfs/bob 159M 18K 159M 1% /myzfs/bob Снепшот можно сделать и на удаленный ресурс (или другое место в локальной системе).\nzfs send myzfs/bob@newtest | ssh localhost zfs receive myzfs/backup zfs list NAME USED AVAIL REFER MOUNTPOINT myzfs 172K 159M 20K /myzfs myzfs/backup 18K 159M 18K /myzfs/backup myzfs/backup@newtest 0 - 18K - myzfs/bob 18K 159M 18K /myzfs/bob myzfs/bob@newtest 0 - 18K - В данном случае снепшот передан zfs receive на локальном узле (в демонстрационных целях). В реальной ситуации таким образом можно сделать снепшот на другой узел сети.\nZpool ведет собственную историю всех команд. Посмотреть историю можно следующим образом.\nzpool history History for \u0026#39;myzfs\u0026#39;: 2007-09-11.15:35:50 zpool create myzfs mirror /disk1 /disk2 /disk3 2007-09-11.15:36:00 zpool detach myzfs /disk3 2007-09-11.15:36:10 zpool attach myzfs /disk1 /disk3 2007-09-11.15:36:53 zpool detach myzfs /disk3 2007-09-11.15:36:59 zpool add myzfs spare /disk3 2007-09-11.15:37:09 zpool remove myzfs /disk3 2007-09-11.15:37:18 zpool offline myzfs /disk1 2007-09-11.15:37:27 zpool online myzfs /disk1 2007-09-11.15:37:37 zpool replace myzfs /disk1 /disk3 2007-09-11.15:37:47 zpool scrub myzfs 2007-09-11.15:37:57 zpool export myzfs 2007-09-11.15:38:05 zpool import -d / myzfs 2007-09-11.15:38:52 zfs create myzfs/colin 2007-09-11.15:39:27 zpool add myzfs mirror /disk1 /disk5 2007-09-11.15:39:38 zfs create myzfs/colin2 2007-09-11.15:39:50 zfs set reservation=20m myzfs/colin 2007-09-11.15:40:18 zfs set quota=20m myzfs/colin2 2007-09-11.15:40:35 zfs set compression=on myzfs/colin2 2007-09-11.15:40:48 zfs snapshot myzfs/colin@test 2007-09-11.15:40:59 zfs rollback myzfs/colin@test 2007-09-11.15:41:11 zfs clone myzfs/colin@test myzfs/colin3 2007-09-11.15:41:25 zfs destroy myzfs/colin2 2007-09-11.15:42:12 zfs promote myzfs/colin3 2007-09-11.15:42:26 zfs rename myzfs/colin3 myzfs/bob 2007-09-11.15:42:57 zfs destroy myzfs/colin 2007-09-11.15:43:23 zfs rename myzfs/bob@test myzfs/bob@newtest 2007-09-11.15:44:30 zfs receive myzfs/backup Ну вот. Основные команды для работы с пулами ZFS усвоены.\nТеперь можно удалить сам пул и файлы. Они нам больше не пригодятся.\n"},{"id":8,"href":"/post/midi-keybiard-jack-bitwig-studio/","title":"Как подключить MIDI клавиатуру к Bitwig Studio","section":"Posts","content":" Как подключить MIDI клавиатуру к Bitwig Studio # Если Вы используете Bitwig Studio под Linux, то наверняка уже знаете об аудио сервере Jack, который предоставляет возможность передачи аудио и MIDI в реальном времени без задержек. По умолчанию Bitwig Studio использует именно его для вывода аудиопотока, а также для ввода аудио и MIDI, что позволяет работать без задержек.\nУ меня есть только одна единственная MIDI клавиатура — «Alesis Q49». И я никак не мог подключить ее к Bitwig Audio, пока не нашел следующий трюк.\nЕсли коротко, трюк заключается в подключении MIDI клавиатуры к виртуальному MIDI устройству при помощи Jack. И уже в Bitwig Studio нужно просто выбрать это виртуальное MIDI устройство. Если такого простого описания для вас недостаточно, то далее я расскажу поэтапно, что нужно сделать на примере графического интерфейса к Jack, который называется QjackCtl.\nПошаговая инструкция # Первым делом закройте Bitwig Studio и остановите сервер Jack, если он у вас запущен — в интерфейсе QjackCtl нажмите кнопку Стоп. Остановите сервер Jack нажатием кнопки Стоп в QjackCtl\nТеперь перейдите в настройки QjackCtl, нажав кнопку Параметры в правой части окна QjackCtl.\nНа вкладке Общие во внутренней вкладке Основные установите значение нет для драйвера MIDI. Драйвер MIDI: нет\nНа вкладе Разное включите опцию Включить поддержку секвенсера ALSA. Активируйте: Включить поддержку секвенсера ALSA\nНажмите ОК, после чего закройте QjackCtl и откройте терминал. В терминале необходимо загрузить модуль ядра, отвечающий за виртуальные MIDI устройства. Выполните:\nsudo modprobe snd_virmidi Теперь запустите QjackCtl и запустите сервер Jack нажав кнопку Запустить. После чего нажмите кнопку Соединения. Нажмите Запустить и затем Соединения\nОткроется окно соединений, в котором вам необходимо на вкладке ALSA скоммутировать выход устройства слева (в моем случае это Q49) с входом первого виртуального MIDI справа (в моем случае это Virtual Raw MIDI 1-0). Выделите их и нажмите кнопку Соединить, как показано ниже. Соедините выход Q49 MIDI 1 с входом VirMIDI 1-0\nЗакройте окно Соединения и сверните Jack. Запустите Bitwig Studio и перейдите в Settings и затем в Controllers. Bitwig - Settings - Controllers\nНажмите кнопку Add и выберите из списка Generic – MIDI Keyboard. Таким образом Вы добавите контроллер. Теперь выберите вход контроллера — Virtual Raw MIDI/1.\nНа этом настройка завершена.\nЧтобы каждый раз не загружать модуль ядра вручную, добавьте его в автозагрузку. Это делается одной командой в терминале:\necho \u0026#34;snd_virmidi\u0026#34; | sudo tee /etc/modules-load.d/midi.conf Подключение ЦАП к Jack в качестве устройства вывод # У меня есть простенький, но достаточно качественный ЦАП Fiio Olimpus E10 и попытавшись подключить его к Jack в качестве устройства вывода я столкнулся с проблемой. Jack не хотел его подключать, сообщая об ошибке. Но решение оказалось довольно простым.\nЕсли у вас есть простой ЦАП (DAC), который имеет только устройство воспроизведения, то, чтобы подключить его к Jack в качестве устройства вывода необходимо выбрать режим подключения «Только воспроизведение».\nДля этого откройте QjackCtl, затем нажмите кнопку Параметры и в окне параметров, на вкладке Общие перейдите на внутреннюю вкладку Дополнительно. Там найдите параметр Звук и переключите его в режим: Только воспроизведение. Нажмите ОК. Режим Звук: Только воспроизведение\nТеперь вы можете использовать ваш ЦАП как устройство вывода без проблем.\nУспехов в творчестве!\n"},{"id":9,"href":"/post/how-to-install-debian-8/","title":"Как установить Debian 8 без знаний и опыта","section":"Posts","content":" Как установить Debian 8 без знаний и опыта # «Как установить Debian без знаний и опыта» — это довольно частый вопрос, который мне приходится слышать. Хоть я и не считаю себя специалистом в этой области, я все же накопил некоторые инструкции для себя, которые позволяют мне быстро установить или настроить то или иное приложение либо операционную систему.\nВ данной статье, как и в остальных статьях моего блога, будет показан пример установки со скриншотами и подробным описанием того, что при этом происходит и для чего это нужно. Даже будет затронута тема LVM. Инструкция довольно длинная и нудная. Больше подойдет тем, кто сталкивается с установкой Linux впервые и хочет найти ответы на большинство своих вопросов в одном месте, не гугля целый день. Хотя, учитывая объем инструкции, Вам придется потратить на нее целый день :) Шутка. На самом деле уже через час у Вас будет свой собственный Debian сервер, который Вы создали и настроили сами!\nПодача материала в этой инструкции тоже своеобразная: если затрагивается какая-то тема во время установки, то по этой теме при возможности будет дана краткая справочная информация и некоторые действия, которые можно произвести уже на установленной системе.\nDisclamer # Напомню. Я не профессионал в данном вопросе. Моя инструкция может содержать огромное множество неточностей и ошибок, которые заметят профессионалы. Если Вы один из них, пожалуйста, дайте знать, что я указал неверно, либо забыл указать — я с удовольствием исправлю.\nВведение # Мы будем устанавливать Debian с целью исследований новой для нас операционной системы и ее возможностей или же с целью развёртывания полноценного WEB-сервера, сервера баз данных либо чего душа пожелает. Мы не будем устанавливать графическую оболочку, так как на сервере в ней нет никакой необходимости.\nУ меня не было свободной физической машины, чтобы провести полную установку со снятием скриншотов, поэтому я воспользовался виртуальной машиной для этих целей. В связи с этим в статье будет описана «чистая» установка на новый чистый виртуальный жесткий диск.\nЗагрузка дистрибутива # Текущей версией на время написания статьи (март 2017) является Debian 8 с кодовым названием «Jessie».\nСуществует три основных способа установки Debian (ссылки на загрузку будут представлены ниже):\nЗагрузка полного образа CD или DVD. Это удобно, если на будущем сервере пока еще нет доступа в интернет для загрузки компонентов по сети. Выбирая этот способ, достаточно загрузить образ первого CD или DVD, который содержит саму операционную систему и наиболее необходимые программные компоненты. Размер файла образа CD примерно 650 Мб. Загрузка образа сетевой установки (netinstall). Данный образ содержит только саму операционную систему. Все дополнительные компоненты будут загружены из интернет. Размер файла такого образа примерно 250 Мб. Загрузка образа стандартного минидиска. Данный способ подходит, если Вам периодически, время от времени, необходимо устанавливать Debian и Вы хотите, чтобы каждый раз устанавливалась самая последняя версия операционной системы и программных компонентов. Образ минидиска имеет размер примерно 28 Мб. Все файлы операционной системы и программных компонентов загружаются через интернет. Есть еще один способ — самостоятельная сборка дистрибутива. Но мы не будем рассматривать этот способ, так как это заслуживает отдельной большой статьи.\nОбразы по первым двум вариантам установки можно загрузить по адресу:\nЕсли нужен CD либо netinstall перейдите на FTP-сервер по адресу: ftp.ua.debian.org/debian-cd/current/amd64/iso-cd/ и скачайте необходимый образ, например, CD №1: debian-8-amd64-CD-1.iso или Netinstall: debian-8-amd64-netinst.iso. Если нужен DVD перейдите на FTP-сервер по адресу: ftp.ua.debian.org/debian-cd/current/amd64/iso-dvd/ и скачайте DVD №1: debian-8-amd64-DVD-1.iso. Образ минидиска можно скачать по адресу: ftp.ua.debian.org/debian/dists/jessie/main/installer-amd64/current/images/netboot/mini.iso. Обратите внимание, что этот загрузочный мини-образ устанавливает последнюю версию Debian ветки «Jessie», в то время как предыдущие ссылки ведут на каталог с образами самой последней версии Debian не привязываясь к ветке. За более подробной информацией Вы можете обратиться к официальному руководству: загрузка образа CD и DVD, загрузка образов для установки через интернет.\nЗапись дистрибутива на носитель # После того, как файл образа загружен, его нужно записать на носитель. Проще всего использовать CD-R или DVD-R диски, если у Вас еще остались приводы для их записи. Но самым ожидаемым способом является запись образа на USB-флешку, с которой затем и будет производиться установка.\nДля записи я использую утилиту «UNetbootin», которую можно бесплатно загрузить на сайте http://unetbootin.github.io/. Обратите внимание на то, что флешка будет автоматически отформатирована! То есть все данные с нее будут удалены. Предупредил.\nЗапишите образ, выбрав следующие параметры, указав файл образа и нажав ОК: Установка Debian # Подключите USB-флешку к серверу и включите его. Вызовите меню загрузки BIOS (Boot menu) и выберите загрузку с USB-устройства, которое должно будет появиться в этом списке. После этого произойдет загрузка загрузчика с флешки и Вы увидите следующий приветственный экран: Если всё так, то разрешите Вас поздравить! Первый этап пройден. Вы скачали и записали установочный образ на носитель и даже смогли загрузиться с него. Идем дальше — жмем Install.\nИнтерактивная конфигурация # Локаль # Далее в интерактивном режиме Вам будет предложено выбрать язык установщика и местонахождение. Эти два параметра определяют основную локаль устанавливаемой системы. Например, если язык будет выбран Русский, а страна Украина, то в итоге выбранная локаль (и кодировка) будет иметь вид: ru_UA.UTF-8.\nЛокаль определяет непосредственно язык системы и региональные особенности этого языка. Это может влиять на отображение времени, валют, календаря (первый день недели), алфавитную сортировку и т.д.\nКодировка определяет то, каким способом будут кодироваться символы UNICODE. По умолчанию в Debian используется UTF-8.\nРекомендуется выбрать наиболее правильную локаль изначально. В будущем основную локаль можно изменить, а также можно добавить любое количество дополнительных локалей, например, для поддержки разных языков в приложениях, которые будут работать на этом сервере.\nВо время инсталляции выбор языка и региона выглядит следующим образом Если Вам нужно изменить локаль уже после установки, то Вы можете воспользоваться следующими инструментами:\nВыполните команду locale, чтобы узнать, какая локаль установлена в системе по умолчанию. Чтобы посмотреть все установленные в системе локали, выполните locale -a. Чтобы добавить в систему новые локали и/или изменить локаль по умолчанию, выполните команду sudo dpkg-reconfigure locales — Вам будет предложено выбрать локали, которые необходимо установить и затем какую локаль установить как основную. Есть еще один способ добавить необходимую локаль. Отредактируйте файл /etc/locale.gen, раскомментировав строки с необходимыми локалями, после чего выполните команду sudo locale-gen.\nНастройка клавиатуры # Следующим этапом идет настройка клавиатуры. Выберите, какая раскладка клавиатуры Вам необходима и на следующем экране выберите сочетание клавиш для переключения между выбранной и стандартной латинской раскладками.\nВо время инсталляции эти диалоговые окна выглядят следующим образом Так как почти вся последующая работа с сервером в будущем будет происходить через SSH, то изменять настройки клавиатуры после установки операционной системы вряд ли понадобится. Но, если вдруг такая необходимость появилась, то выполните команды sudo dpkg-reconfigure keyboard-configuration и затем sudo service keyboard-setup restart. Более подробная информация по этой теме доступна в wiki.\nНастройка сети # Следующим этапом идет настройка сети. Сначала компонент настройки попытается получить сетевые настройки автоматически по протоколу DHCP. Если в сети, к которой подключен сервер, нет DHCP-сервера, жмите Отмена — Вам будет предложено настроить сетевой интерфейс вручную через интерактивный диалог, в котором Вам будет необходимо ввести IP-адрес, маску подсети, адрес шлюза и адреса серверов имен DNS. Далее будет предложено указать имя узла (хоста), а затем имя домена, в который входит данный сервер. В процессе эксплуатации операционной системы Вам вероятно понадобится изменять сетевые настройки.\nНастройки сетевых интерфейсов хранятся в файле /etc/network/interfaces.\nПосле его редактирования не забудьте перезапустить сетевой стек командой /etc/init.d/networking restart. Будьте осторожны, если Вы делаете это удаленно, можете потерять связь с сервером.\nЕсли же необходимо изменить настройки DNS, просто отредактируйте файл /etc/resolv.conf, добавив в него строки формата:\nnameserver 8.8.8.8 nameserver 8.8.4.4 Имя узла и домена в последствии можно изменить командой hostname newname.newdomain. Чтобы имя узла было установлено при загрузке, измените его в файле /etc/hostname (пропишите имя узла без домена). Не забудьте изменить файл /etc/hosts, указав в нем новое имя узла с доменом и без.\nВыбор зеркала архива Debian # Далее необходимо указать страну, в которой расположен Ваш сервер, для отображения списка доступных зеркал. Вы должны будете выбрать сервер зеркала архива Debian, с которого будет производиться загрузка всех файлов.\nРекомендуется использовать ftp.\u0026lt;код страны\u0026gt;.debian.org — мы так и поступим. В большинстве случаев это оптимальный выбор. На следующем экране будет предложено настроить прокси-сервер, если в Вашей сети для доступа в интернет используется прокси. Если не используется — просто выбирайте Продолжить. Начнется загрузка дополнительных компонентов. Учетные записи пользователей # После загрузки компонентов будет предложено задать пароль для суперпользователя root — его нужно будет ввести дважды. Вы можете оставить пароль root пустым — этом случае получить права суперпользователя сможет обычный пользователь через sudo, учетная запись которого будет создана далее. Каким образом поступить Вам — зависит от режима администрирования сервера. Если Вы единственный админстратор, а сервер доступен только Вам, то отдельный пароль для root Вам может быть и не нужен. Если на сервере работает множество пользователей, то необходимо закрыть учетную запись суперпользователя root отдельным паролем. Далее будет предложено создать обычного пользователя. Сначала укажите полное имя пользователя (full name), затем его системное имя пользователя (username) и пароль. После чего будут загружены еще некоторые компоненты. При работе в операционной системе, для повышения полномочий обычных пользователей используется sudo. Это специальный инструмент, позволяющий выполнять часть операций или все возможные операции от имени другого пользователя (по умолчанию от имени root).\nЧтобы простой пользователь в системе мог выполнить команду с повышением (то есть с правами суперпользователя), он должен перед командой вставить sudo. Например: sudo apt-get update. Пользователю будет предложено повторно ввести свой пароль перед тем, как команда будет выполнена непосредственно. Если такой уровень безопасности с дополнительным вводом пароля Вам не нужен, можно отключить запрос пароля в конфигурационном файле /etc/sudoers.\nНе каждый пользователь может пользоваться повышением полномочий через sudo. То, какие пользователи и как именно имеют право пользоваться sudo, указывается в файле /etc/sudoers. В этом файле можно указывать права и привилегии как для каждого пользователя, так и для группы пользователей (перед именем группы указывается символ процента %). Например, чтобы разрешить безусловное использование sudo всем пользователям системы, входящим в группу пользователей sudo, необходимо добавить (или изменить) следующую запись в /etc/sudoers:\n%sudo ALL=(ALL:ALL) ALL Если хотите отключить дополнительный запрос пароля, то измените запись следующим образом:\n%sudo ALL=(ALL) NOPASSWD:ALL Теперь для всех пользователей системы, входящих в группу пользователей sudo, будет разрешено выполнять действия от имени других пользователей без дополнительного ввода своего пароля.\nЧтобы добавить существующего пользователя с именем vasya в группу sudo, просто выполните команду sudo usermod -a -G sudo vasya.\nРазметка диска # Данная тема достаточно обширная и ее детальное рассмотрение выходит далеко за рамки данной статьи. В данной же статье будет затронуто два способа разметки диска.\nПервый — простой способ разметки жесткого диска на разделы в автоматическом режиме, чего вполне достаточно для первой установки с целью ознакомления с системой и может быть достаточно для некоторых простых целей использования сервера.\nВторой — сложный способ с использованием менеджера логических томов (LVM) и ручным созданием разделов. Этот способ более предпочтителен, так как позволяет изменять физическую структуру в будущем.\nДалее описаны оба способа. Вы должны выбрать какой-то один из них, но не оба одновременно.\nАвтоматическая разметка диска # Выберите режим «Авто — использовать весь диск», после чего Вам будет предложено выбрать диск и затем выбрать схему расположения разделов на нем. Вы можете выбрать любую из предложенных схем — всё будет сделано инсталлятором автоматически. На скриншотах показана разметка, в которой используется один единственный корневой раздел (раздел swap будет создан автоматически). На диске будет создана таблица разделов FAT32. (В отличие от FreeBSD, где используется современная таблица разделов GPT, позволяющая создать достаточно большое количество разделов и легко управлять их размером).\nИспользуйте такой способ, если только нет смысла в нормальной правильной организации файловой системы (Ваша первая установка Debian с целью \u0026ldquo;пощупать\u0026rdquo;). Ручная разметка диска с использованием LVM # Тема LVM очень обширная. Чтобы изучить ее более детально, обратитесь к данной статье. Здесь же я попытаюсь дать очень краткое описание и объяснить, почему именно LVM я рекомендую использовать на сервере.\nПроще всего начать с обычной разметки, без использования LVM, которая была описана в предыдущем параграфе. В обычной разметке на самом носителе (физическом устройстве) создаются разделы, на каждом из которых создается файловые системы. Это удобно в простых случаях, так как не требует никаких сложных знаний. Всё в целом так же, как и в других операционных системах: есть диск, на нем есть разделы, которые содержать файловые системы. Эти разделы подмонтированы в операционной системе в точках монтирования. В unix системах это каталоги, в microsoft системах это буквы дисков. Всё просто и понятно. Однако, учитывая то, что у нас сервер, мы должны обеспечить максимально надежную его работу. Если на диске закончится свободное место, мы должны иметь возможность каким-то образом его расширить, используя дополнительный жесткий диск, либо, при использовании виртуальных устройств хранения, расширить объем самого устройства и иметь возможность изменить размер разделов файловой системы. Это и многое другое достаточно сделать при обычной организации разделов (FAT32).\nВ LVM для организации разделов используются не жесткие диски (точнее не сами физические устройства), а виртуальные группы томов. Разделы, или логические тома, создаются не на физическом диске, а внутри группы томов. Сама же группа томов является абстрактным понятием. В группу томов входят физические устройства или физические тома. Таким образом, имеется возможность изменять конфигурацию группы томов, добавляя в нее новые физические тома или изменяя их размер. С точки зрения логических томов, группа томов остается неизменной, лишь меняется ее размер. Файловые системы создаются не в разделах, как при использовании обычной разметки, а в логических томах. Размер логических томов можно изменять во время работы операционной системы в отличие от размера раздела диска FAT32, который изменить без потери данных достаточно проблематично.\nТерминология # Физический том — PV (physical volume) — физический том (входит в состав группы томов, представляет собой физический носитель)\nГруппа томов — VG (volume group) — группа томов (состоит из физических томов со стороны PV и из логических томов со стороны LV)\nЛогический том — LV (logical volume) — логический том (также входит в состав группы томов, эквивалент разделу диска в обычной не-LVM разметке, является блочным устройством, может содержать файловую систему)\nСхема разметки, используемая в примере # В данном примере будем использовать одну группу томов с именем vg1, в которую добавим один физический том (жесткий диск) и следующую схему логических томов: Логические тома входят в группу томов vg1, поэтому имеют соответствующие префиксы. Если в системе используется несколько групп томов, то указание таких префиксов делает работу с томами более удобной. Указание префиксов не является обязательным.\nПоехали! # В диалоговом окне выбора метода разметки выбираем — «Вручную». Затем выбираем жесткий диск (физическое устройство, не раздел) для размещения настроек и подтверждаем в третьем диалоговом окне. Далее необходимо выбрать настройку менеджера логических томов (LVM) и записать эту информацию на диск. Теперь создадим группу томов vg1 и добавим в нее наш физический том (т.е. физический диск). Если бы дисков в нашем сервере было несколько, можно было бы добавить в группу томов их все. С точки зрения логических томов всё это выглядело бы как одна группа томов, не зависимо от того, сколько в ней находится физических томов (то есть жестких дисков). После чего запишем изменения на диск. Пришло время создать логическое тома внутри группы томов. Эти операции равносильный созданию разделов диска на физическом диске при использовании не-LVM системы.\nСоздаем логические тома согласно таблице, указывая их имена и размер. Повторяем операцию для каждого логического тома. После создания последнего тома будет отображена текущая конфигурация LVM. После чего выбираем — Закончить. В итоге получили группу томов vg1, в которую входит один физический том /dev/sda1 и в которой создано пять логических томов с префиксом vg1 для удобства отличия их от логических томов, входящих в другие группы.\nТеперь на каждом из логических томов, согласно таблице, нужно создать файловую систему с указанием типов и точек монтирования. Эта процедура похожа на создание файловых систем на разделах диска в не-LVM Выбираем каждый раздел и создаем на нем файловую систему согласно таблице выше. Далее будут показаны скриншоты каждого из разделов. Не торопитесь, неправильное указание типа файловой системы или точки монтирования — распространенная ошибка. Обратите внимание, что для раздела boot используется Ext3, а для всех остальных, за исключением swap, используется Ext4. После создания файловой системы на каждом из логических томов, выбирайте пункт «Настройка раздела закончена». После создания всех необходимых файловых систем выберите «Закончить разметку и записать изменения на диск». Вот и всё :)\nУстановка системы и выбор ПО # Далее будет производиться установка системы, затем выбор и установка программного обеспечения.\nПри выборе программного обеспечения рекомендую оставить только «SSH-сервер» и «Стандартные системные утилиты». Даже если Вам нужен WEB-сервер, лучше установить последние версии Nginx (или Apache), а так же PHP, MySQL и т.д. из альтернативных репозиториев после установки операционной системы. Причина этому — репозиторий Debian содержат устаревшие версии программного обеспечения, некоторые из которых уже даже не поддерживаются разработчиками. Например, репозиторий Debian до сих пор предлагает PHP версии 5.5, которая уже не поддерживается разработчиками. Текущей версией PHP является 7.0 и 7.1, а минимальной поддерживаемой — 5.6.\nЯ недавно собрал список самых используемых приложений, которые желательно устанавливать из альтернативных репозиториев, предоставляемых самими разработчиками или репозиториев, собранных участниками сообщества. Список содержит все необходимые действия по добавлению альтернативных репозиториев в систему, а так же ссылки на оригинальные инструкции от разработчиков перечисленного ПО. Системный загрузчик GRUB # Последний этап установки Debian — установка загрузчика GRUB. Так как мы устанавливаем Debian как единственную операционную систему на нашем сервере, то просто установите загрузчик в главную загрузочную область, как это предлагается инсталлятором. На втором экране выберите устройство для установки системного загрузчика. В дальнейшем Вы можете добавлять в конфигурацию GRUB другие ядра или другие операционные системы, если в этом будет необходимость.\nЧтобы изменить загрузчик, отредактируйте файл /etc/default/grub, затем запустите sudo update-grub, чтобы сформировать загрузчик. Вы также можете редактировать или добавлять различные сниппеты, которые хранятся в каталоге /etc/grub.d/, если в этом будет какая-то необходимость и Вы знаете что делаете.\nСтоит обратить внимание на то, что изменения загрузчика могут привести к тому, что сервер не сможет загрузиться. Не стоит это делать, если к серверу нет непосредственного доступа. Будьте осторожны!\nЗавершение установки # Вот и всё. Установка завершена. Нажмите «Продолжить», чтобы перезагрузить сервер. После перезагрузки убедитесь, что включена загрузка с жесткого диска и Вы извлекли носитель с дистрибутивом Debian (но не извлекайте его до начала перезагрузки).\nПосле перезагрузки Вы должны увидеть меню загрузчика GRUB. Вы можете немного подождать, либо нажать Enter, чтобы продолжить загрузку.\nПосле окончания загрузки Вы увидите приглашение операционной системы. Можно Вас поздравить с успешно установленной системой.\nТеперь проделайте тоже самое, но уже без инструкции. Обращайтесь к ней лишь изредка, чтобы проконтролировать правильность выполнения своих действий.\nНастройка после установки # После установки желательно проделать несколько простых действий, чтобы сделать работу более приятной.\nРепозиторий APT # Первое, что необходимо сделать — это сконфигурировать стандартный репозиторий. Отредактируйте файл /etc/apt/sources.list введя команду sudo nano /etc/apt/sources.list.\nУдалите или закомментируйте строки, в которых указан репозиторий, находящийся на CD (если Вы устанавливали систему с полных образов, то эти записи могут присутствовать).\nЭти строки выглядят подобным образом (начинаются с dev cdrom):\ndeb cdrom:[Debian GNU/Linux 6.0.1 _Squeeze_ - Official amd64 DVD Binary-1 20110319-14:31]/ squeeze contrib main Репозиторий Debian предоставляет три раздела пакетов программного обеспечения:\nmain — абсолютно бесплатное программное обеспечение, требование к которому предъявлены в следующих критериях. Это целиком бесплатное программное обеспечение, которое если имеет зависимости, то так же целиком бесплатные. contrib — бесплатное программное обеспечение. Программное обеспечение, входящее в данный пакет, так же как и main — абсолютно бесплатное, однако возможно, что хотя бы одна из любых, даже косвенных зависимостей данного программного обеспечения является платной (входит в пакет non-free). По умолчанию раздел не включен в файл /etc/apt/sources.list и Вы не сможете установить программное обеспечение, входящее в этот раздел, пока не добавите его репозиторий в /etc/apt/sources.list non-free — возможно бесплатное программное обеспечение — то, которое не соответствует критериям. Данный разел так же не включен в /etc/apt/sources.list по умолчанию, но Вы можете сделать это самостоятельно. Добавляя в /etc/apt/sources.list разделы contrib и non-free, вы самостоятельно принимаете на себя ответственность за использование проприетарного программного обеспечения.\nДля этого достаточно привести файл /etc/apt/sources.list к виду:\ndeb http://ftp.ua.debian.org/debian/ jessie main contrib non-free deb-src http://ftp.ua.debian.org/debian/ jessie main contrib non-free deb http://security.debian.org/ jessie/updates main contrib non-free deb-src http://security.debian.org/ jessie/updates main contrib non-free deb http://ftp.ua.debian.org/debian/ jessie-updates main contrib non-free deb-src http://ftp.ua.debian.org/debian/ jessie-updates main contrib non-free Более подробно об этом можно прочитать в wiki.\nК этому же параграфу можно отнести и добавление альтернативных репозиториев, если в них есть необходимость, о которых шла речь в разделе Установа системы и выбор ПО.\nОбновление ПО и ОС # В Debian обновление программного обеспечения и операционной системы объедено в одно действие.\nДля начала необходимо произвести обновление информации из репозиториев: sudo apt-get update\nЗатем произведите обновление ПО и ОС командой: sudo apt-get dist-upgrade\nПроверьте текущую версию Debian командой lsb_release -a\nСинхронизация времени NTP # Чтобы часы на сервере всегда показывали точное время (это критически необходимо для работы большинства приложений), необходимо обзавестись NTP-клиентом.\nУстанавливаем: sudo apt-get install ntp ntpdate\nПосле установки автоматически будет запущен NTP-клиент. Для начала остановим его: sudo service ntp stop\nОткроем конфигурационный файл /etc/ntp.conf и приведем список серверов к виду:\nserver 0.ua.pool.ntp.org iburst server 1.ua.pool.ntp.org iburst server 2.ua.pool.ntp.org iburst server 3.ua.pool.ntp.org iburst Пытаемся прочитать время с одного из серверов: sudo ntpdate 0.ua.pool.ntp.org\nЕсли все в порядке, то выполняем команду еще раз, но в этот раз указывая на необходимость записи полученного времени в локальные системные часы: sudo ntpdate -bs 0.ua.pool.ntp.org\nЕсли вдруг обнаружили, что часовой пояс настроен неверно, выполните команду: sudo dpkg-reconfigure tzdata и укажите свое местоположение.\nТеперь запускаем остановленный сервер: sudo service ntp start\nСпустя минуту наблюдаем за работой: ntpq -p\nПоследний штрих # Для включения автодополнения bash, в файле /etc/bash.bashrc раскомментируйте if-fi блок, озаглавленный комментарием (не сам комментарий, а блок, расположенный сразу под ним):\n# enable bash completion in interactive shells Если Вам нравится разноцветная консоль, включить ее очень просто. В файле .bashrc, находящимся в Вашем домашнем каталоге, раскомментируйте строку (будет включено только для Вашей учетной записи):\n#force_color_prompt=yes Установите Dialog, чтобы заменить консольные интерактивные меню на псевдографические диалоговые окна: sudo apt-get install -y dialog\nЕсли командная строка пока еще не Ваш конёк, установите файловый менеджер Midnight Commander: sudo apt-get install -y mc\nВместо того, чтобы устанавливать Debian на свой сервер, Вы можете заказать виртуальный сервер с уже установленным Debian на нем! Вы можете настроить его под свои нужды и использовать как пожелаете. Для этого достаточно зарегистрироваться на DigitalOcean и выбрать любую удобную для Вас конфигурацию «капли». При регистрации Вы получите бонус в виде 100$ на Ваш счет на 60 дней. Это, может быть, даже более предпочтительным вариантом, чем организовывать свой собственный сервер, так как вы получаете виртуальный сервер с профессиональным обслуживанием и гарантированной работой (электропитание и интернет) для любых своих нужд.\nУспехов в освоении Debian!\n"},{"id":10,"href":"/post/install-nginx-php7-mysql57-mariadb11-debian-ubuntu/","title":"Установка Nginx 1.13, PHP 7, MySQL 5.7, MariaDB 10.1, PostgreSQL 11 в Debian и Ubuntu","section":"Posts","content":" Установка Nginx 1.13, PHP 7, MySQL 5.7, MariaDB 10.1, PostgreSQL 11 в Debian и Ubuntu # Набор инструкций для установки последних версий Nginx, PHP, MySQL, MariaDB на компьютер (сервер) под управлением операционных систем Debian или Ubuntu. Инструкции описывают простое добавление альтернативных репозиториев в систему и установку приложений из них.\nРазделы данной инструкции не пересекаются между собой. Это всего лишь набор не связанных инструкций. Всё, что их связывает, это дополнение стандартного репозитория альтернативными с последними версиями. Всё это одновременно устанавливать не нужно! Инсталлируйте только то, что Вам необходимо.\nОписаны следующие приложения (версии указаны на момент написания статьи):\nNginx (1.15) MySQL (5.7, 8.0) MariaDB (10.1) PostgreSQL (11) PHP (7.1, 7.2, 7.3) MongoDB (3.4) Elasticsearch (5.4) Внимание! Здесь не описан атомарный процесс установки и настройки web-сервера! Не задавайте, пожалуйста, подобных вопросов в комментариях.\nДля начала установите компоненты, которые могут быть полезны и без которых некоторые примеры не сработают:\nsudo apt-get install -y apt-transport-https lsb-release ca-certificates Nginx 1.15 # Официальная документация по установке для различных ОС доступна по адресу: www.nginx.com\nСпособ установки для Ubuntu 12.04, 14.04, 15.10, 16.04 # wget http://nginx.org/keys/nginx_signing.key sudo apt-key add nginx_signing.key echo \u0026#34;deb http://nginx.org/packages/mainline/ubuntu/ $(lsb_release -sc) nginx\u0026#34; | sudo tee -a /etc/apt/sources.list.d/nginx.list echo \u0026#34;deb-src http://nginx.org/packages/mainline/ubuntu/ $(lsb_release -sc) nginx\u0026#34; | sudo tee -a /etc/apt/sources.list.d/nginx.list sudo apt-get remove -y nginx-common sudo apt-get update sudo apt-get install -y nginx Способ установки для Debian 7, 8, 9 # wget http://nginx.org/keys/nginx_signing.key sudo apt-key add nginx_signing.key echo \u0026#34;deb http://nginx.org/packages/mainline/debian/ $(lsb_release -sc) nginx\u0026#34; | sudo tee -a /etc/apt/sources.list.d/nginx.list echo \u0026#34;deb-src http://nginx.org/packages/mainline/debian/ $(lsb_release -sc) nginx\u0026#34; | sudo tee -a /etc/apt/sources.list.d/nginx.list sudo apt-get remove -y nginx-common sudo apt-get update sudo apt-get install -y nginx MySQL 5.7 (8) # Если Вы используете MariaDB вместо MySQL, то пролистайте до следующего раздела.\nДанный способ одинаково подходит для установки на:\nDebian 7, 8, 9 Ubuntu 12.04 LTS, 14.04 LTS, 16.04 LTS Официальный источник: dev.mysql.com. Имя файла конфигурационного пакета может измениться к моменту чтения Вами данной статьи. По выше приведенной ссылке Вы можете узнать актуальное имя файла.\nВо время инсталляции репозитория mysql-apt-config будет предложено выбрать версию MySQL, дополнительные настройки и компоненты. Если текущая операционная система не поддерживается, то также будет предложено выбрать подходящую версию ОС.\nwget https://repo.mysql.com/mysql-apt-config_0.8.22-1_all.deb sudo dpkg -i mysql-apt-config_0.8.22-1_all.deb sudo apt-get update sudo apt-get install mysql-server Если нужно сконфигурировать сервер при помощи мастера, выполните:\nsudo mysql_secure_installation Если Вы производили обновление со старой версии MySQL, то не забудьте сразу же после установки новой версии и запуска сервера проапгрейдить все базы данных:\nmysql_upgrade -u root -p --verbose MariaDB 10.1 # Если Вы используете MariaDB вместо MySQL.\nОфициальный источник: downloads.mariadb.org\nУстановка MariaDB в ОС Ubuntu 12.04 или 14.04 # sudo apt-get install -y python-software-properties sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db sudo add-apt-repository \u0026#34;deb [arch=amd64,i386] http://mirror.timeweb.ru/mariadb/repo/10.1/ubuntu $(lsb_release -sc) main\u0026#34; sudo apt-get update sudo apt-get install mariadb-server Установка MariaDB в ОС Ubuntu 16.04 # Разница заключается лишь в ключе, остальные команды те же:\nsudo apt-get install -y python-software-properties sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8 sudo add-apt-repository \u0026#34;deb [arch=amd64,i386] http://mirror.timeweb.ru/mariadb/repo/10.1/ubuntu $(lsb_release -sc) main\u0026#34; sudo apt-get update sudo apt-get install mariadb-server Установка MariaDB в ОС Debian 7 и 8 # sudo apt-get install -y software-properties-common sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 0xcbcb082a1bb943db sudo add-apt-repository \u0026#34;deb [arch=amd64,i386] http://mirror.timeweb.ru/mariadb/repo/10.1/debian $(lsb_release -sc) main\u0026#34; sudo apt-get update sudo apt-get install mariadb-server PostgreSQL 11 # Официальная документация по установке: www.postgresql.org\nУстановка для ОС Ubuntu 12.04, 14.04, 15.10, 16.04 и для ОС Debian 7, 8 идентична:\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - echo \u0026#34;deb http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -sc)-pgdg main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/pgdg.list sudo apt-get update sudo apt-get install postgresql-11 PHP # Существует несколько альтернативных репозиториев PHP для Debian и Ubuntu. Я использую deb.sury.org\nЕсли использовать для установки метапакет, вроде php-fpm, то будет автоматически установлена самая последняя версия, существующая на данный момент (7.2). Я не рекомендую так делать, так как если последняя версия, скажем, была 7.0, а затем вышла 7.1, то при следующем обновлении у вас будет обновлена 7.0 и дополнительно установлена 7.1. Поэтому лучше указывать версию явно.\nУстановка PHP в ОС Ubuntu # Используется альтернативный репозиторий ondrej/php на launchpad.net:\nLC_ALL=C.UTF-8 sudo add-apt-repository ppa:ondrej/php sudo apt-get update sudo apt-get install php7.2-fpm Установка PHP в ОС Debian # Используется альтернативный репозиторий на packages.sury.org:\nsudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg echo \u0026#34;deb https://packages.sury.org/php/ $(lsb_release -sc) main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/php.list sudo apt-get update sudo apt-get install php7.2-fpm MongoDB 3.4 # Официальный источник: docs.mongodb.com\nУстановка MongoDB в ОС Ubuntu 12.04, 14.04 # sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 echo \u0026#34;deb [ arch=amd64 ] http://repo.mongodb.org/apt/ubuntu $(lsb_release -sc)/mongodb-org/3.4 multiverse\u0026#34; | sudo tee -a /etc/apt/sources.list.d/mongodb-org.list sudo apt-get update sudo apt-get install mongodb-org Установка MongoDB в ОС Ubuntu 16.04 # sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 echo \u0026#34;deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu $(lsb_release -sc)/mongodb-org/3.4 multiverse\u0026#34; | sudo tee -a /etc/apt/sources.list.d/mongodb-org.list sudo apt-get update sudo apt-get install mongodb-org Установка MongoDB в ОС Debian 7 и 8 # sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 echo \u0026#34;deb http://repo.mongodb.org/apt/debian $(lsb_release -sc)/mongodb-org/3.4 main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/mongodb-org.list sudo apt-get update sudo apt-get install mongodb-org Elasticsearch 5.4 # Официальный источник: www.elastic.co\nУстановка для всех apt-систем одинаковая:\nwget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - sudo apt-get install apt-transport-https echo \u0026#34;deb https://artifacts.elastic.co/packages/5.x/apt stable main\u0026#34; | sudo tee -a /etc/apt/sources.list.d/elastic-5.x.list sudo apt-get update sudo apt-get install elasticsearch "},{"id":11,"href":"/post/russia-attack-ukraine-jule-2014/","title":"Обстрел Донбасса с территории РФ июль 2014","section":"Posts","content":" Обстрел Донбасса с территории РФ июль 2014 # Обстрел Амвросиевки 14 июля 2014 # Все следующие скриншоты приложения Google Earth я делал лично. Вы можете открыть Google Earth и переместиться по истории на 16.07.2014, чтобы самостоятельно проанализировать написанное далее.\nКоординаты зоны обстрела: 47°45′40″, 38°30′59″. В зоне обстрела видны воронки, с вероятным азимутом прилёта снарядов 190–195°. Это отлично видно по форме воронок. Предположительное размещение орудий на диаметрально противоположной стороне с азимутом 10–15°. Дальность стрельбы РСЗО «Град» с осколочно-фугасным снарядом от 4 до 40 км. Амвросиевка. Прилёт снарядов\nДавайте смотреть, что находится на ЮЮЗ в диапазоне этих расстояний по азимуту 190–195°. Следы работы РСЗО на противоположной стороне\nКоординаты зоны ведения огня: 47°38′14″, 38°28′09″. Территория Российской Федерации (н.п. Селезнев). Расстояние до зоны обстрела ≈15 км. В Google Earth характерные следы от пусков видны на снимках от 16.07.2014.\nФорму воронок от ОФС и вид следов пусковой установки \u0026ldquo;Град\u0026rdquo; вы легко найдете в сети самостоятельно.\nОбстрел под Свердловском 25 июля 2014 # Координаты зоны обстрела: 47°59′45″, 39°38′32″. В зоне обстрела видны воронки с вероятным азимутом прилёта снарядов 105–115°. Предположительное размещение орудий с азимутом 285–295°. Свердловск. Прилёт снарядов\nВероятная зона ведения огня имеет координаты: 47°56′23″, 39°50′24″. Территория Российской Федерации (н.п. Павловка). Расстояние до зоны обстрела ≈15 км. Следы пусков не видны, однако по этим координатам отчетливо видны огневые позиции. Расположение войск РФ на противоположной стороне\nВот вам и «С днем победы над фашизмом\u0026hellip;»\n"},{"id":12,"href":"/post/asterisk-13-chan_dongle-debian-8/","title":"Установка Asterisk 13 + chan_dongle (E1550, E1750) на Debian 8","section":"Posts","content":" Установка Asterisk 13 + chan_dongle (E1550, E1750) на Debian 8 # В предыдущей статье шла речь об установке системы Asterisk версии 11 на сервер под управлением Ubuntu. Основным поводом установки 11 версии было то, что под 13 версию не существовало модуля chan_dongle. Теперь такой модуль есть, поэтому есть смысл написать заново, теперь уже о Asterisk 13, Debian и некоторых других удобных полезных функциях.\nДанная инструкция описывает процесс установки телефонной системы Asterisk с модулями DAHDI, LibPRI, PJSip, SpanDSP, chan_dongle и дополнительными кодеками Opus и g729. Никаких WEB-интерфейсов и прочих утилит для конфигурирования и мониторинга системы данная инструкция не предусматривает. Это связано с тем, что автору приходилось неоднократно разбираться с конфигурационными файлами, сгенерированными автоматически при помощи FreeBPX и прочих подобных систем, что вызывало у автора сильную ненависть к подобным оболочкам. Поэтому, друзья, настраивайте все руками в конфигурационных файлах. Это не так сложно, зато работает как часы и разобраться намного проще.\nDisclamer\nАвтор предупреждает читателей, о тонкой грани между допустимым использованием телефонных систем подобного рода и уголовной ответственностью, которая может наступить при неправильной маршрутизации телефонного трафика (рефайлинг). Пожалуйста, ознакомьтесь с законодательством Вашей страны, чтобы избежать проблем. Автор снимает с себя ответственность за любые действия читателя, в которых ему может помочь материал данной статьи и возлагает ее целиком и полностью на читателя данной статьи. Информация, приведенная в данной статье, является справочной и не носит практического характера.\nВходные данные # Для написания статьи я создал тестовый виртуальный сервер под управлением Debian 8.4. Во время установки было выбрано следующее программное обеспечение: SSH-сервер и Стандартные системные утилиты. В боевой конфигурации рекомендуется выделить отдельный раздел диска для файлов записей разговоров, если это необходимо. Версия Debian\nВажное замечание: производите все действия по установке под учетной записью суперпользователя root. Не используйте sudo, так как это вызывает ошибки в некоторых случаях. Пожалуйста, не игнорируйте это замечание. Вы можете использовать команду:\nsu - либо разрешите на время установки доступ пользователю root через ssh, для чего в файле /etc/ssh/sshd_config установите параметр:\nPermitRootLogin yes и перезапустите ssh-сервер\nservice sshd restart Установка зависимостей # apt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade Далее скопируйте и вставьте целиком:\napt-get install -y build-essential \\ autoconf \\ libncurses5-dev \\ libssl-dev \\ libxml2-dev \\ libsqlite3-dev \\ libmysqlclient-dev \\ curl \\ mpg123 \\ libxml2 \\ libxml2-dev \\ libaudiofile-dev \\ subversion \\ sox \\ libsox-fmt-all \\ uuid-dev \\ libjansson-dev \\ libiksemel-dev \\ libssl-dev \\ libtiff5-dev \\ mysql-client \\ libmyodbc \\ lame \\ linux-headers-`uname -r` После этой процедуры желательно перезагрузить сервер.\nУстановка DAHDI # Внимание! В большинстве инсталляций Вам не пригодится этот модуль. Он необходим только если у Вас есть оборудование, подключенное к данному серверу, которое взаимодействует с телефонной сетью посредством E1, T1 и т.п. Это разного рода PSTN/DAHDI-платы.\ncd /usr/src wget http://downloads.asterisk.org/pub/telephony/dahdi-linux-complete/dahdi-linux-complete-current.tar.gz tar xvfz dahdi-linux-complete-current.tar.gz rm -f dahdi-linux-complete-current.tar.gz cd dahdi-linux-complete-* make all make install make config Результаты выглядят следующим образом: DAHDI make DAHDI make install DAHDI make config\nУстановка LibPRI # cd /usr/src wget http://downloads.asterisk.org/pub/telephony/libpri/libpri-current.tar.gz tar xvfz libpri-current.tar.gz rm -f libpri-current.tar.gz cd libpri-* make make install Результаты выглядят следующим образом: libpri make libpri install\nУстановка PJSip # PJSIP мультимедийная библиотека с открытым кодом, для реализации протоколов SIP, SDP, RTP, STUN, TURN и ICE. Она сочетает лучшие возможности SIP сигнализации, хорошую проходимость NAT и высокий уровень взаимодействия с приложениями. Подходит практически для любого типа систем, начиная от компьютеров и заканчивая встраиваемыми системами (embedded systems) и мобильными телефонами. Подробнее.\nСкопируйте ссылку на загрузку последней версии с сайта www.pjsip.org и используйте в команде wget ниже:\ncd /usr/src wget http://www.pjsip.org/release/2.6/pjproject-2.6.tar.bz2 tar -xjvf pjproject-*.tar.bz2 rm -f pjproject-*.tar.bz2 cd pjproject-* CFLAGS=\u0026#39;-DPJ_HAS_IPV6=1\u0026#39; ./configure --enable-shared --disable-sound --disable-resample --disable-video --disable-opencore-amr make dep make make install Результаты выглядят следующим образом: pjsip configure pjsip make dep pjsip make pjsip make install\nУстановка SpanDSP # Данный модуль необходим для работы с факсами. Если поддержка факсов не нужна, то можно смело пропустить установку этого модуля.\nТак как последняя версия spandsp была выпущена достаточно давно, то можно без проблем установить его из репозитория Debian.\napt-get install -y libspandsp2 libspandsp-dev Либо же загрузите последнюю версию для установки вручную:\ncd /usr/src wget http://soft-switch.org/downloads/spandsp/spandsp-0.0.6pre21.tgz tar vxfz spandsp-*.tgz rm -f spandsp-*.tgz cd spandsp-* ./configure make clean make make install Результаты выглядят следующим образом: spandsp configure spandsp make spandsp makeinstall\nУстановка Asterisk 13 # cd /usr/src wget http://downloads.asterisk.org/pub/telephony/asterisk/asterisk-13-current.tar.gz tar xvfz asterisk-13-current.tar.gz rm -f asterisk-13-current.tar.gz cd asterisk-13* contrib/scripts/get_mp3_source.sh contrib/scripts/install_prereq install ./configure make menuselect Результаты выглядят следующим образом: asterisk install_prereq asterisk configure — заветная звёздочка\nДалее в конфигурационном меню необходимо выбрать по необходимости следующие компоненты:\nAdd-ons: format_mp3 Core Sound Packages: CORE-SOUNDS-EN-(WAV, ALAW, GSM, G729, G722), CORE-SOUNDS-RU-(WAV, ALAW, GSM,G729, G722) Extras Sound Packages: WAV, ALAW, GSM, G729 и G722 Как это выглядит на скриншотах: Addons Core Sound Packages Extras Sound Packages\nПродолжаем установку (процесс make занимает достаточно много времени).\nSaples # Если это первая установка или у Вас еще нет базовых конфигурационных файлов, Вы можете их установить, выполнив make samples. Если Вы не понимаете, о чем идет речь, однозначно устанавливайте.\nmake make install make config make samples ldconfig Результаты выглядят следующим образом: asterisk make asterisk make install\nУстановка кодека G729 # Если кодек g729 не нужен — смело пропускаем.\nG729 — узкополосный речевой кодек (вокодер), который применяется для эффективного цифрового представления узкополосной телефонной речи (сигнала телефонного качества).\nДля начала нужно узнать, какой процессор используется в Вашем сервере:\ngrep -E \u0026#39;model name|flags\u0026#39; /proc/cpuinfo Внимание! Перед тем, как скачивать кодек, откройте сайт asterisk.hosting.lv, выберите подходящий под систему и процессор кодек, скопируйте ссылку на его загрузку и используйте именно эту ссылку в команде ниже! Это крайне важно!\nwget -P /usr/lib/asterisk/modules/ -O codec_g729.so ссылка_на_загрузку После установочная настройка # На этом основная установка системы окончена. Запустите Asterisk и убедитесь, что все в порядке:\n/etc/init.d/asterisk start ps ax | grep asterisk asterisk -rvvvvvvvvvvddddddddddc quit /etc/init.d/asterisk stop Если планируется использовать USB-модемы, то Asterisk желательно запускать от имени группы dialout, чтобы он имел доступ к устройствам USB.\nadduser --system --group --home /var/lib/asterisk --no-create-home --gecos \u0026#34;Asterisk PBX\u0026#34; asterisk usermod -a -G dialout,audio asterisk Задаем права на каталоги:\nchown -R asterisk:asterisk /var/lib/asterisk chown -R asterisk:asterisk /var/log/asterisk chown -R asterisk:asterisk /var/run/asterisk chown -R asterisk:asterisk /var/spool/asterisk chown -R asterisk:asterisk /usr/lib/asterisk chown -R asterisk:asterisk /etc/asterisk chmod -R u=rwX,g=rX,o= /var/lib/asterisk chmod -R u=rwX,g=rX,o= /var/log/asterisk chmod -R u=rwX,g=rX,o= /var/run/asterisk chmod -R u=rwX,g=rX,o= /var/spool/asterisk chmod -R u=rwX,g=rX,o= /usr/lib/asterisk chmod -R u=rwX,g=rX,o= /etc/asterisk Если Вы установили базовые конфигурационные файлы, то по умолчанию в них сконфигурирован английский язык (это влияет на речевые информаторы). Если желаете, можете изменяем язык на русский во всех файлах:\nsed -i \u0026#39;s/defaultlanguage = en/defaultlanguage = ru/\u0026#39; /etc/asterisk/asterisk.conf sed -i \u0026#39;s/;language=en/language=ru/\u0026#39; /etc/asterisk/*.conf В файле /etc/default/asterisk раскомментируем две строчки и изменяем название группы:\nAST_USER=\u0026#34;asterisk\u0026#34; AST_GROUP=\u0026#34;dialout\u0026#34; Запускаем Asterisk и смотрим, от какого пользователя он запустился:\n/etc/init.d/asterisk start ps aux | grep asterisk Должно быть: asterisk ps aux\nУстановка chan_dongle # Модуль chan_dongle необходим для работы с USB-модемами Huawei:\nK3715 E169 / K3520 E155X E175X K3765 Описываемая в данной статье версия является форком основного проекта, но основной проект не развивается с 2013 года и поддерживает только Asterisk 11. Впрочем, есть еще один форк той версии, что используется в данной статье. В связи с этим гарантировать работу модуля невозможно. Со списком известных багов можно ознакомиться по этой ссылке, но не ожидайте, что автор их исправит, так как этот список не обновлялся с 2011 года. Даже сам автор предупреждает, что модуль работает как попало и может назвонить вам куда нибудь и тем самым сожрать все ваши деньги или натворить еще что-то. Так что пожалуйста, прежде чем читать дальше, еще раз подумайте, стоит ли связываться с этим модулем. На сегодняшний день это единственный модуль, способный заставить дружить недорогие GSM-модемы с Asterisk и, скорее всего, у Вас нет выбора.\nThis channel driver is in alpha stage. I am not responsible if this channel driver will eat your money on your SIM card or do any unpredicted things.\nМодемы должны быть разлочены, проверка PIN-кода на SIM-карте должна быть отключена. Также необходимо обязательно отключить на модемах функции CR-ROM и CARDREADER, оставив модем только в режиме модема. Для этого необходимо подключиться к модему консолью и дать следующую АТ-команду:\nAT^U2DIAG=0 Также желательно отключить на модеме ожидание вызова:\nAT+CCWA=0,0,1 Установите необходимые для сборки chan_dongle пакеты:\napt-get install -y unzip automake autoconf Далее загружаем форк chan_dongle под Asterisk 13, разархивируем, собираем, устанавливаем. Не обращаем внимание на строчку \u0026ldquo;automake: error: no \u0026lsquo;Makefile.am\u0026rsquo; found for any configure output\u0026rdquo; — это не является ошибкой:\ncd /usr/src wget https://github.com/oleg-krv/asterisk-chan-dongle/archive/asterisk13.zip unzip asterisk13.zip rm -f asterisk13.zip cd asterisk-chan-dongle-asterisk13 aclocal \u0026amp;\u0026amp; autoconf \u0026amp;\u0026amp; automake -a ./configure make make install Результаты выглядят следующим образом: dongle configure dongle make install\nКопируем конфигурационный файл dongle.conf:\ncp etc/dongle.conf /etc/asterisk/ chown asterisk:asterisk /etc/asterisk/dongle.conf chmod u=rwX,g=rX,o= /etc/asterisk/dongle.conf Перезапускаем Asterisk, смотрим, загрузился ли модуль:\n/etc/init.d/asterisk restart asterisk -rvvvvvvvvvvddddddddddc dongle show devices Далее необходимо сделать так, чтобы модемам при подключении назначался верный владелец (чтобы Asterisk имел к ним доступ). Для этого создадим файл /etc/udev/rules.d/92-dongle.rules со следующим содержимым:\nKERNEL==\u0026#34;ttyUSB*\u0026#34;, MODE=\u0026#34;0666\u0026#34;, OWNER=\u0026#34;asterisk\u0026#34;, GROUP=\u0026#34;dialout\u0026#34; Затем перезапустим службу udev:\nservice udev restart Теперь при подключении устройства типа ttyUSB, система автоматически назначит ему владельца asterisk и группу dialout.\nИдентификация по IMSI или IMEI # В Файле /etc/asterisk/dongle.conf описываются все устройства. Синтаксис файла — общепринятый в Asterisk. Например, я опишу модем, в котором установлена SIM-карта оператора «Киевстар»:\n[Kievstar] imsi=255012321232123 imei=345654898756548 context=from-dongle Идентификация устройства производится по IMSI и IMEI. Можно идентифицировать устройство только по одному из параметров. IMSI — это идентификатор SIM-карты, IMEI — это идентификатор терминала. Если Вам важно идентифицировать устройства по SIM-картам, тогда Вы можете указать только IMSI номера этих SIM-карт (написаны на картах), если же важно идентифицировать по терминалам, тогда указывайте IMEI терминала (написан на модеме).\nВсе входящие вызовы с такого устройства будут обработаны контекстом from-dongle из файла extensions.conf или extensions.ael.\nИсходящие вызовы через данный модем необходимо направлять на Dongle/Kievstar.\nТакже в описании устройства можно указать exten=+380123456789. В таком случае все входящие вызовы будут иметь указанный exten. В некоторых случаях это возможно понадобится.\nЕсли идентификация по IMEI / IMSI не работает # В последней версии chan_dongle обнаружение устройств выполняется либо по идентификатору терминала (модема) — IMEI, либо по идентификатору абонента (SIM-карты) — IMSI. Если же по каким-то причинам Вам необходимо идентифицировать устройство по порту USB-контроллера, то используйте расширенную конфигурацию udev для присвоения псевдонимов портам, а затем эти псевдонимы можно использовать для определения модемов в dongle.conf.\nДля привязки модемов по номеру порта контроллера USB, нужно определить адреса этих портов. Извлеките все модемы из сервера, затем запустите:\nudevadm monitor Вставляйте по одному модему и записывайте адреса портов контроллера, которые относятся к каждому из них. Затем в файл /etc/udev/rules.d/92-dongle.rules допишите псевдонимы для каждого из модемов, указав адреса контроллеров в качестве ID, подобно следующему:\nKERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-1:1.1\u0026#34;, SYMLINK+=\u0026#34;Kievstar-audio\u0026#34; KERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-1:1.2\u0026#34;, SYMLINK+=\u0026#34;Kievstar-data\u0026#34; KERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-2:1.1\u0026#34;, SYMLINK+=\u0026#34;Vodafone-audio\u0026#34; KERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-2:1.2\u0026#34;, SYMLINK+=\u0026#34;Vodafone-data\u0026#34; KERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-3:1.1\u0026#34;, SYMLINK+=\u0026#34;Lifecell-audio\u0026#34; KERNEL==\u0026#34;ttyUSB[0-9]*\u0026#34;, ID==\u0026#34;1-3:1.2\u0026#34;, SYMLINK+=\u0026#34;Lifecell-data\u0026#34; Как видно из примера, необходимы только два порта, вместо четырех.\nТеперь в файле /etc/asterisk/dongle.conf вместо идентификации по IMEI и/или IMSI укажите идентификацию по портам USB следующим образом:\n[Kievstar] audio=/dev/Kievstar-audio data=/dev/Kievstar-data context=from-dongle Однако этот метод определения модемов не является рекомендуемым, т.к. при случайной смене USB-порта либо вообще ничего не будет работать, либо Ваши вызовы пойдут не туда куда планировалось. Настоятельно рекомендуется использовать идентификацию по IMEI / IMSI.\nНа этом установка полностью завершена.\n"},{"id":13,"href":"/post/asterisk11-chan_dongle_e1550-ubuntu14/","title":"Asterisk11 Chan_dongle_e1550 Ubuntu14","section":"Posts","content":" Asterisk11 Chan_dongle_e1550 Ubuntu14 # Статья еще не перенесена\n"},{"id":14,"href":"/post/asterisk-example-2-dongle-call-management/","title":"Asterisk. Пример 2 — SIP и DONGLE","section":"Posts","content":" Asterisk. Пример 2 — SIP и DONGLE # В данной статье будет рассмотрена простейшая связка SIP и DONGLE, которая интересует большинство. Более подробная настройка системы описана в предыдущем примере. Здесь же приведу только фрагменты конфигов с небольшим описанием того, что там настроено.\nВсе приведенные листинги конфигов являются полными листингами, если не указано другое. Иными словами Вы, если только пытаетесь разобраться с системой, должны удалить все строки из Ваших существующих конфигов и добавить только те, что приведены в этой статье. Перед этой процедурой лучше сделайте копию оригинальных конфигурационных файлов - они Вам еще пригодятся для изучения.\nВ первую очередь настроим вызовы между двумя SIP линиями, которые будем использовать для проверки, тестирования и изучения.\nDisclamer # Автор предупреждает читателей, о тонкой грани между допустимым использованием телефонных систем подобного рода и уголовной ответственностью, которая может наступить при неправильной маршрутизации телефонного трафика (рефайлинга). Пожалуйста, ознакомьтесь с законодательством Вашей страны, чтобы избежать проблем. Автор снимает с себя ответственность за любые действия читателя, в которых ему может помочь материал данной статьи и возлагает ее целиком и полностью на читателя данной статьи. Информация, приведенная в данной статье, является справочной и не носит практического характера.\nSIP # Файл sip.conf должен выглядеть так:\n[general] language = ru bindport = 5060 callcounter = yes limitonpeers = yes dtmfmode = rfc2833 compensate = yes defaultexpiry = 3600 disallow = all allow = alaw [LocalSip](!) dtmfmode = rfc2833 canreinvite = no host = dynamic type = friend port = 5060 qualify = yes deny = 0.0.0.0/0.0.0.0 permit = 0.0.0.0/0.0.0.0 callcounter = yes disallow = all allow = alaw [6000](LocalSip) username=6000 secret=606060 callerid=Vladimir Mayakovskiy \u0026lt;6000\u0026gt; context=from-sip-phone [6001](LocalSip) username=6001 secret=616161 callerid=Taras Shevchenko \u0026lt;6001\u0026gt; context=from-sip-phone Здесь были вынесены общие параметры в группу параметров LocalSip, а далее были настроены две SIP-линии, к которым были применены параметры группы. Контекст, правила которого будут обрабатывать вызовы — from-sip-phone.\nВ консоле Asterisk выполните команду reload, чтобы перечитать конфиги и подключите два SIP-softphone с приведенными в конфиге учетными данными к серверу. Убедитесь, что авторизация прошла успешно.\nsip show peers Позвонить Вы еще никуда не сможете, так как мы еще не настроили маршрутизацию.\nDongle # Теперь давайте настроим GSM модемы (Dongle). У нас подключены 2 модема. Первый с SIM-картой оператора Киевстар, второй с SIM-картой оператора Life. Как уже указывалось в основной статье по установке системы Asterisk, линии Dongle можно сконфигурировать различными способами:\nуказать только IMEI — в этом случае привязка линии будет осуществляться по IMEI модема (мобильного терминала). Вы можете менять SIM-карты или разъемы USB. Линия будет закреплена за модемом. указать только IMSI — в этом случае привязка линии будет осуществляться по IMSI номеру SIM-карты. Вы можете заменить модем на другой, можете поменять разъем USB. Линия будет закреплена именно за SIM-картой. жестко указать интерфейсы audio и data — в этом случае линия будет привязана к контроллеру USB (по факту к гнезду USB). Это очень неудобный способ и оставлен в новых версиях Dongle только для совместимости со старыми версиями и с некоторыми операционными системами, где обнаружение по IMEI и IMSI не работает. Самым удобным является способ привязки SIM карты (по номеру IMSI). В этом случае замена порта или модема, в случае их выхода из строя, не приведет к необходимости перенастраивать систему. Можно сочетать любые из способов, но это только затруднит эксплуатацию в будущем. Не усложняйте.\nФайл dongle.conf должен иметь следующее содержание (обратите внимание на секцию defaults — в данном примере указаны только важные параметры, а не точное содержимое. Не удаляйте все содержимое этого файла):\n[general] interval=15 [defaults] ; в этой секции закомментируйте exten= и оставляйте все остальные параметры как есть, кроме следующих параметров: ; это усиление принимаемого аудиосигнала (динамика) rxgain=0 ; это усиление передаваемого аудиосигнала (микрофона) txgain=0 ; желательно указывать для корректного речевого информирования language=ru ; желательно выключать, когда есть вероятность повреждения формы тональных сигналов dtmf=relax [KYIVSTAR] imsi=255031111111111 context=from-gsm [LIFE] imsi=255061111111111 context=from-gsm В итоге получим две линии, идентифицируемые как KYIVSTAR и LIFE, вызовы с которых должны будут обрабатываться правилами маршрутизации в контекте from-gsm.\nПараметры rxgain и txgain задают усиление. Указывается количество dB в виде целого положительного или отрицательного числа. 0 — усиление выключено. Включайте усиление только при явной необходимости, иначе будет страдать качество звука.\nВ итоге имеем две SIP-линии и два Dongle (GSM линии). Самое время начинать звонить между ними.\nExtensions # Сделаем следующую схему: SIP-линии должны звонить друг другу. SIP-линии должны звонить через линию KIEVSTAR только на номера этого оператора, а все остальные вызовы должны уходить через линию LIFE. Все входящие вызовы, поступающие на модемы, должны тут же маршрутироваться на обе SIP-линии. Очереди использовать не будем, может быть напишу об этом отдельно.\nЗа маршрутизацию отвечает подсистема extensions. Настройки очень простые и понятные, частично они были описаны в первом примере. Но на всякий случай прокомментирую. Файл extensions.conf очень маленький:\n[globals] [general] autofallthrough=yes ; Этот контекст принимает и обрабатывает вызовы с SIP-линий [from-sip-phone] ; SIP-линии звонят друг другу exten =\u0026gt; _6XXX,1,Dial(SIP/${EXTEN}) ; исходящие вызовы на номера оператора KYIVSTAR exten =\u0026gt; _06[7,8]XXXXXXX,1,Dial(Dongle/KYIVSTAR/${EXTEN}) exten =\u0026gt; _09[6-8]XXXXXXX,1,Dial(Dongle/KYIVSTAR/${EXTEN}) exten =\u0026gt; _039XXXXXXX,1,Dial(Dongle/KYIVSTAR/${EXTEN}) ; все остальные исходящие вызовы без разбора отправляем через GSM линию LIFE exten =\u0026gt; _X.,1,Dial(Dongle/LIFE/${EXTEN}) ; этот контекст принимает и обрабатывает вызовы с GSM-линий [from-gsm] ; простая реализация без очередей - будут звонить обе SIP-линии exten =\u0026gt; s,1,Dial(SIP/6000\u0026amp;SIP/6001) Вот и все. Пробуйте позвонить.\nУспехов!\n"},{"id":15,"href":"/post/apache24php7win10/","title":"Apache 2.4 + PHP 7 на Windows 7­, 10","section":"Posts","content":" Apache 2.4 + PHP 7 на Windows 7­, 10 # Внимание! Данная инструкция служит дополнением к инструкции по установке Apache 2.4VC11 и PHP 5.6 и описывает лишь отличительные моменты, которые касаются установки Apache24 и PHP7 на Windows. Описание установки СУБД MySQL остается прежним и не повторяется в этой инструкции.\nДанная инструкция рассчитана на разработчиков с базовыми знаниями Apache и PHP. В данной инструкции будут описана только разница в установке Apache и PHP с основной инструкцией по установке PHP 5.6. Если Вы не в курсе, что такое WEB-сервер, http-протокол и интерпретатор PHP, то Вы всегда можете узнать об этом более подробно, прочитав документацию.\nЯ не буду отвечать в комментариях на вопросы, ответ на которые есть в этой или основной инструкциях, ссылка на основную инструкцию указана в первом абзаце, а так же на вопросы, которые касаются понимания работы Apache и PHP и уж тем более на вопросы по ошибкам в разработке. Для этого существуют соответствующие ресурсы, литература, форумы, курсы. Однако, Вы всегда можете задать любой интересующий Вас вопрос. Возможно, кто-то из сообщества сможет Вам помочь.\nУстановка Apache 2.4 VC14 # Загружаем Apache 2.4 binaries VC14 под свою систему по ссылке http://www.apachelounge.com/download/ Качаем 64 разрядную версию сервера. На момент написания этих строк файл назывался так: httpd-2.4.17-win64-VC14.zip Если нужны какие-то дополнительные модули, их можно загрузить там же (для базовой установки нет необходимости) Загружаем и устанавливаем обновления Visual C++ Redistributable for Visual Studio 2015 с сайта Microsoft Разархивируем содержимое папки Apache24 из скаченного архива в D:\\USR\\apache. Обратите внимание, что в D:\\USR\\apache нужно положить не папку Apache24 из архива, а ее содержимое. Инсталлировать ничего не требуется В файле D:\\USR\\apache\\conf\\httpd.conf изменяем значение ServerRoot на \u0026ldquo;d:/USR/apache\u0026rdquo; (строка 37) и значение DocumentRoot (и Directory) на \u0026ldquo;d:/USR/www\u0026rdquo; (строки 243 и 244). Так же следует раскомментировать строку 219 и изменить ее на: ServerName localhost:80 Изменяем параметры хранения логов в том же файле (находим параметры и изменяем): ErrorLog \u0026#34;D:/USR/log/apache-error.log\u0026#34; CustomLog \u0026#34;D:/USR/log/apache-access.log\u0026#34; common Устанавливаем сервис Apache. Открываем командную строку от имени Администратора и вставляем туда следующую строку: D:\\USR\\apache\\bin\\httpd.exe -k install Следим за сообщениями об ошибках во время установки сервиса. Если все сделано верно, никаких ошибок быть не должно. Если у вас после выполнения строки не появилась снова командная строка, то вы что-то сделали неправильно. Просто воспользуйтесь функциями скопировать и вставить, чтобы не допускать ошибок при перепечатке Создаем на рабочем столе ярлык для D:\\USR\\apache\\bin\\ApacheMonitor.exe и/или помещаем его в автозагрузку (для открытия окна автозагрузки в WIN8..10 необходимо нажать WIN+R, затем ввести shell:Startup и нажать ОК) Запускаем «ApacheMonitor». В системном трее появится ярлык. Нажимаем на него левой кнопкой, выбираем Apache24 -\u0026gt; Start В браузере заходим на http://localhost/ - должны увидеть It works! Если не увидели такой надписи, разбираемся, что пошло не так (читаем логи, гуглим, пытаемся самостоятельно разобраться с проблемой, раз уж решили разбираться в тонкостях работы веб-сервера) Установка PHP 7 # Загружаем последнюю версию VC14 x64 Thread Safe по ссылке http://windows.php.net/download/. Обратите внимание, что нужен именно VC14 и именно Thread Safe. Файл, который Вам нужен, скорее всего будет называться наподобие: php-7.0.0-Win32-VC14-x64.zip Извлекаем содержимое архива в D:\\USR\\php. Как в случае с Apache, инсталлировать ничего не требуется В файл D:\\USR\\apache\\conf\\httpd.conf добавляем строки: LoadModule php7_module \u0026#34;d:/USR/php/php7apache2_4.dll\u0026#34; AddHandler application/x-httpd-php .php # Путь к файлу php.ini PHPIniDir \u0026#34;D:/USR/php\u0026#34; И изменяем значение параметра DirectoryIndex на index.html index.php (строка 278) Используя «ApacheMonitor» перезапускаем Apache (Apache24 -\u0026gt; Restart) Заходим браузером http://localhost/index.php и убеждаемся, что PHP работает (обратитесь к первоначальной статье, чтобы узнать, откуда берется файл index.php) — в браузере будет вывод PhpInfo Делаем копию шаблона конфигурационного файла D:\\USR\\php\\php.ini-development с именем D:\\USR\\php\\php.ini - это конфигурационный файл для РНР. Редактируем конфигурационный файл D:\\USR\\php\\php.ini. Пользуясь поиском находим внутри файла, раскомментируем и изменяем параметры. Обратите внимание, что параметр extension определяет набор расширений РНР. Раскомментируйте те расширения, которые нужны Вам. В примере расширения, которые были нужны мне. Временную зону указывайте свою, а не мою: extension_dir = \u0026#34;D:/USR/php/ext\u0026#34; sys_temp_dir = \u0026#34;D:/USR/tmp\u0026#34; extension=php_curl.dll extension=php_gd2.dll extension=php_gettext.dll extension=php_mbstring.dll extension=php_mysqli.dll extension=php_openssl.dll date.timezone = Europe/Zaporozhye Если у Вас возникли проблемы с запуском curl, обратитесь к этой инструкции. Выполняем в командной строке php -m чтобы просмотреть список подключенных расширений. Перезапускаем Apache используя «ApacheMonitor» Установка и настройка всего остального не изменилась. Обратитесь пожалуйста к статье по установке PHP 5.6 для получения подробной информации.\n"},{"id":16,"href":"/post/simply-install-freebsd/","title":"Как установить FreeBSD с флешки","section":"Posts","content":" Как установить FreeBSD с флешки # Подобных статей интернет насчитывает тысячи, еще столько же видеоуроков на YouTube. Все они простые и понятные. Цель написания еще одной статьи простая: дать информацию для моих коллег и клиентов в той форме, в которой они привыкли. Статья совершенно не претендует на уникальность. Скорее всего, Вы ничего не найдете в ней нового. Но есть огромная масса людей, которым до сих пор действительно сложно справиться с установкой системы.\nЕсли Вы хотите установить FreeBSD вручную или на Flash накопитель, то обратитесь к вот этой моей статье. В этой статье будет описана простейшая установка системы в три шага без заморочек.\nПочему FreeBSD # Я не являюсь сторонником холиваров на тему что лучше. Я привык использовать инструменты по их необходимости. Где-то лучше использовать одно, где-то другое. FreeBSD имеет очень простую и быструю установку. Установить FreeBSD можно за 3 минуты и это не шутка. Если нужно поднять простой сервер для элементарных целей, то именно эта система, на мой взгляд, подходит больше всего. В FreeBSD все настолько просто, что вступление к данной статье занимает бОльшую ее часть. Сейчас Вы убедитесь в этом.\nПодготовительные работы # Нам понадобиться сервер (любой исправный компьютер) и USB-стик (флешка).\nВключите свой новый сервер, войтите в BIOS и установите время UTC (GMT 0) - т.е. по Гринвичу, а так же загрузку с USB.\nСкачайте установочный образ. Перейдите на сайт FreeBSD, вероятнее всего ваш сервер имеет 64-разрядную платформу, поэтому выберите в Installer images вариант amd64 в последней версии (на момент написания 10.2). В открывшемся списке файлов выберите ...RELEASE-amd64-memstick.img — это образ для флешки.\nЕсли Вы сейчас все это делаете под Windows, то скачайте и установите утилиту Win32DiskImager для записи образов img на флешку.\nЗапустите утилиту и запишите выбранный образ на флешку: (1 - укажите имя образа, 2 - выберите букву диска USB-флешки, 3 - нажите write) После чего подключайте флешку к вашему новому серверу и перезагружайтесь.\nУстановка # Если автоматическая загрузка с флешки не произошла, то перезагрузите сервер и во время появления POST сообщений BIOS нажмите клавишу, которая вызовет Boot menu (обычно F2 или F12).\nУстановка системы настолько простая, что если Вы ставите систему в первый раз, то Вам почти всегда подойдут варианты, выбранные по умолчанию. За очень редким исключением.\nЕсли все в порядке, то Вы должны увидеть следующий экран: Нажмите Enter, если не хотите ждать. Произойдет дальнейшая загрузка, после которой появится следующее окно: Выбирайте Install (выбрано по умолчанию) и нажимайте Enter. На следующем экране нужно выбрать раскладку. Ничего не выбирайте, оставляйте default (по умолчанию) и жмите Enter Далее укажите имя хоста. Если у вас есть доменное имя, то укажите имя вместе с ним, нажмите Enter. В любом случае впишите хоть что-то. Например test подойдет.\nДалее необходимо выбрать опциональные компоненты системы. Они нам не понадобятся. Выключайте все (включать и выключать клавишей пробел) и жмите Enter. Далее разбивка жесткого диска. Не мудрите, если не знаете зачем это вам. Выбирайте Auto (UFS) (выбрано по умолчанию) и жмите Enter.\nДалее нужно указать, будете использовать весь диск или какой-то раздел. Скорее всего Вы не будете использовать несоклько ОС на этом сервере, поэтому выбирайте Entire Disk (выбрано по умолчанию) и жмите Enter.\nВ следующем окне нужно выбрать схему партицирования. По умолчанию выбрана GPT - она нам подходит больше всего. Жмите Enter.\nВ следующем окне Вы можете исправить объемы партиций (разделов), но это вряд ли вам нужно, если вы находитесь на таком уровне, что устанавливаете систему по этой инструкции. Поэтому выбирайте Finish (выбрано по умолчанию) и жмете Enter. Система запросит подтверждение действий. Ведь после этих действий разметка диска будет изменена! По умолчанию выбрано Commit (подтвердить). Отлично. Нажимайте Enter.\nПосле этого запускается процесс разбивки диска и разархивирования двух архивов: base и kernel. Длится это достаточно быстро (если флешка быстрая и жесткий диск не совсем древний).\nВот и все. Система установлена.\nОбратите внимание, что сложности никакой нет. Вы везде нажимали Enter. В следующий раз можете спокойно доверить установку FreeBSD на сервер своей девушке.\nБазовая настройка # Сразу после установки необходимо провести базовую настройку системы. Установщик сам проведет Вас по всем пунктам этого процесса.\nСначала задайте пароль рута (самого главного пользователя системы). Пароль не теряйте. Нацарапайте гвоздём на системном блоке сервера.\nСеть # Затем настройте сеть. Выберите из списка сетевой адаптер, на котором будете производить настройки. Если он один, просто нажмите Enter. Затем отвечаем на вопросы:\nWould you like to configure IPv4... - хотим ли мы настроить протокол IPv4 на нашей системе. Конечно Yes! Would you like to use DHCP... - если сервер подключен к сети, в которой есть DHCP-сервер, отвечайте Yes, иначе No, чтобы настроить IP вручную. Если вы выбрали No, то в следующем окне укажите IP адрес, маску, шлюз, нажмите ОК Would you like to configure IPv6... - хотим ли мы настроить протокол IPv6. Скорее всего нет. Выбираем No и жмем Enter Resolver configuration - укажите адреса DNS-серверов и нажмите Enter Настройка даты/времени # В следующем окне Выбирайте Yes, если вы в самом начале в BIOS установили время UTC, а не локальное. Если в BIOS установлено локальное время, нажимайте No.\nВыбирайте временную зону. Сначала регион (Европа), а затем город, ближайший к Вам.\nДемоны # Далее необходимо выбрать службы (демоны), которые будут стартовать вместе с системой. Скорее всего Вам не нужно ничего менять, просто нажмите Enter.\nСоздать пользователя # Далее будет предложено создать пользователя. Рекомендуется это сделать, так как по умолчанию главному пользователю (root) запрещен удаленный вход по протоколу SSH (это, конечно, можно отключить, но не нужно). Нажимайте Yes.\nДалее в диалоговом режиме укажите данные:\nUsername: myloginname Full name: My Full Name Uid (Leave empty for default): Login group [myloginname]: Login group is myloginname. Invite myloginname into other groups? []: wheel Login class [default]: Shell (sh csh tcsh zsh nologin) [sh]: Home directory [/home/myloginname]: Home directory permissions (Leave empty for default): Use password-based authentication? [yes]: Use an empty password? (yes/no) [no]: Use a random password? (yes/no) [no]: Enter password: укажите пароль Enter password again: укажите пароль повторно Lock out the account after creation? [no]: Username : myloginname Password : **** Full Name : My Full Name Uid : 1001 Class : Groups : myloginname wheel Home : /home/myloginname Shell : /usr/local/bin/sh Locked : no OK? (yes/no): yes adduser: INFO: Successfully added (myloginname) to the user database. Add another user? (yes/no): no Вместо myloginname и My Full Name укажите свой логин и полное имя. Не забудьте включить пользователя в группу wheel, чтобы он мог выполнять команду su.\nНа этом всё # В последнем окне можно изменить какие-то настройки, если в процессе диалоговой конфигурации Вы что-то сделали не так. Если все ок, Выбирайте Exit (выбрано по умолчанию) и жмите Enter.\nЗатем система предложит запустить оболочку, чтобы вы могли сделать финальные модификации. Но Вам это точно не нужно. Жмите No.\nИ последний вопрос: перезапустить или загрузить LiveCD. Конечно же перезапустить! Выбирайте Reboot.\nПоздравления!\n"},{"id":17,"href":"/post/resize-gpt-psrtition-freebsd/","title":"Изменить размер раздела GPT FreeBSD vmWare","section":"Posts","content":" Изменить размер раздела GPT FreeBSD vmWare # При эксплуатации серверов под управлением FreeBSD в виртуальной среде vmWare, иногда возникает необходимость увеличения объема раздела жесткого диска. Следующие инструкции помогут сделать это легко и быстро.\nИзменяем размер диска в vSphere Client, затем перезагружаем виртуальную машину. (В данном примере общий объем диска был 6 Гб, я увеличил его до 8 Гб. Основной раздел UFS нужно было увеличить с 4 до 6 Гб) Проверяем, что появилось свободное место gpart show da0 Результат: =\u0026gt; 34 12582845 da0 GPT (8.0G) [CORRUPT] 34 256 1 freebsd-boot (128K) 290 4194304 2 freebsd-swap (2.0G) 4194594 8388284 3 freebsd-ufs (4.0G) 12582878 1 - free - (512B) Если вместо свободного места Вы обнаруживаете, что разметка повреждена [CORRUPT], не расстраивайтесь. Починить разметку, если необходимо, можно следующей командой: gpart recover da0 Результат: da0 recovered Теперь с разметкой все в порядке. Можно еще раз посмотреть таблицу разделов. gpart show da0 Результат: =\u0026gt; 34 16777149 da0 GPT (8.0G) 34 256 1 freebsd-boot (128K) 290 4194304 2 freebsd-swap (2.0G) 4194594 8388284 3 freebsd-ufs (4.0G) 12582878 4194305 - free - (2.0G) Вот сейчас видно, что добавилось 2 Гб свободного места. Отлично. Чтобы изменить размер раздела № 3 до конца свободного места, выполняем следующую команду: gpart resize -i 3 da0 Результат: da0p3 resized И теперь посмотрим, что получилось: gpart show da0 Результат: =\u0026gt; 34 16777149 da0 GPT (8.0G) 34 256 1 freebsd-boot (128K) 290 4194304 2 freebsd-swap (2.0G) 4194594 12582589 3 freebsd-ufs (6.0G) Теперь третий раздел имеет 6 Гб. Последний штрих — изменение размера файловой системы на данном разделе. Выполняется простой командой: growfs /dev/da0p3 Результат: Device is mounted read-write; resizing will result in temporary write suspension for /. It\u0026#39;s strongly recommended to make a backup before growing the file system. OK to grow filesystem on /dev/da0p3, mounted on /, from 4.0GB to 6.0GB? [Yes/No] Yes super-block backups (for fsck_ffs -b #) at: 8975872, 10258112, 11540352 Если последняя команда завершилось с ошибкой «Operation not permitted», то вместо устройства (/dev/da0p3) укажите каталог в файловой системе, в который это устройство примонтировано, например: growfs / (Спасибо Петру, подсказавшему это в комментариях).\nВот так все просто. Удачи!\n"},{"id":18,"href":"/post/material-design-product-icon-ai/","title":"Как создать иконку приложения в стиле Material Design. Наиболее правильная инструкция","section":"Posts","content":" Как создать иконку приложения в стиле Material Design. Наиболее правильная инструкция # Если Вы задаетесь вопросом, как создать иконку приложения в стиле Material, то Вы попали по адресу!\nДанная инструкция является максимально верным руководством по созданию иконки приложения Android в стиле Material Design, собранное из различных источников, которые мне удалось найти в сети.\nИконка приложения создается в графическом редакторе Adobe Illustrator CC. Инструкция изложена достаточно кратко. Если знаний редактора не достаточно для повторения, обратитесь к видеозаписи из материалов, приведенных ниже (п.3)\nДля написания инструкции использовались следующие материалы # Google Material Design Guidelines: https://www.google.com/design/spec/style/icons.html What Google missed in their guidelines for Material Design iconography: https://goo.gl/5SpsVn How To Create A Material Design Icon In Adobe Illustrator: https://youtu.be/GzXq6ouGTpE Исходные файлы # Вам необходимо скачать несколько файлов, которые помогут в разработке:\nПалитра цветов Material Design: https://goo.gl/EVxUSx — скопируйте файл Material Palette.ase из архива в каталог с палитрами Adobe Illustrator (C:\\Program Files\\Adobe\\Adobe Illustrator CC 2015\\Presets\\en_US\\Swatches) Шрифты: https://goo.gl/GQbKob — установите шрифты в систему, а так же скопируйте файлы шрифтов в папки C:\\Program Files\\Common Files\\Adobe\\Fonts и C:\\Program Files (x86)\\Common Files\\Adobe\\Fonts Сетка для удобной работы с иконками (Product Icon Sticker Sheet): https://goo.gl/CYE2jV — содержит 4 шаблона иконок приложения Подготовка к действию # Скопируйте файл палитры цветов в библиотеку Adobe Illustrator, затем выберите появившуюся палитру из списка Swatch Libraries в панели Swatches. Установите шрифты и проверьте их доступность в Adobe Illustrator. Если шрифт Roboto Regular недоступен, скопируйте файлы шрифтов в каталоги, указанные выше в исходных файлах. Разархивируйте файлы с сетками и откройте их в Adobe Illustrator. Выберите тот, который Вам подходит больше, остальные закройте. В этих шаблонах уже организованы правильные тени и блики — их значения можно брать за основу. Приступаем.\nСоздание иконки в стиле Material # В данной инструкции будем создавать простейшую иконку одной из описанных в руководстве геометрических форм. Шаблон иконок имеет размер 192×192 pt, что очень удобно для манипулирования значениями размеров. Геометрические размеры самой иконки, в зависимости от ее вида, следующие:\nквадратная иконка: 152×152 pt прямоугольная: 176×128 pt круглая: ⌀ 176 pt Закругление углов квадратной и прямоугольной иконки: 12 pt\nРассмотрим на примере создание квадратной иконки # Создаем новый слой для нашей иконки, называем его «Моя иконка» и создадим фоновое изображение на нем Выбираем инструмент Rectangle Tool (M) и выполняем щелчок на рабочей области. В появившемся окне вводим размеры: ширина 152 и высота 152. Жмем ОК На верхней панели нажимаем Transform и указываем координаты X и Y 96 pt Там же на верхней панели в поле Corner Radius вводим значение 12 pt Указываем цвет заливки, выбрав его из основных цветов палитры Material (например Indigo 500 — Primary) и отключаем цвет обводки Переименуем данную фигуру в «Фон» на палитре слоев (не слой, а фигуру) После всех проделанных манипуляций Вы должны увидеть примерно следующее: Следующее действие — создание зоны блика и тени фона # В слоях выделите фигуру с фоном (переключателем справа) и выполните операцию копирования (Ctrl+C) и дважды вставки вперед (Ctrl+F). В итоге должно получиться три одинаковых фигуры. С новыми двумя фигурами будем работать дальше Переключитесь на среднюю в списке фигуру «Фон» (переключателем справа) и выполните смещение объекта вниз на 1 dp (одиночным нажатием стрелки вниз на клавиатуре) Теперь выделите правым переключателем обе только что созданные фигуры (верхнюю и среднюю) и выполните операцию обрезки «Minus Back» — в итоге должна получиться новая фигура в виде узкой полоски вверху основной фигуры — это так называемый блик. Переименуйте фигуру в «Блик» Установите для получившейся фигуры блика заливку белым цветом с непрозрачностью 20% В слоях снова выделите фигуру с фоном и выполните операцию копирования (Ctrl+C) и дважды вставки назад (Ctrl+B). В итоге получится еще две фигуры с фоном ниже текущей фигуры Переключитесь на среднюю в списке фигуру «Фон» (переключателем справа) и выполните смещение объекта вверх на 1 dp (одиночным нажатием стрелки вверх на клавиатуре) Теперь выделите правым переключателем две фигуры «Фон» (верхнюю и среднюю) и выполните операцию обрезки «Minus Back» — в итоге должна получиться новая фигура в виде узкой полоски внизу основной фигуры — это так называемая тень. Переименуйте фигуру в «Тень» Установите для получившейся фигуры тени заливку цветом, в зависимости от цвета фона с непрозрачностью 20%. Узнать этот цвет можно из таблицы «Tint, shade, and shadow values» по ссылке: https://goo.gl/8Vkg33 В нашем случае для фона Indigo тень должна быть цвета Indigo 900 В итоге должно получиться три фигуры в данной очередности: «Блик», «Тень» и «Фон» На этом работа с фоном завершена\nСоздание знака иконки # Для простоты описания процесса разместим на фоне символ алфавита «В»\nСоздайте надпись, содержащую одну букву размером примерно 150 pt и цвета Grey 100 Переведите текст в кривые (меню: Type — Create Outlines) Отцентруйте символ относительно фона (либо наоборот, сдвиньте по вкусу). Напомню, что центр имеет координаты 96×96 pt, если Вы пользуетесь цифрами Переименуйте фигуру в списке слоев на «Символ» Создание длинной тени для знака # В слоях выделите фигуру с символом (переключателем справа) и выполните операцию копирования (Ctrl+C) и дважды вставки вперед (Ctrl+F). В итоге должно получиться три одинаковых фигуры «Символ». С новыми двумя фигурами будем работать дальше Переключитесь на верхнюю фигуру «Символ», и удерживая клавишу Shift вынесите фигуру за пределы холста под 45° вправо и вниз — это заготовка для формирования длинной тени В итоге средняя и нижняя фигура в списке слоев должны быть расположены по центру фона, а верхняя должна быть за пределами холста справа снизу. Нижнюю фигуру пока не трогаем Теперь выделите правым переключателем две фигуры «Символ» — верхнюю и среднюю, зайдите в меню Object — Blend — Blend Options, включите режим Specified Steps, укажите 200 шагов и нажмите ОК, затем выполните команду меню Object — Blend — Make. На базе двух фигур будет создана одна в виде перетекания между двумя старыми Не снимая выделения с получившейся фигуры, выполните действие в меню Object — Expand… и нажмите ОК — произойдет разбиение перетекания на отдельные полигоны Выполните объединение полигонов (Unite) Переименуйте получившуюся фигуру \u0026lt;Path\u0026gt; с будущей тенью в «Длинная тень» Теперь создадим маску. Скопируйте фоновую фигуру «Фон» (Ctrl+C) и произведите вставку Past in Place (Shift+Ctrl+V). В результате фигура с фоном будет вставлена поверх всех фигур в слое Выделите правым переключателем только что вставленный «Фон», который в самом верху, и фигуру «Длинная тень» и выполните обрезку Crop. В результате получим группу фигур \u0026lt;Group\u0026gt;, содержащую несколько фигур \u0026lt;Path\u0026gt; Удалите все фигуры \u0026lt;Path\u0026gt;, за исключением самой тени — она полностью белая и, скорее всего, расположена выше остальных \u0026lt;Path\u0026gt;. На скриншоте указана фигура, которую следует удалить из группы Переименуйте \u0026lt;Group\u0026gt; в «Длинная тень» и расположите его под фигурой «Символ» Переключитесь на фигуру «Длинная тень», затем на панели Gradient выберите тип Linear, угол −45°, начальный и конечный цвет такой же, какой выбирали для тени фона — в нашем случае это Indigo 900 (Ваш цвет выбирайте из таблицы «Tint, shade, and shadow values» по ссылке: https://goo.gl/8Vkg33), непрозрачность левой части 20%, непрозрачность левой правой части 0% и положение средней точки 33% Теперь необходимо почистить фигуру тени от «ступенек», которые образовались во время Blanding (перетекания фигур). Сделайте активным фигуру «Длинная тень» и увеличьте изображение достаточно сильно, чтобы оценить край фигуры Выберите инструмент Lasso Tool и выделите точки таким образом, чтобы не задеть крайние, как показано ниже Удалите лишние точки при помощи инструмента Remove selected anchor points Создание зоны блика и тени знака # Переключитесь на фигуру «Символ» скопируйте (Ctrl+C) и дважды вставьте наперед (Ctrl+F) две новые фигуры Выберите среднюю фигуру «Символ» и сдвиньте вниз на 1 pt (один раз нажать стрелку вниз на клавиатуре) Теперь выделите правым переключателем обе только что созданные фигуры (верхнюю и среднюю) и выполните операцию обрезки «Minus Back» — в итоге должна получиться новая фигура \u0026lt;Group\u0026gt; в виде узкой полоски вверху основной фигуры — это так называемый блик. Переименуйте фигуру в «Блик символа» Установите для получившейся фигуры блика заливку белым цветом с непрозрачностью 20% Переключитесь на фигуру «Символ» и примените эффект Stylize — Drop Shadow с параметрами: режим Normal, непрозрачность 20%, смещение по X и по Y 4 dp, размытие 4 dp, цвет тени из таблицы «Tint, shade, and shadow values» по ссылке: https://goo.gl/8Vkg33 На панели Appearance к текущей фигуре «Символ» примените функцию «Add new Fill», чтобы получить возможность добавления еще одной тени, если символ изменил цвет заливки, укажите снова значение цвета заливки Fill: Grey 100 Затем примените к фигуре «Символ» еще один эффект тени Stylize — Drop Shadow с параметрами: режим Normal, непрозрачность 20%, смещение X 0 pt, смещение Y 1 pt, размытие 0 pt, цвет как и в предыдущий раз (из таблицы теней) Создание светового блика для всей иконки # Скопируйте фигуру фона «Фон», создайте новый слой и вставьте фигуру фона на него. Отключите заливку фигуры. Переименуйте слой в «Освещение» Создайте для фигуры на новом слое градиентную заливку с параметрами: тип Radial, цвет начала и конца градиента — белый, непрозрачность начала градиента 10%, конца градиента 0%, положение средней точки 33% При помощи инструмента Gradient Tool (G) создайте градиент от верхнего левого угла фона к нижнему правому, после чего измените угол градиента в настройках на −45° Создание общей тени для всей иконки # Примените эффект тени Stylize — Drop Shadow к заливке (Fill) фигуры «Фон» слоя с иконкой «Моя иконка» со следующими параметрами: режим Multiply, непрозрачность 12%, смещение по X и Y 0 pt, размытие 2 pt, цвет тени черный (здесь всегда черный) На панели Appearance к текущей фигуре «Фон» примените функцию «Add new Fill», чтобы добавить еще одну заливку для добавления на нее еще одной тени Примените эффект тени Stylize — Drop Shadow к только созданной заливке с параметрами: режим Multiply, непрозрачность 24%, смещение по X 0 pt, смещение по Y 4 pt, размытие 2 pt, цвет тени черный (здесь всегда черный) Итоговое изображение иконки выглядит так # Сохранение иконки # Отключите все вспомогательные слои. Должны остаться включенными только два слоя «Моя иконка» и «Освещение» Выполните сохранение 5 вариантов иконки, используя функцию File — Save For Web и формат PNG-24 с прозрачностью. Убедитесь также, что включена опция Clip to Artboard Имя файла сохраняемых иконок должно быть ic_launcher.png 6 копий сохраняются в 5 разных каталогов. В каждый каталог свой размер изображения. Далее приведены имена каталогов и размер изображений файла ic_launcher.png, которые должны находиться в этих каталогах: mipmap-mdpi = 48×48 px mipmap-hdpi = 72×72 px mipmap-xhdpi = 96×96 px mipmap-xxhdpi = 144×144 px mipmap-xxxhdpi = 192×192 px Готово!\n"},{"id":19,"href":"/post/asterisk-example-1-call-between-two-sip-line/","title":"Asterisk. Пример 1 — вызов между двумя линиями SIP","section":"Posts","content":" Asterisk. Пример 1 — вызов между двумя линиями SIP # Первое, что хочется сделать сразу после установки системы, это совершить первый телефонный звонок, чтобы убедиться, что система действительно работает и ощутить то самое чувство, когда получилось!\nВ данной статье я постараюсь рассказать про основы работы Asterisk, каким образом вызов продвигается по системе, как настраиваются подсистемы и как они взаимодействуют между собой.\nЕсли Вам не нужно погружаться в технические основы работы системы, если Вы не планируете глубоко изучать принципы работы, способы конфигурирования, если перед Вами стоит цель: настроить быстро, чтобы работало, и забыть, то я порекомендую Вам замечательные оболочки и сборки для удобной, простой и понятной настройки системы, такие как FreePBX, Elastix и т.п.\nDisclamer # Автор предупреждает читателей, о тонкой грани между допустимым использованием телефонных систем подобного рода и уголовной ответственностью, которая может наступить при неправильной маршрутизации телефонного трафика (рефайлинга). Пожалуйста, ознакомьтесь с законодательством Вашей страны, чтобы избежать проблем. Автор снимает с себя ответственность за любые действия читателя, в которых ему может помочь материал данной статьи и возлагает ее целиком и полностью на читателя данной статьи. Информация, приведенная в данной статье, является справочной и не носит практического характера.\nАрхитектура Asterisk # Для начала нужно понять следующее: Система Asterisk строится из ядра и множества различных подсистем. Подсистемы делятся на 4 основные группы:\nПодсистема интерфейса каналов — в эту группу входят различные подсистемы для взаимодействия с источниками телефонного трафика и телефонных сигнализаций (SIP, IAX, PRI, Dongle и т.д.) Подсистема интерфейса приложений — в эту группу входят подсистемы, которые выполняют различные функции, такие как: конференцсвязь, голосовая почта, очередь вызовов, взаимодействие с jabber и т.д. Подсистема интерфейса кодеков — в эту группу входят транскодеры, которые выполняют функции перекодирования голосового потока из одной системы кодирования в другую (A-law, μ-law, GSM, G723, G729 и.д.) Подсистема файлов — подсистема управляет чтением и записью различных форматов файлов. Ядро выполняет следующие функции:\nКоммутация между подсистемами взаимодействия с источниками телефонного трафика. Запуск внешних приложений (например для голосовой почты) Преобразователь кодеков (автоматически выбирает подсистемы транскодеров) Планировщик задач внутри системы В данной статье будет рассмотрен простой пример коммутации между подсистемами интерфейса каналов.\nПодсистема интерфейса каналов # Важно понять следующее. Каждая такая подсистема может иметь множество каналов. Например подсистема SIP может иметь множество телефонных номеров, а подсистема Dongle может иметь множество GSM-модемов. Каждый телефонный номер или каждый модем в системе Asterisk является каналом и в пределах Asterisk называется пиром (peer). В конфигурационных файлах все параметры каждого пира заключаются в блок, которому присваивается имя. Это имя и есть имя пира (или имя канала). Имя пира может быть использовано для маршрутизации вызова. Еще одним важным понятием является context — правила обработки вызовов (extensions) группируются в контексты, имена которых указываются в пирах как обработчики входящих вызовов. Вызовы, поступающие от нескольких пиров, могут обрабатываться одним и тем же контекстом. Например, группа абонентов, которые имеют доступ к звонкам на межгород имеет один контекст, а все остальные имеют другой контекст.\nВ каждом конфигурационном файле есть блоки базовых настроек. Это либо блок [general], где указываются базовые настройки подсисиемы, либо блок [defaults], где указываются базовые настройки пиров. Если у всех пиров какой-то один параметр одинаковый, например тип или контекст, то можно просто вынести его в блок [defaults] и не дублировать каждый раз в каждом пире. Есть и другие способы группировки пиров, но о них в следующий раз.\nНебольшой пример для подсистемы SIP (часть файла sip.conf без блока базовых настроек):\n[5000] type = friend username = 5000 secret = 1234 context = from-sip-lines [5001] type = friend username = 5001 secret = 1234 context = from-sip-lines В данном примере описаны два пира с номерами (extensions) 5000 и 5001. Тип обоих пиров — friend, что означает то, что данные пиры могут как принимать вызовы, так и совершать. Имя пользователя для подключения по протоколу SIP у этих пиров совпадает с их телефонными номерами — самый простой способ, чтобы не запутаться, однако можно назначать любое имя пользователя для пиров. Пароль у обоих пиров в данном примере: 1234. Последний параметр — контекст. Контекст, который будет обрабатывать входящие вызовы, у обоих пиров одинаковый from-sip-lines.\nТеперь, когда мы будем конфигурировать правила обработки вызовов в файле extensions.conf, мы учтем следующее: Сконфигурирем набор правил маршрутизации для обработки входящих вызовов (контекст) from-sip-lines, а направлять вызовы будем в сторону подсистемы SIP к пирам 5000 и 5001.\nПример организации маршрутизации вызовов внутри SIP # Теперь на основании полученных знаний, постараемся скоммутировать вызовы от абонента 5000 к абоненту 5001 и наоборот. В следующем примере будет указаны явные правила, хотя на самом деле так никто не делает, а использует маски и переменные. Но для начала, чтобы понимать как работают правила маршрутизации, это будет только сбивать с толку.\nИтак дано: подсистема SIP. Пиры 5000 и 5001. Контекст обоих пиров from-sip-lines.\nЦель: в контексте from-sip-lines обработать принимаемые вызовы, если получен адрес (extension) 5000, то направить вызов на подсистему SIP к пиру 5000, если получен адрес (extension) 5001, то направить вызов на ту же подсистему SIP, но к пиру 5001. Приступим к написанию данных правил (фрагмент файла extensions.conf без блока базовых настроек):\n[from-sip-lines] exten =\u0026gt; 5000,1,Dial(SIP/5000) exten =\u0026gt; 5000,n,Hangup() exten =\u0026gt; 5001,1,Dial(SIP/5001) exten =\u0026gt; 5001,n,Hangup() Повторюсь еще раз: данный пример не является хорошим, так как он не универсален: придется добавлять по две строчки для каждого нового телефонного номера. Данный пример специально написан таким образом, чтобы наглядно понимать принцип работы правил маршрутизации.\nПервая строка — название группы правил (название контекста). Это название указывается в конфигурации пиров как значение параметра context. Все вызовы, поступающие со стороны пиров будут обработаны правилами, входящими в указанный контекст.\nДалее идут правила. Все правила начинаются с exten =\u0026gt;, после чего идет адрес (экстеншн), который будет проверяться на совпадение с адресом поступившего вызова. Если вы на SIP-телефоне наберете цифры 5001 и нажмете вызов, то этот вызов поступит в подсистему маршрутизации с адресом 5001. Подсистема будет производить поиск правил, которым максимально соответствует поступивший адрес. Следующее поле - это номер по порядку правил. В новых версиях Asterisk нужно нумеровать только первое правило, а в остальных можно поставить просто n и система пронумерует их автоматически в порядке написания в конфигурации. Третий параметр — действие. В нашем случае произойдет следующее: как только будет найдено первое подходящее правило для вызова, то будет выполнено действие, которое соответствует данному правилу, затем после окончания выполнения действия поиск будет продолжен и будет выполнено действие в следующем найденном правиле с таким же exten, причем порядковый номер такого правила должен быть на единицу больше предыдущего.\nПредположим, что абонент с номером 5000 вызывает абонента с номером 5001. Последовательность действий в нашей задаче будет следующая: в подсистему маршрутизации вызова поступает вызов от подсистемы SIP. Данный вызов характеризуется адресом (экстеншеном) 5001 и должен быть обработан контекстом from-sip-lines. Подсистема маршрутизации первым делом должна найти блок правил (контекст) from-sip-lines. Затем подсистема маршрутизации будет производить поиск наиболее точно подходящего правила из данного контекста, анализируя адрес (5001) и сравнивая его с фильтрами каждого из правил с порядковым номером 1. Наиболее удовлетворяющее правило (в нашем случае единственное) будет:\nexten =\u0026gt; 5001,1,Dial(SIP/5001) После чего будет выполнено действие — Dial, т.е. вызов. В качестве параметра для действия Dial указано SIP/5001 — это означает, что вызов необходимо направить подсистеме SIP пиру 5001. При выполнении данного действия происходит создание канала (channel), к которому подключается подсистема. Производится посылка вызова в сторону вызываемого абонента, затем коммутация, затем отбой. Или просто посылка вызова и отбой по таймауту, если трубку никто не поднял. После чего действие данного правила заканчивается.\nПосле окончания действия правила, подсистема маршрутизации продолжает выполнение правил. На этот раз будет произведен поиск правила с порядковым номером 2, максимально удовлетворяющее адресу 5001. Таким правилом будет следующее за первым:\nexten =\u0026gt; 5001,n,Hangup() В конфигурационном файле вместо порядковых номеров можно указать просто n и подсистема маршрутизации автоматически пронумерует эти правила. На самом деле, после загрузки правил в подсистему маршрутизации, вместо символов n уже стоят порядковые номера, так что это правило внутри системы выглядит вот так:\nexten =\u0026gt; 5001,2,Hangup() Действием этого правила является — Hangup, т.е. отбой. Эта команда безусловно завершает вызов.\nПосле выполнения этого правила будет произведен поиск следующего правила с порядковым номером 3. Так как такого правила нет, дальнейшая обработка вызова не производится. Вызов считается завершенным.\nИспользование масок (шаблонов) для фильтров экстеншенов # На самом деле крайне редко бывает ситуация, когда маски не применимы. Практически всегда экстеншены в правилах маршрутизации указываются в виде масок. Например, одной маской можно указать все внутренние телефонные линии SIP, одной маской можно указать сразу все междугородние вызовы, либо масками разделить вызовы по направлениям (мобильным операторам).\nФильтр экстеншенов (адресов вызываемых абонентов) может быть диалпланом или планом набора, т.е. цифры номера вызываемого абонента или маски номера, а так же может быть специальным экстеншеном. Вот специальные экстеншены, которые можно использовать вмето диалплана:\ni (invalid) — ошибка в наборе s (start) — входящий вызов без адреса h (hangup) — после отбоя t (timeout) — по таймауту T (absolute timeout) — по системному таймауту asterisk Например, после отбоя необходимо напечатать в консоль фразу «Call complete». Дополним наши правила в том же блоке файла extenstions.conf строкой:\nexten =\u0026gt; h,1,Verbose(\u0026#34;Call complete\u0026#34;) В данном случае в качестве экстеншена используется не диалплан, а специальный экстеншн h, правила по которому срабатывает после завершения вызова. Действием на данное правило будет команда Verbose, которая предназначена для отладки. При выполнении этой команды происходит вывод в консоль аргумента, указанного в этой команде.\nТеперь о масках (шаблонах) # Если экстеншн записывается в виде шаблона, то он должен начинаться с символа подчеркивания _.\nВ масках используются следующие символы:\nX — любая одна цифра от 0 до 9 Z — любая одна цифра от 1 до 9 N — любая одна цифра от 2 до 9 [13-5] — только одна цифра из возможных: 1, 3, 4 или 5 . — любые возможные символы в любом количестве больше нуля Теперь в нашем примере вместо двух экстеншенов можно указать один: _500X или даже _5ХХХ. В первом случае под фильтр попадут все экстеншены от 5000 до 5009, а во втором от 5000 до 5999.\nНо если мы сократим правило до одного, используя такую маску, то возникает вопрос: на какой экстеншн подсистемы SIP направлять вызовы?\nНемного о переменных # Система asterisk поддерживает работу с переменными. Переменные могут быть пользовательскими и содержать необходимые пользовательские данные и системные, которые содержат различные данные о вызове. Переменные записываются следующим образом: ${имя_переменной}.\nВ данной статье затронем только одну переменную, которая содержит экстеншн (адрес). Это переменная ${EXTEN}.\nПри поступлении вызова в переменной ${EXTEN} содержится номер вызываемого абонента (адрес). Это нам и нужно для написания одного единственного правила для осуществления вызовов между абонентами SIP нашей системы.\nИзменим блок в файле extensions.conf, чтобы он выглядел следующим образом:\n[from-sip-lines] exten =\u0026gt; _5XXX,1,Dial(SIP/${EXTEN}) exten =\u0026gt; _5XXX,n,Hangup() exten =\u0026gt; h,1,Verbose(\u0026#34;Call complete\u0026#34;) Теперь можно добавлять сколько угодно четырехзначных номеров SIP, которые начинаются на цифру 5, в нашу систему и не беспокоиться о том, что вызовы между ними не будут работать.\nДанное правило справедливо для всех вызовов, в адресе которых цифры от 5000 до 5999. И команда Dial направит вызов подсистеме SIP на номер, который хранится в переменной ${EXTEN}, то есть на номер, который набрал абонент.\nПосле отбоя сработает правило h и выдаст в консоль фразу «Call complete».\nНа этом всё. В следующей статье будет описана работа с модемами GSM.\n"},{"id":20,"href":"/post/manual-freebsd-install/","title":"Ручная установка FreeBSD на USB flash или HDD","section":"Posts","content":" Ручная установка FreeBSD на USB flash или HDD # Данная статья подойдет как для ручной установки FreeBSD 10 на жесткий диск в целях повышения собственного skill, так и для ручной установки FreeBSD на USB flash накопитель, либо на любой другой накопитель, на который невозможно установить систему стандартными средствами.\nУстановочный образ диска или USB-стика можно скачать на FTP-серверах FreeBSD. Список Украинских зеркал. Для записи образа на USB-стик воспользуйтесь приложением Win32DiskImager.\nУстановка системы # Загружаемся с установочного диска. Нажимаем Enter.\nВ первом диалоговом окне «Welcome» выбираем \u0026lt; Shell \u0026gt; После чего попадаем в оболочку Далее необходимо определить, какие накопители имеются в нашей системе.\ngeom disk list Из вывода следует, что у нас два устройства:\nada0 — жесткий диск (IDE Hard Drive) cd0 — дисковод Посмотрим, нет ли на жестком диске какой либо разметки:\ngpart show ada0 Наш жесткий диск не размечен.\nСоздадим разметку GPT и посмотрим, что произошло:\ngpart create -s gpt /dev/ada0 gpart show ada0 Теперь наш диск имеет разметку GPT. Начальный номер блока LBA, который мы можем использовать, = 34. Блоки LBA с 0 по 33 зарезервированы. Во второй колонке можно увидеть количество доступных блоков LBA. Размер блока LBA = 512 байт.\nЕсли установка производится на современные жесткие диски, у которых размер сектора = 4 кб, то при создании разделов (партиций) необходимо использовать выравнивание. Можно поступить двумя способами: 1) если указываем параметры раздела в блоках, то номер блока вводить кратным 8, например: -b 40; 2) если указываем размер раздела в байтах, либо не указываем вообще начало и размер, использовать параметр -a 4k, который подгонит начало и конец раздела под секторы, размером 4 кб. Так как мы в данном примере производим тестовую установку на виртуальный жесткий диск либо на флеш-накопитель, то этого можно не делать. В любом случае перед созданием разделов нужно точно знать размер сектора вашего накопителя, иначе это выльется жуткими тормозами в работе.\nДалее необходимо создать разделы (партиции). В минимальной системе должно быть три основные раздела: загрузочный, подкачка, корневой. При необходимости можно выносить отдельные части файловой системы (например /usr или /var) на отдельные разделы, но в данном примере делать этого мы не будем. При создании разделов их размер указывается в блоках. Вы вполне можете указывать размер в килобайтах / мегабайтах / гигабайтах, для этого достаточно использовать следующую запись: 64k, 128M, 2G, однако такой подход не совсем правильный, т.к. система ведет пересчет в LBA и, в конечном итоге, может получиться не совсем ожидаемый результат (например: пустой блок размером 1 LBA в конце диска). Выполним создание разделов, используя различные способы:\ngpart add -b 34 -s 128 -t freebsd-boot /dev/ada0 gpart add -s 2G -t freebsd-swap /dev/ada0 gpart add -t freebsd-ufs /dev/ada0 Первая команда создает раздел типа freebsd-boot, начиная с LBA 34 и размером 128 LBA (64 кб). Вторая команда создает раздел типа freebsd-swap, начиная с первого свободного LBA и размером 2 Гб (кол-во LBA рассчитываются автоматически). Третья команда создает раздел типа freebsd-ufs, начиная с первого свободного LBA и до последнего возможного LBA.\nТеперь установим загрузчик в первый раздел и отформатируем третий, затем проверим тип файловой системы на нем:\ngpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 /dev/ada0 newfs -U /dev/ada0p3 file -s /dev/ada0p3 После форматирования раздела /dev/ada0p3, на нем должна находиться файловая система UFS (Unix File System) версии 2.\nДалее подмонтируем только что созданный и отформатированный раздел диска к нашей работающей системе, чтобы иметь возможность работать с ним:\nmount -t ufs -o rw /dev/ada0p3 /mnt Дальнейшие действия зависят от источника файлов установки.\nПервый вариант # Установка производится с образа bootonly, либо есть необходимость производить установку именно по сети. В этом случае необходимо настроить сетевое подключение (допустим, что мы используем DHCP) и загрузить файлы во временную папку, которую мы создадим на нашем диске.\nОпределим имена сетевых интерфейсов и включим на необходимом DHCP-клиент:\nifconfig dhclient em0 Создадим временный каталог на жестком диске для файлов дистрибутива и загрузим в него минимально необходимые файлы для установки, затем извлечем их содержимое в корневой раздел диска, который мы примонтировали в каталог /mnt, затем удалим временный каталог:\nmkdir /mnt/data/ fetch ftp://ftp.ua.freebsd.org/pub/FreeBSD/releases/amd64/10.1-RELEASE/base.txz -o /mnt/data fetch ftp://ftp.ua.freebsd.org/pub/FreeBSD/releases/amd64/10.1-RELEASE/kernel.txz -o /mnt/data cat /mnt/data/base.txz | tar -xpJf - -C /mnt cat /mnt/data/kernel.txz | tar -xpJf - -C /mnt rm -rf /mnt/data/ Второй вариант # Установка производится с полного образа и файлы будут использованы именно с установочного диска. Выполним извлечение файлов из двух основных файлов дистрибутива:\ncat /usr/freebsd-dist/base.txz | tar -xpJf - -C /mnt cat /usr/freebsd-dist/kernel.txz | tar -xpJf - -C /mnt На данном этапе базовая установка системы завершена. Осталось внести некоторые изменения в конфигурационные файлы, а именно в файл /etc/fstab внести информацию о разделах, которые необходимо автоматически монтировать при загрузке системы, в файл /etc/rc.conf внести информацию о настройках сети (в нашем примере DHCP) и настроить часовой пояс.\nВыполним редактирование файла /etc/fstab. Т. к. наша устанавливаемая система примонтирована в /mnt, то соответственно это будет файл /mnt/etc/fstab\nee /mnt/etc/fstab Добавим строки для монтирования раздела swap и корневого раздела:\n/dev/ada0p2 none swap sw 0 0 /dev/ada0p3 / ufs rw 1 1 Выполним редактирование файла /mnt/etc/rc.conf по тому же принципу. Добавим в файл следующие строки:\nhostname=\u0026#34;myhostname\u0026#34; ifconfig_em0=\u0026#34;DHCP\u0026#34; sshd_enable=\u0026#34;YES\u0026#34; Для настройки часового пояса достаточно скопировать файл, соответствующий ближайшему к вам населенному пункту:\ncp /mnt/usr/share/zoneinfo/Europe/Zaporozhye /mnt/etc/localtime На этом базовая установка завершена.\nУстановленная система не содержит пользователей. А для root не установлен пароль. Используйте команды adduser и passwd для создания пользователей и задания пароля root.\nПерезагружаемся и наслаждаемся.\nshutdown -r now Установка системы на USB-флешку # Установка системы на флешку ничем не отличается от установки на жесткий диск, за исключением того, что раздел swap крайне желательно создать на жестком диске. Установку на флешку не обязательно производить с установочного компакт-диска. Достаточно подключить флешку к компьютеру, на котором уже установлена ОС FreeBSD и выполнить все по приведенной выше инструкции, но только не с накопителем /dev/ada0, а с накопителем /dev/ad0 (либо подобным).\nИсключением является лишь то, что после установки системы и после ее первой загрузки, когда сформированы и записаны на носитель все сертификаты и ключи, необходимо выполнить некоторые настройки, а именно: в файле fstab указать, что флешка должна монтироваться в режиме только чтение, указать объем монтируемых в ОЗУ разделов /tmp и /var, создать символические ссылки для тех каталогов, файлы в которых должны сохраняться после перезагрузки.\nЕсли никаких жестких дисков, кроме USB-флешки, нет, то файл /etc/fstab должен выглядеть следующим образом:\n/dev/ad0p2 none swap sw 0 0 /dev/ad0p3 / ufs ro 1 1 Если в системе имеется жесткий диск, то целесообразно создать раздел swap на нем. В этом случае на флешке будет только два раздела: загрузочный и корневой. Тогда файл /etc/fstab будет выглядеть примерно так:\n/dev/ada0p1 none swap sw 0 0 /dev/ad0p2 / ufs ro 1 1 В файл /etc/rc.conf добавляем строки:\nvarmfs=true varsize=96M tmpmfs=true tmpsize=48M Для того, чтобы каталоги, находящиеся в /var (который расположен в ОЗУ), сохранялись после перезагрузки, необходимо сделать для них символические ссылки на флешке. Для примера, чтобы корректно работал пакетный менеджер pkg, необходимо для начала создать на флешке каталоги для символических ссылок.\nВыполните:\nmkdir /usr/local/pkg mkdir /usr/local/pkgcache Затем в конец файла /etc/rc.d/var необходимо добавить строки:\nrm -r /var/db/pkg rm -r /var/cache/pkg ln -s /usr/local/pkg /var/db/pkg ln -s /usr/local/pkgcache /var/cache/pkg Теперь, после загрузки системы, будут удалены каталоги /var/db/pkg и /var/cache/pkg, расположенные в ОЗУ, и на их место будут подмонтированы каталоги с флешки со всеми необходимыми файлами.\nНа этом настройка работы FreeBSD с флеш-памяти завершена. После перезагрузки корневой раздел будет подмонтирован в режиме только чтение, а каталоги /var и /tmp будут подмонтированы в ОЗУ. Такой подход позволяет избежать преждевременного износа флеш-памяти. В каталоги /var/db и /var/cache, расположенные во флеш-памяти, будут подмонтированы каталогиис файлами, расположенные на флеш-накопителе.\nПосле этого, если будет необходимо внести какие либо изменения в файловую систему (изменить конфигурационные файлы, добавить пользователей, установить пакеты и т.д.) сначала нужно будет перемонтировать корневой раздел в режиме записи на лету. Делается это командой:\nmount -uw / После окончания работ с файловой системой, верните корневой каталог в режим только для чтения.\nmount -ur / На этом настройка операционной системы FreeBSD, установленной на флеш-накопитель, завершена.\n"},{"id":21,"href":"/post/apache24php56win7/","title":"Apache 2.4 + PHP 5.6 + MySQL 5.6 на Windows 7, 10","section":"Posts","content":" Apache 2.4 + PHP 5.6 + MySQL 5.6 на Windows 7, 10 # В статье описывается установка Apache 2.4 + PHP 5.6 + MySQL 5.6 на операционную систему Windows 7 / 8 / 8.1 / 10\nДанная инструкция будет полезна начинающим WEB-разработчикам, которые собираются установить на своем ПК с ОС Windows WEB-сервер Apache с интерпретатором PHP последних версий. Конечно же, намного проще установить сборку, наподобие Denwer или прибегнуть к использованию инсталляторов и не париться по поводу настроек. Однако каждый WEB-разработчик обязан понимать процесс работы WEB-сервера, процесс его установки и настройки.\nЕсли Вы хотите установить PHP 7, то после прочтения этой статьи обратитесь к этой статье.\nЕсли в процессе сборки сервера по этой инструкции Вы столкнулись с проблемами и все еще считаете себя WEB-разработчиком, то будет правильным шагом разобраться в возникших проблемах, а не писать в комментарии что инструкция говно. Инструкция рабочая. Проверено временем и сотнями инсталляций. Будьте внимательней при выполнении простых шагов. Выполнение шагов вручную и разбор ситуаций, если не заработало, добавит Вам skill как разработчику. Если Вы не WEB-разработчик и не планируете им быть, то подыщите простой способ установки в интернете — данная инструкция не для Вас.\nОбратите внимание, что под Windows XP данные версии VC11 запустить будет невозможно (или крайне затруднительно).\nПодготовительные работы # Убедитесь, что у вас именно Windows 7 или новее. Если у Вас Windows XP, данная инструкция не поможет Вам, так как описанная здесь версия Apache не работает под Windows XP.\nУдалите все WEB-серверы, которые устанавливали до этого, зайдите в службы и убедитесь, что там нет служб Apache или IIS. Если у вас уже установлен какой-либо веб-сервер, второй параллельно скорее всего не заработает вовсе.\nЕсли у Вас есть Скайп, обязательно отключите в настройках использование 80 порта. В конечном итоге Вы должны убедиться, что ни одна служба не использует 80й порт.\nДля работы очень желательно иметь файловый менеджер, позволяющий создавать файлы с любыми расширениями, либо, что еще лучше, редактор кода, наподобие Sublime Text или Notepad++ или полноценную IDE.\nСтруктура папок может быть различной, однако данная инструкция написана под определенную структуру и, если ей следовать, всё гарантированно заработает.\nПеред тем как начать, создайте на диске D папку USR, внутри которой создайте 5 подпапкок: apache, php, tmp, www, log. Именно так. Без указания номеров версий.\nВ каталоге www создаем индексные файлы (при помощи файлового менеджера или редактора кода), которые будут нужны для проверки того, что все работает:\nindex.html с содержимым: It works! index.php с содержимым: \u0026lt;?php phpinfo(); ?\u0026gt; В системную переменную PATH добавляем:\n;D:\\USR\\apache;D:\\USR\\apache\\bin;D:\\USR\\php; Замечания! # Приведенные в примерах конфигурационных файлов номера строк могут отличаться для других версий apache и php. Все команды, включая редактирование файлов, должны осуществляться от имени Администратора.\nУстановка Apache 2.4 # Хотя для простой разработки на PHP и нет необходимости в отдельном WEB-сервере (в PHP встроен собственный WEB-сервер, которого почти всегда достаточно для разработки одного проекта), все же рекомендуется произвести установку и настройку WEB-сервера Apache, хотя бы потому, что программист обязан знать эти тонкости. В конечном итоге придется работать с WEB-сервером и придется разбираться с его конфигурацией. Так что приступим.\nЗагружаем Apache 2.4 binaries VC11 под свою систему по ссылке http://www.apachelounge.com/download/VC11/ Скорее всего у Вас 64 разрядная ОС, поэтому Вам понадобится файл с именем, наподобие httpd-2.4.xx-win64-VC11.zip Если нужны какие-то дополнительные модули, их можно загрузить там же (для базовой установки нет необходимости) Разархивируем содержимое папки Apache24 из скаченного архива в D:\\USR\\apache. Обратите внимание, что в D:\\USR\\apache нужно положить не папку Apache24 из архива, а ее содержимое. Инсталлировать ничего не требуется В файле D:\\USR\\apache\\conf\\httpd.conf изменяем значение ServerRoot на \u0026quot;d:/USR/apache\u0026quot; (строка 37) и значение DocumentRoot (и Direcroty) на \u0026quot;d:/USR/www\u0026quot; (строки 242 и 243). Так же следует раскомментировать строку 218 и изменить ее на: ServerName localhost:80 Изменяем параметры хранения логов в том же файле (находим параметры и изменяем): ErrorLog \u0026#34;D:/USR/log/apache-error.log\u0026#34; CustomLog \u0026#34;D:/USR/log/apache-access.log\u0026#34; common Устанавливаем сервис Apache (от имени Администратора). Открываем командную строку от имени Администратора и вставляем туда следующую строку: D:\\USR\\apache\\bin\\httpd.exe -k install Следим за сообщениями об ошибках во время установки сервиса. Если все сделано верно, никаких ошибок быть не должно. Если у вас после выполнения строки не появилась снова командная строка, то вы что-то сделали неправильно. Просто воспользуйтесь функциями скопировать и вставить, чтобы не допускать ошибок при перепечатке. Создаем на рабочем столе ярлык для D:\\USR\\apache\\bin\\ApacheMonitor.exe и/или помещаем его в автозагрузку (для открытия окна автозагрузки в WIN8 необходимо нажать WIN+R, затем ввести shell:Startup и нажать ОК) Запускаем «ApacheMonitor». В системном трее появится ярлык. Нажимаем на него левой кнопкой, выбираем Apache24 -\u0026gt; Start В браузере заходим на http://localhost/ - должны увидеть It works! Если не увидели такой надписи, разбираемся, что пошло не так (читаем логи, гуглим, пытаемся самостоятельно разобраться с проблемой, раз уж решили разбираться в тонкостях работы веб-сервера) Установка PHP 5.6 # Загружаем последнюю версию VC11 x86 Thread Safe или VC11 x64 Thread Safe по ссылке http://windows.php.net/download/. Обратите внимание, что нужен именно VC11 и именно Thread Safe. Разрядность должна быть как у Apache. Файл, который Вам нужен, скорее всего будет называться наподобие: php-5.6.11-Win32-VC11-x86.zip или php-5.6.11-Win32-VC11-x64.zip Извлекаем содержимое архива в D:\\USR\\php. Как в случае с Apache, инсталлировать ничего не требуется В файл D:\\USR\\apache\\conf\\httpd.conf добавляем строки: LoadModule php5_module \u0026#34;d:/USR/php/php5apache2_4.dll\u0026#34; AddHandler application/x-httpd-php .php # Путь к файлу php.ini PHPIniDir \u0026#34;D:/USR/php\u0026#34; И изменяем значение DirectoryIndex на index.html index.php (строка 276) Используя «ApacheMonitor» перезапускаем Apache (Apache24 -\u0026gt; Restart) Заходим браузером http://localhost/index.php и убеждаемся, что PHP работает. Делаем копию файла D:\\USR\\php\\php.ini-development с именем D:\\USR\\php\\php.ini Пользуясь поиском находим, раскомментируем и изменяем параметры: extension_dir = \u0026#34;D:/USR/php/ext\u0026#34; sys_temp_dir = \u0026#34;D:/USR/tmp\u0026#34; extension=php_mysql.dll extension=php_mysqli.dll extension=php_openssl.dll date.timezone = Europe/Zaporozhye Выполняем в командной строке php -m чтобы просмотреть список подключенных модулей. Перезапускаем Apache используя «ApacheMonitor» Виртуальные хосты в Apache # Если на компьютере производится отладка нескольких проектов, то могут понадобиться виртуальные хосты (сайты). На примере будем рассматривать два виртуальных хоста: s1.localhost и s2.localhost. Для удобства будем создавать папки с такими же названиями, что совсем не обязательно в реальной системе. Следует учесть, что при использовании виртуальных хостов, параметр DocumentRoot конфигурационного файла Apache более не имеет смысла. Основным хостом сервера (который будет доступен по адресу http://localhost/) теперь является первый виртуальный хост в конфигурационном файле виртуальных хостов! Для начала необходимо добавить в файл c:\\Windows\\System32\\drivers\\etc\\hosts строки: 127.0.0.1 s1.localhost 127.0.0.1 s2.localhost Делать это нужно от имени Администратора. Желательно после этого перезагрузиться, но на практике этого не требовалось. Если изменить файл не удается (права доступа), вы можете скопировать его на рабочий стол, изменить, а затем скопировать обратно. Создаем папки для виртуальных хостов D:\\USR\\www\\s1.localhost и D:\\USR\\www\\s2.localhost, в которых будут располагаться файлы. В каждой из папок создаем файл index.html с содержимым S1 и S2 соответственно (для контроля того, что все работает как нужно) Затем создаем папки для логов: D:\\USR\\log\\s1.localhost и D:\\USR\\log\\s2.localhost — тут будут храниться логи каждого из сайтов. Вообще-то, логи можно хранить в одной папке, но я привык делать так — мне так более удобно. Далее необходимо включить поддержку виртуальных хостов. В файле D:\\USR\\apache\\conf\\httpd.conf раскомментировать строку Include conf/extra/httpd-vhosts.conf Далее редактируем файл d:\\USR\\apache\\conf\\extra\\httpd-vhosts.conf - он должен выглядеть так (каждому виртуальному хосту свой блок VirtualHost): \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin webmaster@s1.localhost DocumentRoot \u0026#34;D:/USR/www/s1.localhost\u0026#34; ServerName s1.localhost ServerAlias www.s1.localhost ErrorLog \u0026#34;D:/USR/log/s1.localhost/error.log\u0026#34; CustomLog \u0026#34;D:/USR/log/s1.localhost/access.log\u0026#34; common \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin webmaster@s2.localhost DocumentRoot \u0026#34;D:/USR/www/s2.localhost\u0026#34; ServerName s2.localhost ServerAlias www.s2.localhost ErrorLog \u0026#34;D:/USR/log/s2.localhost/error.log\u0026#34; CustomLog \u0026#34;D:/USR/log/s2.localhost/access.log\u0026#34; common \u0026lt;/VirtualHost\u0026gt; Первый виртуальный хост s1.localhost теперь будет основным хостом системы, т.к. его блок следует первым в конфигурационном файле, т.е. будет доступен при входе на http://localhost/ Перезапускаем Apache используя ApacheMonitor и заходим по очереди на http://s1.localhost/ и http://s2.localhost/. Итак. Для добавления нового виртуального хоста будет достаточно: создать папку для файлов хоста в D:\\USR\\www, создать папку для логов хоста в D:\\USR\\log, прописать имя хоста в файле hosts, добавить блок VirtualHost в файл конфигурации виртуальных хостов. Установка MySQL 5.6 # Загружаем MySQL Installer MSI (mysql-installer-community) по ссылке: http://dev.mysql.com/downloads/windows/installer/5.6.html Во время установки на этапе Choosing a Setup Type выбираем: Custom, затем удаляем из устанавливаемых продуктов всё (в правой колонке), за исключением самого MySQL сервера (автоматически будут добавлены необходимые обязательные модули). Проще удалить все и добавить только сервер — все необходимые компоненты при этом добавятся сами Запускаем установку, нажав на Execute в следующем окне После установки сервера нажимаем несколько раз Next и переходим к конфигурированию сервера Выбираем тип Development Machine, опции оставляем как есть и нажимаем Next Устанавливаем пароль основного пользователя root (обязательно) — здесь же можно добавить пользователей, но пока этого делать не нужно, нажимаем Next Указываем, нужно ли сделать так, чтобы сервер запускался автоматически со стартом Windows (у меня автозапуск выключен, т.к. локальный MySQL-сервер используется только для отладки в очень редких случаях), нажимаем Next апускаем конфигурирование кнопкой Execute. Всё должно пройти успешно, после чего нажимаем Next и затем Finish Установка сервера MySQL завершена. Поздравляем! Если вы оставили в настройках автозагрузку сервера, то более ничего делать не нужно. Сервер MySQL будет запускаться автоматически вместе со стартом операционной системы Windows. Иначе придется запускать сервер из окна Службы панели Управления компьютером Windows (или написать свой минискрипт для запуска и остановки службы). Я работаю на ноутбуке и постоянно запущенный сервер мне не нужен (расход ресурсов). Для работы с MySQL сервером есть множество полезных и удобных утилит. Я рекомендую использовать dbforge Studio for MySQL. При помощи этого инструмента можно создавать пользователей БД и назначать права доступа. Возможно, есть более удобные и быстрые инструменты. Из всех, что я использовал, этот наиболее функциональный, хоть и не особо быстрый. Часто задаваемые вопросы (FAQ) # Q: В браузере отображается РНР-сценарий вместо результата.\nA: Вы невнимательно читали статью и все таки скачали не ту версию РНР, которая требуется. Обращаю еще раз внимание — нужна именно Thread Safe версия РНР, разрядность которой должна совпадать с разрядностью Apache. Убедиться в том, что ошибка именно в этом можно по отсутствию файла d:/USR/php/php5apache2_4.dll. Почему-то это самая частая проблема, хотя в тексте на этом специально заострено внимание.\nQ: При старте Apache ошибка: The requested operation has failed.\nA: Apache VC11 не работает под Windows XP. Если у Вас Windows 7-10, то проверьте, чтобы порт 80 не был занят другими процессами, например каким нибудь другим WEB-сервером, который Вы устанавливали до этого. Проверьте, чтобы в приложении Skype было отключено использование 80 порта.\nQ: При старте Apache ошибка об отсутствии библиотек типа VCRUNTIME140.dll и тому подобных, название которых содержит VC.\nA: Установите пакет Visual C++ с сайта Microsoft по ссылке.\nQ: Как установить PHPMyAdmin?\nA: PHPMyAdmin — это такое же WEB-приложение, как и любое другое. Создайте для него виртуальный хост по инструкции из этой статьи, как для любого другого сайта, разархивируйте архив с PHPMyAdmin в созданную для хоста папку, перейдите в браузере на адрес этого виртуального хоста и следуйте инструкция по установке. За более подробной информацией обращайтесь на сайт PHPMyAdmin.\n"}]